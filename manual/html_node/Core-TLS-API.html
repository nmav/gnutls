<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This manual is last updated 4 March 2015 for version
3.5.3 of GnuTLS.

Copyright (C) 2001-2015 Free Software Foundation, Inc.\\
Copyright (C) 2001-2015 Nikos Mavrogiannopoulos

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled "GNU Free
Documentation License". -->
<!-- Created by GNU Texinfo 6.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>GnuTLS 3.5.3: Core TLS API</title>

<meta name="description" content="GnuTLS 3.5.3: Core TLS API">
<meta name="keywords" content="GnuTLS 3.5.3: Core TLS API">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="Function-and-Data-Index.html#Function-and-Data-Index" rel="index" title="Function and Data Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="API-reference.html#API-reference" rel="up" title="API reference">
<link href="Datagram-TLS-API.html#Datagram-TLS-API" rel="next" title="Datagram TLS API">
<link href="API-reference.html#API-reference" rel="prev" title="API reference">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
body { 
	margin: 2%;
	padding: 0 5%;
	background: #ffffff;
}
h1,h2,h3,h4,h5 {
    font-weight: bold;
    padding: 5px 5px 5px 5px;
    background-color: #c2e0ff;
    color: #336699;
}
h1 {
    padding: 2em 2em 2em 5%;
    color: white;
    background: #336699;
    text-align: center;
    letter-spacing: 3px;
}
h2 { text-decoration: underline; }
pre {
  margin: 0 5%;
  padding: 0.5em;
}
pre.example,pre.verbatim {
  padding-bottom: 1em;

  border: solid #c2e0ff;
  background: #f0faff;
  border-width: 1px 1px 1px 5px;
  margin: 1em auto;
  width: 90%;
}

div.node {
  margin: 0 -5% 0 -2%;
  padding: 0.5em 0.5em;
  margin-top: 0.5em;
  margin-bottom: 0.5em;
  font-weight: bold;
}
dd, li {
  padding-top: 0.1em;
  padding-bottom: 0.1em;
}
div.float {

  margin-bottom: 0.5em;
  text-align: center;
}

table {
  text-align: left;
  margin-left:auto;
  margin-right:auto;
  border-spacing: 7px;
  width: 50%;
}

th {
  padding: 0;
  color: #336699;
  background-color: #c2e0ff;
  border: solid #000000;
  border-width: 0px;
  margin: 1em auto;
  text-align: center;
  margin-left:auto;
  margin-right:auto;
}

td {
  padding: 0;
  border: solid #000000;
  background-color: #f0faff;
  border-width: 0px;
  margin: 1em auto;
  text-align: left;
  margin-left:auto;
  margin-right:auto;
  padding-left: 1em;
}

dl {
  text-align: left;
  margin-left:auto;
  margin-right:auto;
  width: 50%;

  padding-left: 1em;
  border: solid #c2e0ff;
  background: #f0faff;
  border-width: 5px 1px 1px 1px;
  margin: 1em auto;
}

-->
</style>


</head>

<body lang="en">
<a name="Core-TLS-API"></a>
<div class="header">
<p>
Next: <a href="Datagram-TLS-API.html#Datagram-TLS-API" accesskey="n" rel="next">Datagram TLS API</a>, Up: <a href="API-reference.html#API-reference" accesskey="u" rel="up">API reference</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Function-and-Data-Index.html#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="Core-TLS-API-1"></a>
<h3 class="section">E.1 Core TLS API</h3>

<p>The prototypes for the following functions lie in
<samp>gnutls/gnutls.h</samp>.
</p>

<a name="gnutls_005falert_005fget-1"></a>
<h4 class="subheading">gnutls_alert_get</h4>
<a name="gnutls_005falert_005fget"></a><dl>
<dt><a name="index-gnutls_005falert_005fget-1"></a>Function: <em>gnutls_alert_description_t</em> <strong>gnutls_alert_get</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function will return the last alert number received.  This
function should be called when <code>GNUTLS_E_WARNING_ALERT_RECEIVED</code>  or
<code>GNUTLS_E_FATAL_ALERT_RECEIVED</code>  errors are returned by a gnutls
function.  The peer may send alerts if he encounters an error.
If no alert has been received the returned value is undefined.
</p>
<p><strong>Returns:</strong> the last alert received, a
<code>gnutls_alert_description_t</code>  value.
</p></dd></dl>

<a name="gnutls_005falert_005fget_005fname-1"></a>
<h4 class="subheading">gnutls_alert_get_name</h4>
<a name="gnutls_005falert_005fget_005fname"></a><dl>
<dt><a name="index-gnutls_005falert_005fget_005fname-1"></a>Function: <em>const char *</em> <strong>gnutls_alert_get_name</strong> <em>(gnutls_alert_description_t <var>alert</var>)</em></dt>
<dd><p><var>alert</var>: is an alert number.
</p>
<p>This function will return a string that describes the given alert
number, or <code>NULL</code> .  See <code>gnutls_alert_get()</code> .
</p>
<p><strong>Returns:</strong> string corresponding to <code>gnutls_alert_description_t</code>  value.
</p></dd></dl>

<a name="gnutls_005falert_005fget_005fstrname-1"></a>
<h4 class="subheading">gnutls_alert_get_strname</h4>
<a name="gnutls_005falert_005fget_005fstrname"></a><dl>
<dt><a name="index-gnutls_005falert_005fget_005fstrname"></a>Function: <em>const char *</em> <strong>gnutls_alert_get_strname</strong> <em>(gnutls_alert_description_t <var>alert</var>)</em></dt>
<dd><p><var>alert</var>: is an alert number.
</p>
<p>This function will return a string of the name of the alert.
</p>
<p><strong>Returns:</strong> string corresponding to <code>gnutls_alert_description_t</code>  value.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<a name="gnutls_005falert_005fsend-1"></a>
<h4 class="subheading">gnutls_alert_send</h4>
<a name="gnutls_005falert_005fsend"></a><dl>
<dt><a name="index-gnutls_005falert_005fsend-1"></a>Function: <em>int</em> <strong>gnutls_alert_send</strong> <em>(gnutls_session_t <var>session</var>, gnutls_alert_level_t <var>level</var>, gnutls_alert_description_t <var>desc</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>level</var>: is the level of the alert
</p>
<p><var>desc</var>: is the alert description
</p>
<p>This function will send an alert to the peer in order to inform
him of something important (eg. his Certificate could not be verified).
If the alert level is Fatal then the peer is expected to close the
connection, otherwise he may ignore the alert and continue.
</p>
<p>The error code of the underlying record send function will be
returned, so you may also receive <code>GNUTLS_E_INTERRUPTED</code>  or
<code>GNUTLS_E_AGAIN</code>  as well.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p></dd></dl>

<a name="gnutls_005falert_005fsend_005fappropriate-1"></a>
<h4 class="subheading">gnutls_alert_send_appropriate</h4>
<a name="gnutls_005falert_005fsend_005fappropriate"></a><dl>
<dt><a name="index-gnutls_005falert_005fsend_005fappropriate"></a>Function: <em>int</em> <strong>gnutls_alert_send_appropriate</strong> <em>(gnutls_session_t <var>session</var>, int <var>err</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>err</var>: is an integer
</p>
<p>Sends an alert to the peer depending on the error code returned by
a gnutls function. This function will call <code>gnutls_error_to_alert()</code> 
to determine the appropriate alert to send.
</p>
<p>This function may also return <code>GNUTLS_E_AGAIN</code> , or
<code>GNUTLS_E_INTERRUPTED</code> .
</p>
<p>If the return value is <code>GNUTLS_E_INVALID_REQUEST</code> , then no alert has
been sent to the peer.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p></dd></dl>

<a name="gnutls_005falpn_005fget_005fselected_005fprotocol-1"></a>
<h4 class="subheading">gnutls_alpn_get_selected_protocol</h4>
<a name="gnutls_005falpn_005fget_005fselected_005fprotocol"></a><dl>
<dt><a name="index-gnutls_005falpn_005fget_005fselected_005fprotocol"></a>Function: <em>int</em> <strong>gnutls_alpn_get_selected_protocol</strong> <em>(gnutls_session_t <var>session</var>, gnutls_datum_t * <var>protocol</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>protocol</var>: will hold the protocol name
</p>
<p>This function allows you to get the negotiated protocol name. The
returned protocol should be treated as opaque, constant value and
only valid during the session life.
</p>
<p>The selected protocol is the first supported by the list sent
by the client.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p>
<p>Since 3.2.0
</p></dd></dl>

<a name="gnutls_005falpn_005fset_005fprotocols-1"></a>
<h4 class="subheading">gnutls_alpn_set_protocols</h4>
<a name="gnutls_005falpn_005fset_005fprotocols"></a><dl>
<dt><a name="index-gnutls_005falpn_005fset_005fprotocols"></a>Function: <em>int</em> <strong>gnutls_alpn_set_protocols</strong> <em>(gnutls_session_t <var>session</var>, const gnutls_datum_t * <var>protocols</var>, unsigned <var>protocols_size</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>protocols</var>: is the protocol names to add.
</p>
<p><var>protocols_size</var>: the number of protocols to add.
</p>
<p><var>flags</var>: zero or a sequence of <code>gnutls_alpn_flags_t</code> 
</p>
<p>This function is to be used by both clients and servers, to declare
the supported ALPN protocols, which are used during negotiation with peer.
</p>
<p>See <code>gnutls_alpn_flags_t</code>  description for the documentation of available
flags.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p>
<p>Since 3.2.0
</p></dd></dl>

<a name="gnutls_005fanon_005fallocate_005fclient_005fcredentials-1"></a>
<h4 class="subheading">gnutls_anon_allocate_client_credentials</h4>
<a name="gnutls_005fanon_005fallocate_005fclient_005fcredentials"></a><dl>
<dt><a name="index-gnutls_005fanon_005fallocate_005fclient_005fcredentials"></a>Function: <em>int</em> <strong>gnutls_anon_allocate_client_credentials</strong> <em>(gnutls_anon_client_credentials_t *      <var>sc</var>)</em></dt>
<dd><p><var>sc</var>: is a pointer to a <code>gnutls_anon_client_credentials_t</code>  type.
</p>
<p>Allocate a gnutls_anon_client_credentials_t structure.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, or an error code.
</p></dd></dl>

<a name="gnutls_005fanon_005fallocate_005fserver_005fcredentials-1"></a>
<h4 class="subheading">gnutls_anon_allocate_server_credentials</h4>
<a name="gnutls_005fanon_005fallocate_005fserver_005fcredentials"></a><dl>
<dt><a name="index-gnutls_005fanon_005fallocate_005fserver_005fcredentials"></a>Function: <em>int</em> <strong>gnutls_anon_allocate_server_credentials</strong> <em>(gnutls_anon_server_credentials_t *      <var>sc</var>)</em></dt>
<dd><p><var>sc</var>: is a pointer to a <code>gnutls_anon_server_credentials_t</code>  type.
</p>
<p>Allocate a gnutls_anon_server_credentials_t structure.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, or an error code.
</p></dd></dl>

<a name="gnutls_005fanon_005ffree_005fclient_005fcredentials-1"></a>
<h4 class="subheading">gnutls_anon_free_client_credentials</h4>
<a name="gnutls_005fanon_005ffree_005fclient_005fcredentials"></a><dl>
<dt><a name="index-gnutls_005fanon_005ffree_005fclient_005fcredentials"></a>Function: <em>void</em> <strong>gnutls_anon_free_client_credentials</strong> <em>(gnutls_anon_client_credentials_t <var>sc</var>)</em></dt>
<dd><p><var>sc</var>: is a <code>gnutls_anon_client_credentials_t</code>  type.
</p>
<p>Free a gnutls_anon_client_credentials_t structure.
</p></dd></dl>

<a name="gnutls_005fanon_005ffree_005fserver_005fcredentials-1"></a>
<h4 class="subheading">gnutls_anon_free_server_credentials</h4>
<a name="gnutls_005fanon_005ffree_005fserver_005fcredentials"></a><dl>
<dt><a name="index-gnutls_005fanon_005ffree_005fserver_005fcredentials"></a>Function: <em>void</em> <strong>gnutls_anon_free_server_credentials</strong> <em>(gnutls_anon_server_credentials_t <var>sc</var>)</em></dt>
<dd><p><var>sc</var>: is a <code>gnutls_anon_server_credentials_t</code>  type.
</p>
<p>Free a gnutls_anon_server_credentials_t structure.
</p></dd></dl>

<a name="gnutls_005fanon_005fset_005fparams_005ffunction-1"></a>
<h4 class="subheading">gnutls_anon_set_params_function</h4>
<a name="gnutls_005fanon_005fset_005fparams_005ffunction"></a><dl>
<dt><a name="index-gnutls_005fanon_005fset_005fparams_005ffunction"></a>Function: <em>void</em> <strong>gnutls_anon_set_params_function</strong> <em>(gnutls_anon_server_credentials_t <var>res</var>, gnutls_params_function * <var>func</var>)</em></dt>
<dd><p><var>res</var>: is a gnutls_anon_server_credentials_t type
</p>
<p><var>func</var>: is the function to be called
</p>
<p>This function will set a callback in order for the server to get
the Diffie-Hellman or RSA parameters for anonymous authentication.
The callback should return <code>GNUTLS_E_SUCCESS</code>  (0) on success.
</p></dd></dl>

<a name="gnutls_005fanon_005fset_005fserver_005fdh_005fparams-1"></a>
<h4 class="subheading">gnutls_anon_set_server_dh_params</h4>
<a name="gnutls_005fanon_005fset_005fserver_005fdh_005fparams"></a><dl>
<dt><a name="index-gnutls_005fanon_005fset_005fserver_005fdh_005fparams"></a>Function: <em>void</em> <strong>gnutls_anon_set_server_dh_params</strong> <em>(gnutls_anon_server_credentials_t <var>res</var>, gnutls_dh_params_t <var>dh_params</var>)</em></dt>
<dd><p><var>res</var>: is a gnutls_anon_server_credentials_t type
</p>
<p><var>dh_params</var>: The Diffie-Hellman parameters.
</p>
<p>This function will set the Diffie-Hellman parameters for an
anonymous server to use.  These parameters will be used in
Anonymous Diffie-Hellman cipher suites.
</p></dd></dl>

<a name="gnutls_005fanon_005fset_005fserver_005fparams_005ffunction-1"></a>
<h4 class="subheading">gnutls_anon_set_server_params_function</h4>
<a name="gnutls_005fanon_005fset_005fserver_005fparams_005ffunction"></a><dl>
<dt><a name="index-gnutls_005fanon_005fset_005fserver_005fparams_005ffunction"></a>Function: <em>void</em> <strong>gnutls_anon_set_server_params_function</strong> <em>(gnutls_anon_server_credentials_t            <var>res</var>, gnutls_params_function * <var>func</var>)</em></dt>
<dd><p><var>res</var>: is a gnutls_certificate_credentials_t type
</p>
<p><var>func</var>: is the function to be called
</p>
<p>This function will set a callback in order for the server to get
the Diffie-Hellman parameters for anonymous authentication.  The
callback should return <code>GNUTLS_E_SUCCESS</code>  (0) on success.
</p></dd></dl>

<a name="gnutls_005fauth_005fclient_005fget_005ftype-1"></a>
<h4 class="subheading">gnutls_auth_client_get_type</h4>
<a name="gnutls_005fauth_005fclient_005fget_005ftype"></a><dl>
<dt><a name="index-gnutls_005fauth_005fclient_005fget_005ftype"></a>Function: <em>gnutls_credentials_type_t</em> <strong>gnutls_auth_client_get_type</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Returns the type of credentials that were used for client authentication.
The returned information is to be used to distinguish the function used
to access authentication data.
</p>
<p><strong>Returns:</strong> The type of credentials for the client authentication
schema, a <code>gnutls_credentials_type_t</code>  type.
</p></dd></dl>

<a name="gnutls_005fauth_005fget_005ftype-1"></a>
<h4 class="subheading">gnutls_auth_get_type</h4>
<a name="gnutls_005fauth_005fget_005ftype"></a><dl>
<dt><a name="index-gnutls_005fauth_005fget_005ftype"></a>Function: <em>gnutls_credentials_type_t</em> <strong>gnutls_auth_get_type</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Returns type of credentials for the current authentication schema.
The returned information is to be used to distinguish the function used
to access authentication data.
</p>
<p>Eg. for CERTIFICATE ciphersuites (key exchange algorithms:
<code>GNUTLS_KX_RSA</code> , <code>GNUTLS_KX_DHE_RSA</code> ), the same function are to be
used to access the authentication data.
</p>
<p><strong>Returns:</strong> The type of credentials for the current authentication
schema, a <code>gnutls_credentials_type_t</code>  type.
</p></dd></dl>

<a name="gnutls_005fauth_005fserver_005fget_005ftype-1"></a>
<h4 class="subheading">gnutls_auth_server_get_type</h4>
<a name="gnutls_005fauth_005fserver_005fget_005ftype"></a><dl>
<dt><a name="index-gnutls_005fauth_005fserver_005fget_005ftype"></a>Function: <em>gnutls_credentials_type_t</em> <strong>gnutls_auth_server_get_type</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Returns the type of credentials that were used for server authentication.
The returned information is to be used to distinguish the function used
to access authentication data.
</p>
<p><strong>Returns:</strong> The type of credentials for the server authentication
schema, a <code>gnutls_credentials_type_t</code>  type.
</p></dd></dl>

<a name="gnutls_005fbuffer_005fappend_005fdata-1"></a>
<h4 class="subheading">gnutls_buffer_append_data</h4>
<a name="gnutls_005fbuffer_005fappend_005fdata"></a><dl>
<dt><a name="index-gnutls_005fbuffer_005fappend_005fdata"></a>Function: <em>int</em> <strong>gnutls_buffer_append_data</strong> <em>(gnutls_buffer_t <var>dest</var>, const void * <var>data</var>, size_t <var>data_size</var>)</em></dt>
<dd><p><var>dest</var>: the buffer to append to
</p>
<p><var>data</var>: the data
</p>
<p><var>data_size</var>: the size of  <code>data</code> 
</p>
<p>Appends the provided  <code>data</code> to the destination buffer.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<a name="gnutls_005fbye-1"></a>
<h4 class="subheading">gnutls_bye</h4>
<a name="gnutls_005fbye"></a><dl>
<dt><a name="index-gnutls_005fbye-1"></a>Function: <em>int</em> <strong>gnutls_bye</strong> <em>(gnutls_session_t <var>session</var>, gnutls_close_request_t <var>how</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>how</var>: is an integer
</p>
<p>Terminates the current TLS/SSL connection. The connection should
have been initiated using <code>gnutls_handshake()</code> .   <code>how</code> should be one
of <code>GNUTLS_SHUT_RDWR</code> , <code>GNUTLS_SHUT_WR</code> .
</p>
<p>In case of <code>GNUTLS_SHUT_RDWR</code>  the TLS session gets
terminated and further receives and sends will be disallowed.  If
the return value is zero you may continue using the underlying
transport layer. <code>GNUTLS_SHUT_RDWR</code>  sends an alert containing a close
request and waits for the peer to reply with the same message.
</p>
<p>In case of <code>GNUTLS_SHUT_WR</code>  the TLS session gets terminated
and further sends will be disallowed. In order to reuse the
connection you should wait for an EOF from the peer.
<code>GNUTLS_SHUT_WR</code>  sends an alert containing a close request.
</p>
<p>Note that not all implementations will properly terminate a TLS
connection.  Some of them, usually for performance reasons, will
terminate only the underlying transport layer, and thus not
distinguishing between a malicious party prematurely terminating 
the connection and normal termination. 
</p>
<p>This function may also return <code>GNUTLS_E_AGAIN</code>  or
<code>GNUTLS_E_INTERRUPTED</code> ; cf.  <code>gnutls_record_get_direction()</code> .
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, or an error code, see
function documentation for entire semantics.
</p></dd></dl>

<a name="gnutls_005fcertificate_005factivation_005ftime_005fpeers-1"></a>
<h4 class="subheading">gnutls_certificate_activation_time_peers</h4>
<a name="gnutls_005fcertificate_005factivation_005ftime_005fpeers"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005factivation_005ftime_005fpeers"></a>Function: <em>time_t</em> <strong>gnutls_certificate_activation_time_peers</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p>This function will return the peer&rsquo;s certificate activation time.
This is the creation time for openpgp keys.
</p>
<p><strong>Returns:</strong> (time_t)-1 on error.
</p>
<p><strong>Deprecated:</strong> <code>gnutls_certificate_verify_peers2()</code>  now verifies activation times.
</p></dd></dl>

<a name="gnutls_005fcertificate_005fallocate_005fcredentials-1"></a>
<h4 class="subheading">gnutls_certificate_allocate_credentials</h4>
<a name="gnutls_005fcertificate_005fallocate_005fcredentials"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fallocate_005fcredentials"></a>Function: <em>int</em> <strong>gnutls_certificate_allocate_credentials</strong> <em>(gnutls_certificate_credentials_t *      <var>res</var>)</em></dt>
<dd><p><var>res</var>: is a pointer to a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p>Allocate a gnutls_certificate_credentials_t structure.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, or an error code.
</p></dd></dl>

<a name="gnutls_005fcertificate_005fclient_005fget_005frequest_005fstatus-1"></a>
<h4 class="subheading">gnutls_certificate_client_get_request_status</h4>
<a name="gnutls_005fcertificate_005fclient_005fget_005frequest_005fstatus"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fclient_005fget_005frequest_005fstatus"></a>Function: <em>int</em> <strong>gnutls_certificate_client_get_request_status</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p>Get whether client certificate is requested or not.
</p>
<p><strong>Returns:</strong> 0 if the peer (server) did not request client
authentication or 1 otherwise.
</p></dd></dl>

<a name="gnutls_005fcertificate_005fexpiration_005ftime_005fpeers-1"></a>
<h4 class="subheading">gnutls_certificate_expiration_time_peers</h4>
<a name="gnutls_005fcertificate_005fexpiration_005ftime_005fpeers"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fexpiration_005ftime_005fpeers"></a>Function: <em>time_t</em> <strong>gnutls_certificate_expiration_time_peers</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p>This function will return the peer&rsquo;s certificate expiration time.
</p>
<p><strong>Returns:</strong> (time_t)-1 on error.
</p>
<p><strong>Deprecated:</strong> <code>gnutls_certificate_verify_peers2()</code>  now verifies expiration times.
</p></dd></dl>

<a name="gnutls_005fcertificate_005ffree_005fca_005fnames-1"></a>
<h4 class="subheading">gnutls_certificate_free_ca_names</h4>
<a name="gnutls_005fcertificate_005ffree_005fca_005fnames"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005ffree_005fca_005fnames"></a>Function: <em>void</em> <strong>gnutls_certificate_free_ca_names</strong> <em>(gnutls_certificate_credentials_t <var>sc</var>)</em></dt>
<dd><p><var>sc</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p>This function will delete all the CA name in the given
credentials. Clients may call this to save some memory since in
client side the CA names are not used. Servers might want to use
this function if a large list of trusted CAs is present and
sending the names of it would just consume bandwidth without providing 
information to client.
</p>
<p>CA names are used by servers to advertise the CAs they support to
clients.
</p></dd></dl>

<a name="gnutls_005fcertificate_005ffree_005fcas-1"></a>
<h4 class="subheading">gnutls_certificate_free_cas</h4>
<a name="gnutls_005fcertificate_005ffree_005fcas"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005ffree_005fcas"></a>Function: <em>void</em> <strong>gnutls_certificate_free_cas</strong> <em>(gnutls_certificate_credentials_t <var>sc</var>)</em></dt>
<dd><p><var>sc</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p>This function will delete all the CAs associated with the given
credentials. Servers that do not use
<code>gnutls_certificate_verify_peers2()</code>  may call this to save some
memory.
</p></dd></dl>

<a name="gnutls_005fcertificate_005ffree_005fcredentials-1"></a>
<h4 class="subheading">gnutls_certificate_free_credentials</h4>
<a name="gnutls_005fcertificate_005ffree_005fcredentials"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005ffree_005fcredentials"></a>Function: <em>void</em> <strong>gnutls_certificate_free_credentials</strong> <em>(gnutls_certificate_credentials_t <var>sc</var>)</em></dt>
<dd><p><var>sc</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p>Free a gnutls_certificate_credentials_t structure.
</p>
<p>This function does not free any temporary parameters associated
with this structure (ie RSA and DH parameters are not freed by this
function).
</p></dd></dl>

<a name="gnutls_005fcertificate_005ffree_005fcrls-1"></a>
<h4 class="subheading">gnutls_certificate_free_crls</h4>
<a name="gnutls_005fcertificate_005ffree_005fcrls"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005ffree_005fcrls"></a>Function: <em>void</em> <strong>gnutls_certificate_free_crls</strong> <em>(gnutls_certificate_credentials_t <var>sc</var>)</em></dt>
<dd><p><var>sc</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p>This function will delete all the CRLs associated
with the given credentials.
</p></dd></dl>

<a name="gnutls_005fcertificate_005ffree_005fkeys-1"></a>
<h4 class="subheading">gnutls_certificate_free_keys</h4>
<a name="gnutls_005fcertificate_005ffree_005fkeys"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005ffree_005fkeys"></a>Function: <em>void</em> <strong>gnutls_certificate_free_keys</strong> <em>(gnutls_certificate_credentials_t <var>sc</var>)</em></dt>
<dd><p><var>sc</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p>This function will delete all the keys and the certificates associated
with the given credentials. This function must not be called when a
TLS negotiation that uses the credentials is in progress.
</p></dd></dl>

<a name="gnutls_005fcertificate_005fget_005fcrt_005fraw-1"></a>
<h4 class="subheading">gnutls_certificate_get_crt_raw</h4>
<a name="gnutls_005fcertificate_005fget_005fcrt_005fraw"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fget_005fcrt_005fraw"></a>Function: <em>int</em> <strong>gnutls_certificate_get_crt_raw</strong> <em>(gnutls_certificate_credentials_t <var>sc</var>, unsigned <var>idx1</var>, unsigned <var>idx2</var>, gnutls_datum_t * <var>cert</var>)</em></dt>
<dd><p><var>sc</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>idx1</var>: the index of the certificate chain if multiple are present
</p>
<p><var>idx2</var>: the index of the certificate in the chain. Zero gives the server&rsquo;s certificate.
</p>
<p><var>cert</var>: Will hold the DER encoded certificate.
</p>
<p>This function will return the DER encoded certificate of the
server or any other certificate on its certificate chain (based on  <code>idx2</code> ).
The returned data should be treated as constant and only accessible during the lifetime
of  <code>sc</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value. In case the indexes are out of bounds <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
is returned.
</p>
<p><strong>Since:</strong> 3.2.5
</p></dd></dl>

<a name="gnutls_005fcertificate_005fget_005fissuer-1"></a>
<h4 class="subheading">gnutls_certificate_get_issuer</h4>
<a name="gnutls_005fcertificate_005fget_005fissuer"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fget_005fissuer"></a>Function: <em>int</em> <strong>gnutls_certificate_get_issuer</strong> <em>(gnutls_certificate_credentials_t <var>sc</var>, gnutls_x509_crt_t <var>cert</var>, gnutls_x509_crt_t * <var>issuer</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>sc</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>cert</var>: is the certificate to find issuer for
</p>
<p><var>issuer</var>: Will hold the issuer if any. Should be treated as constant.
</p>
<p><var>flags</var>: Use zero or <code>GNUTLS_TL_GET_COPY</code> 
</p>
<p>This function will return the issuer of a given certificate.
If the flag <code>GNUTLS_TL_GET_COPY</code>  is specified a copy of the issuer
will be returned which must be freed using <code>gnutls_x509_crt_deinit()</code> .
In that case the provided  <code>issuer</code> must not be initialized.
</p>
<p>As with <code>gnutls_x509_trust_list_get_issuer()</code>  this function requires
the <code>GNUTLS_TL_GET_COPY</code>  flag in order to operate with PKCS<code>11</code>  trust
lists in a thread-safe way. 
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<a name="gnutls_005fcertificate_005fget_005fours-1"></a>
<h4 class="subheading">gnutls_certificate_get_ours</h4>
<a name="gnutls_005fcertificate_005fget_005fours"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fget_005fours"></a>Function: <em>const gnutls_datum_t *</em> <strong>gnutls_certificate_get_ours</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p>Gets the certificate as sent to the peer in the last handshake.
The certificate is in raw (DER) format.  No certificate
list is being returned. Only the first certificate.
</p>
<p><strong>Returns:</strong> a pointer to a <code>gnutls_datum_t</code>  containing our
certificate, or <code>NULL</code>  in case of an error or if no certificate
was used.
</p></dd></dl>

<a name="gnutls_005fcertificate_005fget_005fpeers-1"></a>
<h4 class="subheading">gnutls_certificate_get_peers</h4>
<a name="gnutls_005fcertificate_005fget_005fpeers"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fget_005fpeers"></a>Function: <em>const gnutls_datum_t *</em> <strong>gnutls_certificate_get_peers</strong> <em>(gnutls_session_t          <var>session</var>, unsigned int * <var>list_size</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p><var>list_size</var>: is the length of the certificate list (may be <code>NULL</code> )
</p>
<p>Get the peer&rsquo;s raw certificate (chain) as sent by the peer.  These
certificates are in raw format (DER encoded for X.509).  In case of
a X.509 then a certificate list may be present.  The list
is provided as sent by the server; the server must send as first
certificate in the list its own certificate, following the
issuer&rsquo;s certificate, then the issuer&rsquo;s issuer etc. However, there
are servers which violate this principle and thus on certain
occasions this may be an unsorted list.
</p>
<p>In case of OpenPGP keys a single key will be returned in raw
format.
</p>
<p><strong>Returns:</strong> a pointer to a <code>gnutls_datum_t</code>  containing the peer&rsquo;s
certificates, or <code>NULL</code>  in case of an error or if no certificate
was used.
</p></dd></dl>

<a name="gnutls_005fcertificate_005fget_005fpeers_005fsubkey_005fid-1"></a>
<h4 class="subheading">gnutls_certificate_get_peers_subkey_id</h4>
<a name="gnutls_005fcertificate_005fget_005fpeers_005fsubkey_005fid"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fget_005fpeers_005fsubkey_005fid"></a>Function: <em>int</em> <strong>gnutls_certificate_get_peers_subkey_id</strong> <em>(gnutls_session_t <var>session</var>, gnutls_datum_t * <var>id</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p><var>id</var>: will contain the ID
</p>
<p>Get the peer&rsquo;s subkey ID when OpenPGP certificates are
used. The returned  <code>id</code> should be treated as constant.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p>
<p><strong>Since:</strong> 3.1.3
</p></dd></dl>

<a name="gnutls_005fcertificate_005fget_005fverify_005fflags-1"></a>
<h4 class="subheading">gnutls_certificate_get_verify_flags</h4>
<a name="gnutls_005fcertificate_005fget_005fverify_005fflags"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fget_005fverify_005fflags"></a>Function: <em>unsigned int</em> <strong>gnutls_certificate_get_verify_flags</strong> <em>(gnutls_certificate_credentials_t <var>res</var>)</em></dt>
<dd><p><var>res</var>: is a gnutls_certificate_credentials_t type
</p>
<p>Returns the verification flags set with
<code>gnutls_certificate_set_verify_flags()</code> .
</p>
<p><strong>Returns:</strong> The certificate verification flags used by  <code>res</code> .
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<a name="gnutls_005fcertificate_005fget_005fx509_005fcrt-1"></a>
<h4 class="subheading">gnutls_certificate_get_x509_crt</h4>
<a name="gnutls_005fcertificate_005fget_005fx509_005fcrt"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fget_005fx509_005fcrt"></a>Function: <em>int</em> <strong>gnutls_certificate_get_x509_crt</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, unsigned <var>index</var>, gnutls_x509_crt_t ** <var>crt_list</var>, unsigned * <var>crt_list_size</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>index</var>: The index of the certificate list to obtain.
</p>
<p><var>crt_list</var>: Where to store the certificate list.
</p>
<p><var>crt_list_size</var>: Will hold the number of certificates.
</p>
<p>Obtains a X.509 certificate list that has been stored in  <code>res</code> with one of
<code>gnutls_certificate_set_x509_key()</code> , <code>gnutls_certificate_set_key()</code> ,
<code>gnutls_certificate_set_x509_key_file()</code> ,
<code>gnutls_certificate_set_x509_key_file2()</code> ,
<code>gnutls_certificate_set_x509_key_mem()</code> , or
<code>gnutls_certificate_set_x509_key_mem2()</code> . Each certificate in the returned
certificate list must be deallocated with <code>gnutls_x509_crt_deinit()</code> , and the
list itself must be freed with <code>gnutls_free()</code> .
</p>
<p>If there is no certificate with the given index,
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  is returned. If the certificate
with the given index is not a X.509 certificate, <code>GNUTLS_E_INVALID_REQUEST</code> 
is returned. The returned certificates must be deinitialized after
use, and the  <code>crt_list</code> pointer must be freed using <code>gnutls_free()</code> .
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  (0) on success, or a negative error code.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<a name="gnutls_005fcertificate_005fget_005fx509_005fkey-1"></a>
<h4 class="subheading">gnutls_certificate_get_x509_key</h4>
<a name="gnutls_005fcertificate_005fget_005fx509_005fkey"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fget_005fx509_005fkey"></a>Function: <em>int</em> <strong>gnutls_certificate_get_x509_key</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, unsigned <var>index</var>, gnutls_x509_privkey_t * <var>key</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>index</var>: The index of the key to obtain.
</p>
<p><var>key</var>: Location to store the key.
</p>
<p>Obtains a X.509 private key that has been stored in  <code>res</code> with one of
<code>gnutls_certificate_set_x509_key()</code> , <code>gnutls_certificate_set_key()</code> ,
<code>gnutls_certificate_set_x509_key_file()</code> ,
<code>gnutls_certificate_set_x509_key_file2()</code> ,
<code>gnutls_certificate_set_x509_key_mem()</code> , or
<code>gnutls_certificate_set_x509_key_mem2()</code> . The returned key must be deallocated
with <code>gnutls_x509_privkey_deinit()</code>  when no longer needed.
</p>
<p>If there is no key with the given index,
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  is returned. If the key with the
given index is not a X.509 key, <code>GNUTLS_E_INVALID_REQUEST</code>  is returned.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  (0) on success, or a negative error code.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<a name="gnutls_005fcertificate_005fsend_005fx509_005frdn_005fsequence-1"></a>
<h4 class="subheading">gnutls_certificate_send_x509_rdn_sequence</h4>
<a name="gnutls_005fcertificate_005fsend_005fx509_005frdn_005fsequence"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fsend_005fx509_005frdn_005fsequence-1"></a>Function: <em>void</em> <strong>gnutls_certificate_send_x509_rdn_sequence</strong> <em>(gnutls_session_t <var>session</var>, int <var>status</var>)</em></dt>
<dd><p><var>session</var>: a <code>gnutls_session_t</code>  type.
</p>
<p><var>status</var>: is 0 or 1
</p>
<p>If status is non zero, this function will order gnutls not to send
the rdnSequence in the certificate request message. That is the
server will not advertise its trusted CAs to the peer. If status
is zero then the default behaviour will take effect, which is to
advertise the server&rsquo;s trusted CAs.
</p>
<p>This function has no effect in clients, and in authentication
methods other than certificate with X.509 certificates.
</p></dd></dl>

<a name="gnutls_005fcertificate_005fserver_005fset_005frequest-1"></a>
<h4 class="subheading">gnutls_certificate_server_set_request</h4>
<a name="gnutls_005fcertificate_005fserver_005fset_005frequest"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fserver_005fset_005frequest-1"></a>Function: <em>void</em> <strong>gnutls_certificate_server_set_request</strong> <em>(gnutls_session_t <var>session</var>, gnutls_certificate_request_t <var>req</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>req</var>: is one of GNUTLS_CERT_REQUEST, GNUTLS_CERT_REQUIRE
</p>
<p>This function specifies if we (in case of a server) are going to
send a certificate request message to the client. If  <code>req</code> is
GNUTLS_CERT_REQUIRE then the server will return an error if the
peer does not provide a certificate. If you do not call this
function then the client will not be asked to send a certificate.
</p></dd></dl>

<a name="gnutls_005fcertificate_005fset_005fdh_005fparams-1"></a>
<h4 class="subheading">gnutls_certificate_set_dh_params</h4>
<a name="gnutls_005fcertificate_005fset_005fdh_005fparams"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fset_005fdh_005fparams"></a>Function: <em>void</em> <strong>gnutls_certificate_set_dh_params</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, gnutls_dh_params_t <var>dh_params</var>)</em></dt>
<dd><p><var>res</var>: is a gnutls_certificate_credentials_t type
</p>
<p><var>dh_params</var>: the Diffie-Hellman parameters.
</p>
<p>This function will set the Diffie-Hellman parameters for a
certificate server to use. These parameters will be used in
Ephemeral Diffie-Hellman cipher suites.  Note that only a pointer
to the parameters are stored in the certificate handle, so you
must not deallocate the parameters before the certificate is deallocated.
</p></dd></dl>

<a name="gnutls_005fcertificate_005fset_005fflags-1"></a>
<h4 class="subheading">gnutls_certificate_set_flags</h4>
<a name="gnutls_005fcertificate_005fset_005fflags"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fset_005fflags"></a>Function: <em>void</em> <strong>gnutls_certificate_set_flags</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>res</var>: is a gnutls_certificate_credentials_t type
</p>
<p><var>flags</var>: are the flags of <code>gnutls_certificate_flags</code>  type
</p>
<p>This function will set flags to tweak the operation of
the credentials structure. See the <code>gnutls_certificate_flags</code>  enumerations
for more information on the available flags. 
</p>
<p><strong>Since:</strong> 3.4.7
</p></dd></dl>

<a name="gnutls_005fcertificate_005fset_005focsp_005fstatus_005frequest_005ffile-1"></a>
<h4 class="subheading">gnutls_certificate_set_ocsp_status_request_file</h4>
<a name="gnutls_005fcertificate_005fset_005focsp_005fstatus_005frequest_005ffile"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fset_005focsp_005fstatus_005frequest_005ffile"></a>Function: <em>int</em> <strong>gnutls_certificate_set_ocsp_status_request_file</strong> <em>(gnutls_certificate_credentials_t <var>sc</var>, const char * <var>response_file</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>sc</var>: is a credentials structure.
</p>
<p><var>response_file</var>: a filename of the OCSP response
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function sets the filename of an OCSP response, that will be
sent to the client if requests an OCSP certificate status. This is
a convenience function which is inefficient on busy servers since
the file is opened on every access. Use 
<code>gnutls_certificate_set_ocsp_status_request_function()</code>  to fine-tune
file accesses.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p>
<p><strong>Since:</strong> 3.1.3
</p></dd></dl>

<a name="gnutls_005fcertificate_005fset_005focsp_005fstatus_005frequest_005ffunction-1"></a>
<h4 class="subheading">gnutls_certificate_set_ocsp_status_request_function</h4>
<a name="gnutls_005fcertificate_005fset_005focsp_005fstatus_005frequest_005ffunction"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fset_005focsp_005fstatus_005frequest_005ffunction"></a>Function: <em>void</em> <strong>gnutls_certificate_set_ocsp_status_request_function</strong> <em>(gnutls_certificate_credentials_t <var>sc</var>, gnutls_status_request_ocsp_func <var>ocsp_func</var>, void * <var>ptr</var>)</em></dt>
<dd><p><var>sc</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>ocsp_func</var>: function pointer to OCSP status request callback.
</p>
<p><var>ptr</var>: opaque pointer passed to callback function
</p>
<p>This function is to be used by server to register a callback to
handle OCSP status requests from the client.  The callback will be
invoked if the client supplied a status-request OCSP extension.
The callback function prototype is:
</p>
<p>typedef int (*gnutls_status_request_ocsp_func)
(gnutls_session_t session, void *ptr, gnutls_datum_t *ocsp_response);
</p>
<p>The callback will be invoked if the client requests an OCSP certificate
status.  The callback may return <code>GNUTLS_E_NO_CERTIFICATE_STATUS</code> , if
there is no recent OCSP response. If the callback returns <code>GNUTLS_E_SUCCESS</code> ,
the server will provide the client with the ocsp_response.
</p>
<p>The response must be a value allocated using <code>gnutls_malloc()</code> , and will be
deinitialized when needed.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p>
<p><strong>Since:</strong> 3.1.3
</p></dd></dl>

<a name="gnutls_005fcertificate_005fset_005fparams_005ffunction-1"></a>
<h4 class="subheading">gnutls_certificate_set_params_function</h4>
<a name="gnutls_005fcertificate_005fset_005fparams_005ffunction"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fset_005fparams_005ffunction-1"></a>Function: <em>void</em> <strong>gnutls_certificate_set_params_function</strong> <em>(gnutls_certificate_credentials_t            <var>res</var>, gnutls_params_function * <var>func</var>)</em></dt>
<dd><p><var>res</var>: is a gnutls_certificate_credentials_t type
</p>
<p><var>func</var>: is the function to be called
</p>
<p>This function will set a callback in order for the server to get
the Diffie-Hellman or RSA parameters for certificate
authentication.  The callback should return <code>GNUTLS_E_SUCCESS</code>  (0) on success.
</p></dd></dl>

<a name="gnutls_005fcertificate_005fset_005fpin_005ffunction-1"></a>
<h4 class="subheading">gnutls_certificate_set_pin_function</h4>
<a name="gnutls_005fcertificate_005fset_005fpin_005ffunction"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fset_005fpin_005ffunction-1"></a>Function: <em>void</em> <strong>gnutls_certificate_set_pin_function</strong> <em>(gnutls_certificate_credentials_t       <var>cred</var>, gnutls_pin_callback_t <var>fn</var>, void * <var>userdata</var>)</em></dt>
<dd><p><var>cred</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>fn</var>: A PIN callback
</p>
<p><var>userdata</var>: Data to be passed in the callback
</p>
<p>This function will set a callback function to be used when
required to access a protected object. This function overrides any other
global PIN functions.
</p>
<p>Note that this function must be called right after initialization
to have effect.
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>

<a name="gnutls_005fcertificate_005fset_005fretrieve_005ffunction-1"></a>
<h4 class="subheading">gnutls_certificate_set_retrieve_function</h4>
<a name="gnutls_005fcertificate_005fset_005fretrieve_005ffunction"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fset_005fretrieve_005ffunction"></a>Function: <em>void</em> <strong>gnutls_certificate_set_retrieve_function</strong> <em>(gnutls_certificate_credentials_t <var>cred</var>, gnutls_certificate_retrieve_function * <var>func</var>)</em></dt>
<dd><p><var>cred</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>func</var>: is the callback function
</p>
<p>This function sets a callback to be called in order to retrieve the
certificate to be used in the handshake. The callback will take control
only if a certificate is requested by the peer. You are advised
to use <code>gnutls_certificate_set_retrieve_function2()</code>  because it
is much more efficient in the processing it requires from gnutls.
</p>
<p>The callback&rsquo;s function prototype is:
int (*callback)(gnutls_session_t, const gnutls_datum_t* req_ca_dn, int nreqs,
const gnutls_pk_algorithm_t* pk_algos, int pk_algos_length, gnutls_retr2_st* st);
</p>
<p><code>req_ca_dn</code> is only used in X.509 certificates.
Contains a list with the CA names that the server considers trusted.
This is a hint and typically the client should send a certificate that is signed
by one of these CAs. These names, when available, are DER encoded. To get a more
meaningful value use the function <code>gnutls_x509_rdn_get()</code> .
</p>
<p><code>pk_algos</code> contains a list with server&rsquo;s acceptable signature algorithms.
The certificate returned should support the server&rsquo;s given algorithms.
</p>
<p><code>st</code> should contain the certificates and private keys.
</p>
<p>If the callback function is provided then gnutls will call it, in the
handshake, after the certificate request message has been received.
</p>
<p>In server side pk_algos and req_ca_dn are NULL.
</p>
<p>The callback function should set the certificate list to be sent,
and return 0 on success. If no certificate was selected then the
number of certificates should be set to zero. The value (-1)
indicates error and the handshake will be terminated. If both certificates
are set in the credentials and a callback is available, the callback
takes predence.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<a name="gnutls_005fcertificate_005fset_005fverify_005fflags-1"></a>
<h4 class="subheading">gnutls_certificate_set_verify_flags</h4>
<a name="gnutls_005fcertificate_005fset_005fverify_005fflags"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fset_005fverify_005fflags"></a>Function: <em>void</em> <strong>gnutls_certificate_set_verify_flags</strong> <em>(gnutls_certificate_credentials_t         <var>res</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>res</var>: is a gnutls_certificate_credentials_t type
</p>
<p><var>flags</var>: are the flags
</p>
<p>This function will set the flags to be used for verification 
of certificates and override any defaults.  The provided flags must be an OR of the
<code>gnutls_certificate_verify_flags</code>  enumerations. 
</p></dd></dl>

<a name="gnutls_005fcertificate_005fset_005fverify_005ffunction-1"></a>
<h4 class="subheading">gnutls_certificate_set_verify_function</h4>
<a name="gnutls_005fcertificate_005fset_005fverify_005ffunction"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fset_005fverify_005ffunction"></a>Function: <em>void</em> <strong>gnutls_certificate_set_verify_function</strong> <em>(gnutls_certificate_credentials_t <var>cred</var>, gnutls_certificate_verify_function * <var>func</var>)</em></dt>
<dd><p><var>cred</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>func</var>: is the callback function
</p>
<p>This function sets a callback to be called when peer&rsquo;s certificate
has been received in order to verify it on receipt rather than
doing after the handshake is completed.
</p>
<p>The callback&rsquo;s function prototype is:
int (*callback)(gnutls_session_t);
</p>
<p>If the callback function is provided then gnutls will call it, in the
handshake, just after the certificate message has been received.
To verify or obtain the certificate the <code>gnutls_certificate_verify_peers2()</code> ,
<code>gnutls_certificate_type_get()</code> , <code>gnutls_certificate_get_peers()</code>  functions
can be used.
</p>
<p>The callback function should return 0 for the handshake to continue
or non-zero to terminate.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>

<a name="gnutls_005fcertificate_005fset_005fverify_005flimits-1"></a>
<h4 class="subheading">gnutls_certificate_set_verify_limits</h4>
<a name="gnutls_005fcertificate_005fset_005fverify_005flimits"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fset_005fverify_005flimits"></a>Function: <em>void</em> <strong>gnutls_certificate_set_verify_limits</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, unsigned int <var>max_bits</var>, unsigned int <var>max_depth</var>)</em></dt>
<dd><p><var>res</var>: is a gnutls_certificate_credentials type
</p>
<p><var>max_bits</var>: is the number of bits of an acceptable certificate (default 8200)
</p>
<p><var>max_depth</var>: is maximum depth of the verification of a certificate chain (default 5)
</p>
<p>This function will set some upper limits for the default
verification function, <code>gnutls_certificate_verify_peers2()</code> , to avoid
denial of service attacks.  You can set them to zero to disable
limits.
</p></dd></dl>

<a name="gnutls_005fcertificate_005fset_005fx509_005fcrl-1"></a>
<h4 class="subheading">gnutls_certificate_set_x509_crl</h4>
<a name="gnutls_005fcertificate_005fset_005fx509_005fcrl"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fset_005fx509_005fcrl"></a>Function: <em>int</em> <strong>gnutls_certificate_set_x509_crl</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, gnutls_x509_crl_t * <var>crl_list</var>, int <var>crl_list_size</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>crl_list</var>: is a list of trusted CRLs. They should have been verified before.
</p>
<p><var>crl_list_size</var>: holds the size of the crl_list
</p>
<p>This function adds the trusted CRLs in order to verify client or
server certificates.  In case of a client this is not required to
be called if the certificates are not verified using
<code>gnutls_certificate_verify_peers2()</code> .  This function may be called
multiple times.
</p>
<p><strong>Returns:</strong> number of CRLs processed, or a negative error code on error.
</p>
<p><strong>Since:</strong> 2.4.0
</p></dd></dl>

<a name="gnutls_005fcertificate_005fset_005fx509_005fcrl_005ffile-1"></a>
<h4 class="subheading">gnutls_certificate_set_x509_crl_file</h4>
<a name="gnutls_005fcertificate_005fset_005fx509_005fcrl_005ffile"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fset_005fx509_005fcrl_005ffile"></a>Function: <em>int</em> <strong>gnutls_certificate_set_x509_crl_file</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, const char * <var>crlfile</var>, gnutls_x509_crt_fmt_t <var>type</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>crlfile</var>: is a file containing the list of verified CRLs (DER or PEM list)
</p>
<p><var>type</var>: is PEM or DER
</p>
<p>This function adds the trusted CRLs in order to verify client or server
certificates.  In case of a client this is not required
to be called if the certificates are not verified using
<code>gnutls_certificate_verify_peers2()</code> .
This function may be called multiple times.
</p>
<p><strong>Returns:</strong> number of CRLs processed or a negative error code on error.
</p></dd></dl>

<a name="gnutls_005fcertificate_005fset_005fx509_005fcrl_005fmem-1"></a>
<h4 class="subheading">gnutls_certificate_set_x509_crl_mem</h4>
<a name="gnutls_005fcertificate_005fset_005fx509_005fcrl_005fmem"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fset_005fx509_005fcrl_005fmem"></a>Function: <em>int</em> <strong>gnutls_certificate_set_x509_crl_mem</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, const gnutls_datum_t * <var>CRL</var>, gnutls_x509_crt_fmt_t <var>type</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>CRL</var>: is a list of trusted CRLs. They should have been verified before.
</p>
<p><var>type</var>: is DER or PEM
</p>
<p>This function adds the trusted CRLs in order to verify client or
server certificates.  In case of a client this is not required to
be called if the certificates are not verified using
<code>gnutls_certificate_verify_peers2()</code> .  This function may be called
multiple times.
</p>
<p><strong>Returns:</strong> number of CRLs processed, or a negative error code on error.
</p></dd></dl>

<a name="gnutls_005fcertificate_005fset_005fx509_005fkey-1"></a>
<h4 class="subheading">gnutls_certificate_set_x509_key</h4>
<a name="gnutls_005fcertificate_005fset_005fx509_005fkey"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fset_005fx509_005fkey"></a>Function: <em>int</em> <strong>gnutls_certificate_set_x509_key</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, gnutls_x509_crt_t * <var>cert_list</var>, int <var>cert_list_size</var>, gnutls_x509_privkey_t <var>key</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>cert_list</var>: contains a certificate list (path) for the specified private key
</p>
<p><var>cert_list_size</var>: holds the size of the certificate list
</p>
<p><var>key</var>: is a <code>gnutls_x509_privkey_t</code>  key
</p>
<p>This function sets a certificate/private key pair in the
gnutls_certificate_credentials_t type.  This function may be
called more than once, in case multiple keys/certificates exist for
the server.  For clients that wants to send more than their own end
entity certificate (e.g., also an intermediate CA cert) then put
the certificate chain in  <code>cert_list</code> .
</p>
<p>Note that the certificates and keys provided, can be safely deinitialized
after this function is called.
</p>
<p>If that function fails to load the  <code>res</code> type is at an undefined state, it must
not be reused to load other keys or certificates.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  (0) on success, or a negative error code.
</p>
<p><strong>Since:</strong> 2.4.0
</p></dd></dl>

<a name="gnutls_005fcertificate_005fset_005fx509_005fkey_005ffile-1"></a>
<h4 class="subheading">gnutls_certificate_set_x509_key_file</h4>
<a name="gnutls_005fcertificate_005fset_005fx509_005fkey_005ffile"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fset_005fx509_005fkey_005ffile"></a>Function: <em>int</em> <strong>gnutls_certificate_set_x509_key_file</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, const char * <var>certfile</var>, const char * <var>keyfile</var>, gnutls_x509_crt_fmt_t <var>type</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>certfile</var>: is a file that containing the certificate list (path) for
the specified private key, in PKCS7 format, or a list of certificates
</p>
<p><var>keyfile</var>: is a file that contains the private key
</p>
<p><var>type</var>: is PEM or DER
</p>
<p>This function sets a certificate/private key pair in the
gnutls_certificate_credentials_t type.  This function may be
called more than once, in case multiple keys/certificates exist for
the server.  For clients that need to send more than its own end
entity certificate, e.g., also an intermediate CA cert, then the
 <code>certfile</code> must contain the ordered certificate chain.
</p>
<p>Note that the names in the certificate provided will be considered
when selecting the appropriate certificate to use (in case of multiple
certificate/key pairs).
</p>
<p>This function can also accept URLs at  <code>keyfile</code> and  <code>certfile</code> . In that case it
will use the private key and certificate indicated by the URLs. Note
that the supported URLs are the ones indicated by <code>gnutls_url_is_supported()</code> .
</p>
<p>In case the  <code>certfile</code> is provided as a PKCS <code>11</code>  URL, then the certificate, and its
present issuers in the token are imported (i.e., forming the required trust chain).
</p>
<p>If that function fails to load the  <code>res</code> structure is at an undefined state, it must
not be reused to load other keys or certificates.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  (0) on success, or a negative error code.
</p>
<p><strong>Since:</strong> 3.1.11
</p></dd></dl>

<a name="gnutls_005fcertificate_005fset_005fx509_005fkey_005ffile2-1"></a>
<h4 class="subheading">gnutls_certificate_set_x509_key_file2</h4>
<a name="gnutls_005fcertificate_005fset_005fx509_005fkey_005ffile2"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fset_005fx509_005fkey_005ffile2"></a>Function: <em>int</em> <strong>gnutls_certificate_set_x509_key_file2</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, const char * <var>certfile</var>, const char * <var>keyfile</var>, gnutls_x509_crt_fmt_t <var>type</var>, const char * <var>pass</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>certfile</var>: is a file that containing the certificate list (path) for
the specified private key, in PKCS7 format, or a list of certificates
</p>
<p><var>keyfile</var>: is a file that contains the private key
</p>
<p><var>type</var>: is PEM or DER
</p>
<p><var>pass</var>: is the password of the key
</p>
<p><var>flags</var>: an ORed sequence of gnutls_pkcs_encrypt_flags_t
</p>
<p>This function sets a certificate/private key pair in the
gnutls_certificate_credentials_t type.  This function may be
called more than once, in case multiple keys/certificates exist for
the server.  For clients that need to send more than its own end
entity certificate, e.g., also an intermediate CA cert, then the
 <code>certfile</code> must contain the ordered certificate chain.
</p>
<p>Note that the names in the certificate provided will be considered
when selecting the appropriate certificate to use (in case of multiple
certificate/key pairs).
</p>
<p>This function can also accept URLs at  <code>keyfile</code> and  <code>certfile</code> . In that case it
will use the private key and certificate indicated by the URLs. Note
that the supported URLs are the ones indicated by <code>gnutls_url_is_supported()</code> .
Before GnuTLS 3.4.0 when a URL was specified, the  <code>pass</code> part was ignored and a
PIN callback had to be registered, this is no longer the case in current releases.
</p>
<p>In case the  <code>certfile</code> is provided as a PKCS <code>11</code>  URL, then the certificate, and its
present issuers in the token are imported (i.e., forming the required trust chain).
</p>
<p>If that function fails to load the  <code>res</code> structure is at an undefined state, it must
not be reused to load other keys or certificates.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  (0) on success, or a negative error code.
</p></dd></dl>

<a name="gnutls_005fcertificate_005fset_005fx509_005fkey_005fmem-1"></a>
<h4 class="subheading">gnutls_certificate_set_x509_key_mem</h4>
<a name="gnutls_005fcertificate_005fset_005fx509_005fkey_005fmem"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fset_005fx509_005fkey_005fmem"></a>Function: <em>int</em> <strong>gnutls_certificate_set_x509_key_mem</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, const gnutls_datum_t * <var>cert</var>, const gnutls_datum_t * <var>key</var>, gnutls_x509_crt_fmt_t <var>type</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>cert</var>: contains a certificate list (path) for the specified private key
</p>
<p><var>key</var>: is the private key, or <code>NULL</code> 
</p>
<p><var>type</var>: is PEM or DER
</p>
<p>This function sets a certificate/private key pair in the
gnutls_certificate_credentials_t type. This function may be called
more than once, in case multiple keys/certificates exist for the
server.
</p>
<p>Note that the keyUsage (2.5.29.15) PKIX extension in X.509 certificates
is supported. This means that certificates intended for signing cannot
be used for ciphersuites that require encryption.
</p>
<p>If the certificate and the private key are given in PEM encoding
then the strings that hold their values must be null terminated.
</p>
<p>The  <code>key</code> may be <code>NULL</code>  if you are using a sign callback, see
<code>gnutls_sign_callback_set()</code> .
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  (0) on success, or a negative error code.
</p></dd></dl>

<a name="gnutls_005fcertificate_005fset_005fx509_005fkey_005fmem2-1"></a>
<h4 class="subheading">gnutls_certificate_set_x509_key_mem2</h4>
<a name="gnutls_005fcertificate_005fset_005fx509_005fkey_005fmem2"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fset_005fx509_005fkey_005fmem2"></a>Function: <em>int</em> <strong>gnutls_certificate_set_x509_key_mem2</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, const gnutls_datum_t * <var>cert</var>, const gnutls_datum_t * <var>key</var>, gnutls_x509_crt_fmt_t <var>type</var>, const char * <var>pass</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>cert</var>: contains a certificate list (path) for the specified private key
</p>
<p><var>key</var>: is the private key, or <code>NULL</code> 
</p>
<p><var>type</var>: is PEM or DER
</p>
<p><var>pass</var>: is the key&rsquo;s password
</p>
<p><var>flags</var>: an ORed sequence of gnutls_pkcs_encrypt_flags_t
</p>
<p>This function sets a certificate/private key pair in the
gnutls_certificate_credentials_t type. This function may be called
more than once, in case multiple keys/certificates exist for the
server.
</p>
<p>Note that the keyUsage (2.5.29.15) PKIX extension in X.509 certificates
is supported. This means that certificates intended for signing cannot
be used for ciphersuites that require encryption.
</p>
<p>If the certificate and the private key are given in PEM encoding
then the strings that hold their values must be null terminated.
</p>
<p>The  <code>key</code> may be <code>NULL</code>  if you are using a sign callback, see
<code>gnutls_sign_callback_set()</code> .
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  (0) on success, or a negative error code.
</p></dd></dl>

<a name="gnutls_005fcertificate_005fset_005fx509_005fsimple_005fpkcs12_005ffile-1"></a>
<h4 class="subheading">gnutls_certificate_set_x509_simple_pkcs12_file</h4>
<a name="gnutls_005fcertificate_005fset_005fx509_005fsimple_005fpkcs12_005ffile"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fset_005fx509_005fsimple_005fpkcs12_005ffile"></a>Function: <em>int</em> <strong>gnutls_certificate_set_x509_simple_pkcs12_file</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, const char * <var>pkcs12file</var>, gnutls_x509_crt_fmt_t <var>type</var>, const char * <var>password</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>pkcs12file</var>: filename of file containing PKCS<code>12</code>  blob.
</p>
<p><var>type</var>: is PEM or DER of the  <code>pkcs12file</code> .
</p>
<p><var>password</var>: optional password used to decrypt PKCS<code>12</code>  file, bags and keys.
</p>
<p>This function sets a certificate/private key pair and/or a CRL in
the gnutls_certificate_credentials_t type.  This function may
be called more than once (in case multiple keys/certificates exist
for the server).
</p>
<p>PKCS<code>12</code>  files with a MAC, encrypted bags and PKCS <code>8</code> 
private keys are supported. However,
only password based security, and the same password for all
operations, are supported.
</p>
<p>PKCS<code>12</code>  file may contain many keys and/or certificates, and this
function will try to auto-detect based on the key ID the certificate
and key pair to use. If the PKCS<code>12</code>  file contain the issuer of
the selected certificate, it will be appended to the certificate
to form a chain.
</p>
<p>If more than one private keys are stored in the PKCS<code>12</code>  file,
then only one key will be read (and it is undefined which one).
</p>
<p>It is believed that the limitations of this function is acceptable
for most usage, and that any more flexibility would introduce
complexity that would make it harder to use this functionality at
all.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  (0) on success, or a negative error code.
</p></dd></dl>

<a name="gnutls_005fcertificate_005fset_005fx509_005fsimple_005fpkcs12_005fmem-1"></a>
<h4 class="subheading">gnutls_certificate_set_x509_simple_pkcs12_mem</h4>
<a name="gnutls_005fcertificate_005fset_005fx509_005fsimple_005fpkcs12_005fmem"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fset_005fx509_005fsimple_005fpkcs12_005fmem"></a>Function: <em>int</em> <strong>gnutls_certificate_set_x509_simple_pkcs12_mem</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, const gnutls_datum_t * <var>p12blob</var>, gnutls_x509_crt_fmt_t <var>type</var>, const char * <var>password</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>p12blob</var>: the PKCS<code>12</code>  blob.
</p>
<p><var>type</var>: is PEM or DER of the  <code>pkcs12file</code> .
</p>
<p><var>password</var>: optional password used to decrypt PKCS<code>12</code>  file, bags and keys.
</p>
<p>This function sets a certificate/private key pair and/or a CRL in
the gnutls_certificate_credentials_t type.  This function may
be called more than once (in case multiple keys/certificates exist
for the server).
</p>
<p>Encrypted PKCS<code>12</code>  bags and PKCS<code>8</code>  private keys are supported.  However,
only password based security, and the same password for all
operations, are supported.
</p>
<p>PKCS<code>12</code>  file may contain many keys and/or certificates, and this
function will try to auto-detect based on the key ID the certificate
and key pair to use. If the PKCS<code>12</code>  file contain the issuer of
the selected certificate, it will be appended to the certificate
to form a chain.
</p>
<p>If more than one private keys are stored in the PKCS<code>12</code>  file,
then only one key will be read (and it is undefined which one).
</p>
<p>It is believed that the limitations of this function is acceptable
for most usage, and that any more flexibility would introduce
complexity that would make it harder to use this functionality at
all.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  (0) on success, or a negative error code.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<a name="gnutls_005fcertificate_005fset_005fx509_005fsystem_005ftrust-1"></a>
<h4 class="subheading">gnutls_certificate_set_x509_system_trust</h4>
<a name="gnutls_005fcertificate_005fset_005fx509_005fsystem_005ftrust"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fset_005fx509_005fsystem_005ftrust-1"></a>Function: <em>int</em> <strong>gnutls_certificate_set_x509_system_trust</strong> <em>(gnutls_certificate_credentials_t       <var>cred</var>)</em></dt>
<dd><p><var>cred</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p>This function adds the system&rsquo;s default trusted CAs in order to
verify client or server certificates.
</p>
<p>In the case the system is currently unsupported <code>GNUTLS_E_UNIMPLEMENTED_FEATURE</code> 
is returned.
</p>
<p><strong>Returns:</strong> the number of certificates processed or a negative error code
on error.
</p>
<p><strong>Since:</strong> 3.0.20
</p></dd></dl>

<a name="gnutls_005fcertificate_005fset_005fx509_005ftrust-1"></a>
<h4 class="subheading">gnutls_certificate_set_x509_trust</h4>
<a name="gnutls_005fcertificate_005fset_005fx509_005ftrust"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fset_005fx509_005ftrust"></a>Function: <em>int</em> <strong>gnutls_certificate_set_x509_trust</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, gnutls_x509_crt_t * <var>ca_list</var>, int <var>ca_list_size</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>ca_list</var>: is a list of trusted CAs
</p>
<p><var>ca_list_size</var>: holds the size of the CA list
</p>
<p>This function adds the trusted CAs in order to verify client
or server certificates. In case of a client this is not required
to be called if the certificates are not verified using
<code>gnutls_certificate_verify_peers2()</code> .
This function may be called multiple times.
</p>
<p>In case of a server the CAs set here will be sent to the client if
a certificate request is sent. This can be disabled using
<code>gnutls_certificate_send_x509_rdn_sequence()</code> .
</p>
<p><strong>Returns:</strong> the number of certificates processed or a negative error code
on error.
</p>
<p><strong>Since:</strong> 2.4.0
</p></dd></dl>

<a name="gnutls_005fcertificate_005fset_005fx509_005ftrust_005fdir-1"></a>
<h4 class="subheading">gnutls_certificate_set_x509_trust_dir</h4>
<a name="gnutls_005fcertificate_005fset_005fx509_005ftrust_005fdir"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fset_005fx509_005ftrust_005fdir"></a>Function: <em>int</em> <strong>gnutls_certificate_set_x509_trust_dir</strong> <em>(gnutls_certificate_credentials_t <var>cred</var>, const char * <var>ca_dir</var>, gnutls_x509_crt_fmt_t <var>type</var>)</em></dt>
<dd><p><var>cred</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>ca_dir</var>: is a directory containing the list of trusted CAs (DER or PEM list)
</p>
<p><var>type</var>: is PEM or DER
</p>
<p>This function adds the trusted CAs present in the directory in order to 
verify client or server certificates. This function is identical
to <code>gnutls_certificate_set_x509_trust_file()</code>  but loads all certificates
in a directory.
</p>
<p><strong>Returns:</strong> the number of certificates processed
</p>
<p><strong>Since:</strong> 3.3.6
</p></dd></dl>

<a name="gnutls_005fcertificate_005fset_005fx509_005ftrust_005ffile-1"></a>
<h4 class="subheading">gnutls_certificate_set_x509_trust_file</h4>
<a name="gnutls_005fcertificate_005fset_005fx509_005ftrust_005ffile"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fset_005fx509_005ftrust_005ffile"></a>Function: <em>int</em> <strong>gnutls_certificate_set_x509_trust_file</strong> <em>(gnutls_certificate_credentials_t            <var>cred</var>, const char * <var>cafile</var>, gnutls_x509_crt_fmt_t <var>type</var>)</em></dt>
<dd><p><var>cred</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>cafile</var>: is a file containing the list of trusted CAs (DER or PEM list)
</p>
<p><var>type</var>: is PEM or DER
</p>
<p>This function adds the trusted CAs in order to verify client or
server certificates. In case of a client this is not required to
be called if the certificates are not verified using
<code>gnutls_certificate_verify_peers2()</code> .  This function may be called
multiple times.
</p>
<p>In case of a server the names of the CAs set here will be sent to
the client if a certificate request is sent. This can be disabled
using <code>gnutls_certificate_send_x509_rdn_sequence()</code> .
</p>
<p>This function can also accept URLs. In that case it
will import all certificates that are marked as trusted. Note
that the supported URLs are the ones indicated by <code>gnutls_url_is_supported()</code> .
</p>
<p><strong>Returns:</strong> the number of certificates processed
</p></dd></dl>

<a name="gnutls_005fcertificate_005fset_005fx509_005ftrust_005fmem-1"></a>
<h4 class="subheading">gnutls_certificate_set_x509_trust_mem</h4>
<a name="gnutls_005fcertificate_005fset_005fx509_005ftrust_005fmem"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fset_005fx509_005ftrust_005fmem"></a>Function: <em>int</em> <strong>gnutls_certificate_set_x509_trust_mem</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, const gnutls_datum_t * <var>ca</var>, gnutls_x509_crt_fmt_t <var>type</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>ca</var>: is a list of trusted CAs or a DER certificate
</p>
<p><var>type</var>: is DER or PEM
</p>
<p>This function adds the trusted CAs in order to verify client or
server certificates. In case of a client this is not required to be
called if the certificates are not verified using
<code>gnutls_certificate_verify_peers2()</code> .  This function may be called
multiple times.
</p>
<p>In case of a server the CAs set here will be sent to the client if
a certificate request is sent. This can be disabled using
<code>gnutls_certificate_send_x509_rdn_sequence()</code> .
</p>
<p><strong>Returns:</strong> the number of certificates processed or a negative error code
on error.
</p></dd></dl>

<a name="gnutls_005fcertificate_005ftype_005fget-1"></a>
<h4 class="subheading">gnutls_certificate_type_get</h4>
<a name="gnutls_005fcertificate_005ftype_005fget"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005ftype_005fget"></a>Function: <em>gnutls_certificate_type_t</em> <strong>gnutls_certificate_type_get</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>The certificate type is by default X.509, unless it is negotiated
as a TLS extension.
</p>
<p><strong>Returns:</strong> the currently used <code>gnutls_certificate_type_t</code>  certificate
type.
</p></dd></dl>

<a name="gnutls_005fcertificate_005ftype_005fget_005fid-1"></a>
<h4 class="subheading">gnutls_certificate_type_get_id</h4>
<a name="gnutls_005fcertificate_005ftype_005fget_005fid"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005ftype_005fget_005fid"></a>Function: <em>gnutls_certificate_type_t</em> <strong>gnutls_certificate_type_get_id</strong> <em>(const char * <var>name</var>)</em></dt>
<dd><p><var>name</var>: is a certificate type name
</p>
<p>The names are compared in a case insensitive way.
</p>
<p><strong>Returns:</strong> a <code>gnutls_certificate_type_t</code>  for the specified in a
string certificate type, or <code>GNUTLS_CRT_UNKNOWN</code>  on error.
</p></dd></dl>

<a name="gnutls_005fcertificate_005ftype_005fget_005fname-1"></a>
<h4 class="subheading">gnutls_certificate_type_get_name</h4>
<a name="gnutls_005fcertificate_005ftype_005fget_005fname"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005ftype_005fget_005fname"></a>Function: <em>const char *</em> <strong>gnutls_certificate_type_get_name</strong> <em>(gnutls_certificate_type_t           <var>type</var>)</em></dt>
<dd><p><var>type</var>: is a certificate type
</p>
<p>Convert a <code>gnutls_certificate_type_t</code>  type to a string.
</p>
<p><strong>Returns:</strong> a string that contains the name of the specified
certificate type, or <code>NULL</code>  in case of unknown types.
</p></dd></dl>

<a name="gnutls_005fcertificate_005ftype_005flist-1"></a>
<h4 class="subheading">gnutls_certificate_type_list</h4>
<a name="gnutls_005fcertificate_005ftype_005flist"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005ftype_005flist"></a>Function: <em>const gnutls_certificate_type_t *</em> <strong>gnutls_certificate_type_list</strong> <em>( <var>void</var>)</em></dt>
<dd>
<p>Get a list of certificate types.
</p>
<p><strong>Returns:</strong> a (0)-terminated list of <code>gnutls_certificate_type_t</code> 
integers indicating the available certificate types.
</p></dd></dl>

<a name="gnutls_005fcertificate_005fverification_005fstatus_005fprint-1"></a>
<h4 class="subheading">gnutls_certificate_verification_status_print</h4>
<a name="gnutls_005fcertificate_005fverification_005fstatus_005fprint"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fverification_005fstatus_005fprint"></a>Function: <em>int</em> <strong>gnutls_certificate_verification_status_print</strong> <em>(unsigned int <var>status</var>, gnutls_certificate_type_t           <var>type</var>, gnutls_datum_t * <var>out</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>status</var>: The status flags to be printed
</p>
<p><var>type</var>: The certificate type
</p>
<p><var>out</var>: Newly allocated datum with (0) terminated string.
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function will pretty print the status of a verification
process &ndash; eg. the one obtained by <code>gnutls_certificate_verify_peers3()</code> .
</p>
<p>The output  <code>out</code> needs to be deallocated using <code>gnutls_free()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.4
</p></dd></dl>

<a name="gnutls_005fcertificate_005fverify_005fpeers-1"></a>
<h4 class="subheading">gnutls_certificate_verify_peers</h4>
<a name="gnutls_005fcertificate_005fverify_005fpeers"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fverify_005fpeers"></a>Function: <em>int</em> <strong>gnutls_certificate_verify_peers</strong> <em>(gnutls_session_t <var>session</var>, gnutls_typed_vdata_st * <var>data</var>, unsigned int <var>elements</var>, unsigned int * <var>status</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p><var>data</var>: an array of typed data
</p>
<p><var>elements</var>: the number of data elements
</p>
<p><var>status</var>: is the output of the verification
</p>
<p>This function will verify the peer&rsquo;s certificate and store the
status in the  <code>status</code> variable as a bitwise or&rsquo;d gnutls_certificate_status_t
values or zero if the certificate is trusted. Note that value in  <code>status</code> is set only when the return value of this function is success (i.e, failure 
to trust a certificate does not imply a negative return value).
The default verification flags used by this function can be overridden
using <code>gnutls_certificate_set_verify_flags()</code> . See the documentation
of <code>gnutls_certificate_verify_peers2()</code>  for details in the verification process.
</p>
<p>The acceptable  <code>data</code> types are <code>GNUTLS_DT_DNS_HOSTNAME</code> , <code>GNUTLS_DT_RFC822NAME</code>  and <code>GNUTLS_DT_KEY_PURPOSE_OID</code> .
The former two accept as data a null-terminated hostname or email address, and the latter a null-terminated
object identifier (e.g., <code>GNUTLS_KP_TLS_WWW_SERVER</code> ).
</p>
<p>If a DNS hostname is provided then this function will compare
the hostname in the certificate against the given. If names do not match the 
<code>GNUTLS_CERT_UNEXPECTED_OWNER</code>  status flag will be set.
If a key purpose OID is provided and the end-certificate contains the extended key
usage PKIX extension, it will be required to be have the provided key purpose 
or be marked for any purpose, otherwise verification status will have the
<code>GNUTLS_CERT_SIGNER_CONSTRAINTS_FAILURE</code>  flag set.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  (0) when the validation is performed, or a negative error code otherwise.
A sucessful error code means that the  <code>status</code> parameter must be checked to obtain the validation status.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fcertificate_005fverify_005fpeers2-1"></a>
<h4 class="subheading">gnutls_certificate_verify_peers2</h4>
<a name="gnutls_005fcertificate_005fverify_005fpeers2"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fverify_005fpeers2"></a>Function: <em>int</em> <strong>gnutls_certificate_verify_peers2</strong> <em>(gnutls_session_t <var>session</var>, unsigned int * <var>status</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p><var>status</var>: is the output of the verification
</p>
<p>This function will verify the peer&rsquo;s certificate and store
the status in the  <code>status</code> variable as a bitwise or&rsquo;d gnutls_certificate_status_t
values or zero if the certificate is trusted. Note that value in  <code>status</code> is set only when the return value of this function is success (i.e, failure 
to trust a certificate does not imply a negative return value).
The default verification flags used by this function can be overridden
using <code>gnutls_certificate_set_verify_flags()</code> .
</p>
<p>This function will take into account the OCSP Certificate Status TLS extension,
as well as the following X.509 certificate extensions: Name Constraints,
Key Usage, and Basic Constraints (pathlen).
</p>
<p>To avoid denial of service attacks some
default upper limits regarding the certificate key size and chain
size are set. To override them use <code>gnutls_certificate_set_verify_limits()</code> .
</p>
<p>Note that you must also check the peer&rsquo;s name in order to check if
the verified certificate belongs to the actual peer, see <code>gnutls_x509_crt_check_hostname()</code> ,
or use <code>gnutls_certificate_verify_peers3()</code> .
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  (0) when the validation is performed, or a negative error code otherwise.
A sucessful error code means that the  <code>status</code> parameter must be checked to obtain the validation status.
</p></dd></dl>

<a name="gnutls_005fcertificate_005fverify_005fpeers3-1"></a>
<h4 class="subheading">gnutls_certificate_verify_peers3</h4>
<a name="gnutls_005fcertificate_005fverify_005fpeers3"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fverify_005fpeers3"></a>Function: <em>int</em> <strong>gnutls_certificate_verify_peers3</strong> <em>(gnutls_session_t <var>session</var>, const char * <var>hostname</var>, unsigned int * <var>status</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p><var>hostname</var>: is the expected name of the peer; may be <code>NULL</code> 
</p>
<p><var>status</var>: is the output of the verification
</p>
<p>This function will verify the peer&rsquo;s certificate and store the
status in the  <code>status</code> variable as a bitwise or&rsquo;d gnutls_certificate_status_t
values or zero if the certificate is trusted. Note that value in  <code>status</code> is set only when the return value of this function is success (i.e, failure 
to trust a certificate does not imply a negative return value).
The default verification flags used by this function can be overridden
using <code>gnutls_certificate_set_verify_flags()</code> . See the documentation
of <code>gnutls_certificate_verify_peers2()</code>  for details in the verification process.
</p>
<p>If the  <code>hostname</code> provided is non-NULL then this function will compare
the hostname in the certificate against it. The comparison will follow
the RFC6125 recommendations. If names do not match the
<code>GNUTLS_CERT_UNEXPECTED_OWNER</code>  status flag will be set.
</p>
<p>In order to verify the purpose of the end-certificate (by checking the extended
key usage), use <code>gnutls_certificate_verify_peers()</code> .
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  (0) when the validation is performed, or a negative error code otherwise.
A sucessful error code means that the  <code>status</code> parameter must be checked to obtain the validation status.
</p>
<p><strong>Since:</strong> 3.1.4
</p></dd></dl>

<a name="gnutls_005fcheck_005fversion-1"></a>
<h4 class="subheading">gnutls_check_version</h4>
<a name="gnutls_005fcheck_005fversion"></a><dl>
<dt><a name="index-gnutls_005fcheck_005fversion"></a>Function: <em>const char *</em> <strong>gnutls_check_version</strong> <em>(const char * <var>req_version</var>)</em></dt>
<dd><p><var>req_version</var>: version string to compare with, or <code>NULL</code> .
</p>
<p>Check the GnuTLS Library version against the provided string.
See <code>GNUTLS_VERSION</code>  for a suitable  <code>req_version</code> string.
</p>
<p>See also <code>gnutls_check_version_numeric()</code> , which provides this
functionality as a macro.
</p>
<p><strong>Returns:</strong> Check that the version of the library is at
minimum the one given as a string in  <code>req_version</code> and return the
actual version string of the library; return <code>NULL</code>  if the
condition is not met.  If <code>NULL</code>  is passed to this function no
check is done and only the version string is returned.
</p></dd></dl>

<a name="gnutls_005fcipher_005fget-1"></a>
<h4 class="subheading">gnutls_cipher_get</h4>
<a name="gnutls_005fcipher_005fget"></a><dl>
<dt><a name="index-gnutls_005fcipher_005fget"></a>Function: <em>gnutls_cipher_algorithm_t</em> <strong>gnutls_cipher_get</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Get currently used cipher.
</p>
<p><strong>Returns:</strong> the currently used cipher, a <code>gnutls_cipher_algorithm_t</code> 
type.
</p></dd></dl>

<a name="gnutls_005fcipher_005fget_005fid-1"></a>
<h4 class="subheading">gnutls_cipher_get_id</h4>
<a name="gnutls_005fcipher_005fget_005fid"></a><dl>
<dt><a name="index-gnutls_005fcipher_005fget_005fid"></a>Function: <em>gnutls_cipher_algorithm_t</em> <strong>gnutls_cipher_get_id</strong> <em>(const char * <var>name</var>)</em></dt>
<dd><p><var>name</var>: is a cipher algorithm name
</p>
<p>The names are compared in a case insensitive way.
</p>
<p><strong>Returns:</strong> return a <code>gnutls_cipher_algorithm_t</code>  value corresponding to
the specified cipher, or <code>GNUTLS_CIPHER_UNKNOWN</code>  on error.
</p></dd></dl>

<a name="gnutls_005fcipher_005fget_005fkey_005fsize-1"></a>
<h4 class="subheading">gnutls_cipher_get_key_size</h4>
<a name="gnutls_005fcipher_005fget_005fkey_005fsize"></a><dl>
<dt><a name="index-gnutls_005fcipher_005fget_005fkey_005fsize"></a>Function: <em>size_t</em> <strong>gnutls_cipher_get_key_size</strong> <em>(gnutls_cipher_algorithm_t <var>algorithm</var>)</em></dt>
<dd><p><var>algorithm</var>: is an encryption algorithm
</p>
<p>Get key size for cipher.
</p>
<p><strong>Returns:</strong> length (in bytes) of the given cipher&rsquo;s key size, or 0 if
the given cipher is invalid.
</p></dd></dl>

<a name="gnutls_005fcipher_005fget_005fname-1"></a>
<h4 class="subheading">gnutls_cipher_get_name</h4>
<a name="gnutls_005fcipher_005fget_005fname"></a><dl>
<dt><a name="index-gnutls_005fcipher_005fget_005fname"></a>Function: <em>const char *</em> <strong>gnutls_cipher_get_name</strong> <em>(gnutls_cipher_algorithm_t <var>algorithm</var>)</em></dt>
<dd><p><var>algorithm</var>: is an encryption algorithm
</p>
<p>Convert a <code>gnutls_cipher_algorithm_t</code>  type to a string.
</p>
<p><strong>Returns:</strong> a pointer to a string that contains the name of the
specified cipher, or <code>NULL</code> .
</p></dd></dl>

<a name="gnutls_005fcipher_005flist-1"></a>
<h4 class="subheading">gnutls_cipher_list</h4>
<a name="gnutls_005fcipher_005flist"></a><dl>
<dt><a name="index-gnutls_005fcipher_005flist"></a>Function: <em>const gnutls_cipher_algorithm_t *</em> <strong>gnutls_cipher_list</strong> <em>( <var>void</var>)</em></dt>
<dd>
<p>Get a list of supported cipher algorithms.  Note that not
necessarily all ciphers are supported as TLS cipher suites.  For
example, DES is not supported as a cipher suite, but is supported
for other purposes (e.g., PKCS<code>8</code>  or similar).
</p>
<p>This function is not thread safe.
</p>
<p><strong>Returns:</strong> a (0)-terminated list of <code>gnutls_cipher_algorithm_t</code> 
integers indicating the available ciphers.
</p></dd></dl>

<a name="gnutls_005fcipher_005fsuite_005fget_005fname-1"></a>
<h4 class="subheading">gnutls_cipher_suite_get_name</h4>
<a name="gnutls_005fcipher_005fsuite_005fget_005fname"></a><dl>
<dt><a name="index-gnutls_005fcipher_005fsuite_005fget_005fname"></a>Function: <em>const char *</em> <strong>gnutls_cipher_suite_get_name</strong> <em>(gnutls_kx_algorithm_t       <var>kx_algorithm</var>, gnutls_cipher_algorithm_t       <var>cipher_algorithm</var>, gnutls_mac_algorithm_t       <var>mac_algorithm</var>)</em></dt>
<dd><p><var>kx_algorithm</var>: is a Key exchange algorithm
</p>
<p><var>cipher_algorithm</var>: is a cipher algorithm
</p>
<p><var>mac_algorithm</var>: is a MAC algorithm
</p>
<p>Note that the full cipher suite name must be prepended by TLS or
SSL depending of the protocol in use.
</p>
<p><strong>Returns:</strong> a string that contains the name of a TLS cipher suite,
specified by the given algorithms, or <code>NULL</code> .
</p></dd></dl>

<a name="gnutls_005fcipher_005fsuite_005finfo-1"></a>
<h4 class="subheading">gnutls_cipher_suite_info</h4>
<a name="gnutls_005fcipher_005fsuite_005finfo"></a><dl>
<dt><a name="index-gnutls_005fcipher_005fsuite_005finfo"></a>Function: <em>const char *</em> <strong>gnutls_cipher_suite_info</strong> <em>(size_t <var>idx</var>, unsigned char * <var>cs_id</var>, gnutls_kx_algorithm_t * <var>kx</var>, gnutls_cipher_algorithm_t * <var>cipher</var>, gnutls_mac_algorithm_t * <var>mac</var>, gnutls_protocol_t * <var>min_version</var>)</em></dt>
<dd><p><var>idx</var>: index of cipher suite to get information about, starts on 0.
</p>
<p><var>cs_id</var>: output buffer with room for 2 bytes, indicating cipher suite value
</p>
<p><var>kx</var>: output variable indicating key exchange algorithm, or <code>NULL</code> .
</p>
<p><var>cipher</var>: output variable indicating cipher, or <code>NULL</code> .
</p>
<p><var>mac</var>: output variable indicating MAC algorithm, or <code>NULL</code> .
</p>
<p><var>min_version</var>: output variable indicating TLS protocol version, or <code>NULL</code> .
</p>
<p>Get information about supported cipher suites.  Use the function
iteratively to get information about all supported cipher suites.
Call with idx=0 to get information about first cipher suite, then
idx=1 and so on until the function returns NULL.
</p>
<p><strong>Returns:</strong> the name of  <code>idx</code> cipher suite, and set the information
about the cipher suite in the output variables.  If  <code>idx</code> is out of
bounds, <code>NULL</code>  is returned.
</p></dd></dl>

<a name="gnutls_005fcompression_005fget-1"></a>
<h4 class="subheading">gnutls_compression_get</h4>
<a name="gnutls_005fcompression_005fget"></a><dl>
<dt><a name="index-gnutls_005fcompression_005fget"></a>Function: <em>gnutls_compression_method_t</em> <strong>gnutls_compression_get</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Get currently used compression algorithm.
</p>
<p><strong>Returns:</strong> the currently used compression method, a
<code>gnutls_compression_method_t</code>  value.
</p></dd></dl>

<a name="gnutls_005fcompression_005fget_005fid-1"></a>
<h4 class="subheading">gnutls_compression_get_id</h4>
<a name="gnutls_005fcompression_005fget_005fid"></a><dl>
<dt><a name="index-gnutls_005fcompression_005fget_005fid"></a>Function: <em>gnutls_compression_method_t</em> <strong>gnutls_compression_get_id</strong> <em>(const char * <var>name</var>)</em></dt>
<dd><p><var>name</var>: is a compression method name
</p>
<p>The names are compared in a case insensitive way.
</p>
<p><strong>Returns:</strong> an id of the specified in a string compression method, or
<code>GNUTLS_COMP_UNKNOWN</code>  on error.
</p></dd></dl>

<a name="gnutls_005fcompression_005fget_005fname-1"></a>
<h4 class="subheading">gnutls_compression_get_name</h4>
<a name="gnutls_005fcompression_005fget_005fname"></a><dl>
<dt><a name="index-gnutls_005fcompression_005fget_005fname"></a>Function: <em>const char *</em> <strong>gnutls_compression_get_name</strong> <em>(gnutls_compression_method_t      <var>algorithm</var>)</em></dt>
<dd><p><var>algorithm</var>: is a Compression algorithm
</p>
<p>Convert a <code>gnutls_compression_method_t</code>  value to a string.
</p>
<p><strong>Returns:</strong> a pointer to a string that contains the name of the
specified compression algorithm, or <code>NULL</code> .
</p></dd></dl>

<a name="gnutls_005fcompression_005flist-1"></a>
<h4 class="subheading">gnutls_compression_list</h4>
<a name="gnutls_005fcompression_005flist"></a><dl>
<dt><a name="index-gnutls_005fcompression_005flist"></a>Function: <em>const gnutls_compression_method_t *</em> <strong>gnutls_compression_list</strong> <em>( <var>void</var>)</em></dt>
<dd>
<p>Get a list of compression methods.  
</p>
<p><strong>Returns:</strong> a zero-terminated list of <code>gnutls_compression_method_t</code> 
integers indicating the available compression methods.
</p></dd></dl>

<a name="gnutls_005fcredentials_005fclear-1"></a>
<h4 class="subheading">gnutls_credentials_clear</h4>
<a name="gnutls_005fcredentials_005fclear"></a><dl>
<dt><a name="index-gnutls_005fcredentials_005fclear"></a>Function: <em>void</em> <strong>gnutls_credentials_clear</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Clears all the credentials previously set in this session.
</p></dd></dl>

<a name="gnutls_005fcredentials_005fget-1"></a>
<h4 class="subheading">gnutls_credentials_get</h4>
<a name="gnutls_005fcredentials_005fget"></a><dl>
<dt><a name="index-gnutls_005fcredentials_005fget"></a>Function: <em>int</em> <strong>gnutls_credentials_get</strong> <em>(gnutls_session_t <var>session</var>, gnutls_credentials_type_t <var>type</var>, void ** <var>cred</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>type</var>: is the type of the credentials to return
</p>
<p><var>cred</var>: will contain the credentials.
</p>
<p>Returns the previously provided credentials structures.
</p>
<p>For <code>GNUTLS_CRD_ANON</code> ,  <code>cred</code> will be
<code>gnutls_anon_client_credentials_t</code>  in case of a client.  In case of
a server it should be <code>gnutls_anon_server_credentials_t</code> .
</p>
<p>For <code>GNUTLS_CRD_SRP</code> ,  <code>cred</code> will be <code>gnutls_srp_client_credentials_t</code> 
in case of a client, and <code>gnutls_srp_server_credentials_t</code> , in case
of a server.
</p>
<p>For <code>GNUTLS_CRD_CERTIFICATE</code> ,  <code>cred</code> will be
<code>gnutls_certificate_credentials_t</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p>
<p><strong>Since:</strong> 3.3.3
</p></dd></dl>

<a name="gnutls_005fcredentials_005fset-1"></a>
<h4 class="subheading">gnutls_credentials_set</h4>
<a name="gnutls_005fcredentials_005fset"></a><dl>
<dt><a name="index-gnutls_005fcredentials_005fset-1"></a>Function: <em>int</em> <strong>gnutls_credentials_set</strong> <em>(gnutls_session_t <var>session</var>, gnutls_credentials_type_t <var>type</var>, void * <var>cred</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>type</var>: is the type of the credentials
</p>
<p><var>cred</var>: the credentials to set
</p>
<p>Sets the needed credentials for the specified type.  E.g. username,
password - or public and private keys etc.  The  <code>cred</code> parameter is
a structure that depends on the specified type and on the current
session (client or server).
</p>
<p>In order to minimize memory usage, and share credentials between
several threads gnutls keeps a pointer to cred, and not the whole
cred structure.  Thus you will have to keep the structure allocated
until you call <code>gnutls_deinit()</code> .
</p>
<p>For <code>GNUTLS_CRD_ANON</code> ,  <code>cred</code> should be
<code>gnutls_anon_client_credentials_t</code>  in case of a client.  In case of
a server it should be <code>gnutls_anon_server_credentials_t</code> .
</p>
<p>For <code>GNUTLS_CRD_SRP</code> ,  <code>cred</code> should be <code>gnutls_srp_client_credentials_t</code> 
in case of a client, and <code>gnutls_srp_server_credentials_t</code> , in case
of a server.
</p>
<p>For <code>GNUTLS_CRD_CERTIFICATE</code> ,  <code>cred</code> should be
<code>gnutls_certificate_credentials_t</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p></dd></dl>

<a name="gnutls_005fdb_005fcheck_005fentry-1"></a>
<h4 class="subheading">gnutls_db_check_entry</h4>
<a name="gnutls_005fdb_005fcheck_005fentry"></a><dl>
<dt><a name="index-gnutls_005fdb_005fcheck_005fentry"></a>Function: <em>int</em> <strong>gnutls_db_check_entry</strong> <em>(gnutls_session_t <var>session</var>, gnutls_datum_t <var>session_entry</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>session_entry</var>: is the session data (not key)
</p>
<p>This function has no effect. 
</p>
<p><strong>Returns:</strong> Returns <code>GNUTLS_E_EXPIRED</code> , if the database entry has
expired or 0 otherwise.
</p></dd></dl>

<a name="gnutls_005fdb_005fcheck_005fentry_005ftime-1"></a>
<h4 class="subheading">gnutls_db_check_entry_time</h4>
<a name="gnutls_005fdb_005fcheck_005fentry_005ftime"></a><dl>
<dt><a name="index-gnutls_005fdb_005fcheck_005fentry_005ftime"></a>Function: <em>time_t</em> <strong>gnutls_db_check_entry_time</strong> <em>(gnutls_datum_t * <var>entry</var>)</em></dt>
<dd><p><var>entry</var>: is a pointer to a <code>gnutls_datum_t</code>  type.
</p>
<p>This function returns the time that this entry was active.
It can be used for database entry expiration.
</p>
<p><strong>Returns:</strong> The time this entry was created, or zero on error.
</p></dd></dl>

<a name="gnutls_005fdb_005fget_005fdefault_005fcache_005fexpiration-1"></a>
<h4 class="subheading">gnutls_db_get_default_cache_expiration</h4>
<a name="gnutls_005fdb_005fget_005fdefault_005fcache_005fexpiration"></a><dl>
<dt><a name="index-gnutls_005fdb_005fget_005fdefault_005fcache_005fexpiration"></a>Function: <em>unsigned</em> <strong>gnutls_db_get_default_cache_expiration</strong> <em>( <var>void</var>)</em></dt>
<dd>
<p>Returns the expiration time (in seconds) of stored sessions for resumption. 
</p></dd></dl>

<a name="gnutls_005fdb_005fget_005fptr-1"></a>
<h4 class="subheading">gnutls_db_get_ptr</h4>
<a name="gnutls_005fdb_005fget_005fptr"></a><dl>
<dt><a name="index-gnutls_005fdb_005fget_005fptr"></a>Function: <em>void *</em> <strong>gnutls_db_get_ptr</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Get db function pointer.
</p>
<p><strong>Returns:</strong> the pointer that will be sent to db store, retrieve and
delete functions, as the first argument.
</p></dd></dl>

<a name="gnutls_005fdb_005fremove_005fsession-1"></a>
<h4 class="subheading">gnutls_db_remove_session</h4>
<a name="gnutls_005fdb_005fremove_005fsession"></a><dl>
<dt><a name="index-gnutls_005fdb_005fremove_005fsession"></a>Function: <em>void</em> <strong>gnutls_db_remove_session</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function will remove the current session data from the
session database.  This will prevent future handshakes reusing
these session data.  This function should be called if a session
was terminated abnormally, and before <code>gnutls_deinit()</code>  is called.
</p>
<p>Normally <code>gnutls_deinit()</code>  will remove abnormally terminated
sessions.
</p></dd></dl>

<a name="gnutls_005fdb_005fset_005fcache_005fexpiration-1"></a>
<h4 class="subheading">gnutls_db_set_cache_expiration</h4>
<a name="gnutls_005fdb_005fset_005fcache_005fexpiration"></a><dl>
<dt><a name="index-gnutls_005fdb_005fset_005fcache_005fexpiration"></a>Function: <em>void</em> <strong>gnutls_db_set_cache_expiration</strong> <em>(gnutls_session_t <var>session</var>, int <var>seconds</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>seconds</var>: is the number of seconds.
</p>
<p>Set the expiration time for resumed sessions. The default is 3600
(one hour) at the time of this writing.
</p></dd></dl>

<a name="gnutls_005fdb_005fset_005fptr-1"></a>
<h4 class="subheading">gnutls_db_set_ptr</h4>
<a name="gnutls_005fdb_005fset_005fptr"></a><dl>
<dt><a name="index-gnutls_005fdb_005fset_005fptr"></a>Function: <em>void</em> <strong>gnutls_db_set_ptr</strong> <em>(gnutls_session_t <var>session</var>, void * <var>ptr</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>ptr</var>: is the pointer
</p>
<p>Sets the pointer that will be provided to db store, retrieve and
delete functions, as the first argument.
</p></dd></dl>

<a name="gnutls_005fdb_005fset_005fremove_005ffunction-1"></a>
<h4 class="subheading">gnutls_db_set_remove_function</h4>
<a name="gnutls_005fdb_005fset_005fremove_005ffunction"></a><dl>
<dt><a name="index-gnutls_005fdb_005fset_005fremove_005ffunction"></a>Function: <em>void</em> <strong>gnutls_db_set_remove_function</strong> <em>(gnutls_session_t <var>session</var>, gnutls_db_remove_func <var>rem_func</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>rem_func</var>: is the function.
</p>
<p>Sets the function that will be used to remove data from the
resumed sessions database. This function must return 0 on success.
</p>
<p>The first argument to  <code>rem_func</code> will be null unless
<code>gnutls_db_set_ptr()</code>  has been called.
</p></dd></dl>

<a name="gnutls_005fdb_005fset_005fretrieve_005ffunction-1"></a>
<h4 class="subheading">gnutls_db_set_retrieve_function</h4>
<a name="gnutls_005fdb_005fset_005fretrieve_005ffunction"></a><dl>
<dt><a name="index-gnutls_005fdb_005fset_005fretrieve_005ffunction"></a>Function: <em>void</em> <strong>gnutls_db_set_retrieve_function</strong> <em>(gnutls_session_t <var>session</var>, gnutls_db_retr_func <var>retr_func</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>retr_func</var>: is the function.
</p>
<p>Sets the function that will be used to retrieve data from the
resumed sessions database.  This function must return a
gnutls_datum_t containing the data on success, or a gnutls_datum_t
containing null and 0 on failure.
</p>
<p>The datum&rsquo;s data must be allocated using the function
<code>gnutls_malloc()</code> .
</p>
<p>The first argument to  <code>retr_func</code> will be null unless
<code>gnutls_db_set_ptr()</code>  has been called.
</p></dd></dl>

<a name="gnutls_005fdb_005fset_005fstore_005ffunction-1"></a>
<h4 class="subheading">gnutls_db_set_store_function</h4>
<a name="gnutls_005fdb_005fset_005fstore_005ffunction"></a><dl>
<dt><a name="index-gnutls_005fdb_005fset_005fstore_005ffunction"></a>Function: <em>void</em> <strong>gnutls_db_set_store_function</strong> <em>(gnutls_session_t <var>session</var>, gnutls_db_store_func <var>store_func</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>store_func</var>: is the function
</p>
<p>Sets the function that will be used to store data in the resumed
sessions database. This function must return 0 on success.
</p>
<p>The first argument to  <code>store_func</code> will be null unless
<code>gnutls_db_set_ptr()</code>  has been called.
</p></dd></dl>

<a name="gnutls_005fdeinit-1"></a>
<h4 class="subheading">gnutls_deinit</h4>
<a name="gnutls_005fdeinit"></a><dl>
<dt><a name="index-gnutls_005fdeinit-1"></a>Function: <em>void</em> <strong>gnutls_deinit</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function clears all buffers associated with the  <code>session</code> .
This function will also remove session data from the session
database if the session was terminated abnormally.
</p></dd></dl>

<a name="gnutls_005fdh_005fget_005fgroup-1"></a>
<h4 class="subheading">gnutls_dh_get_group</h4>
<a name="gnutls_005fdh_005fget_005fgroup"></a><dl>
<dt><a name="index-gnutls_005fdh_005fget_005fgroup"></a>Function: <em>int</em> <strong>gnutls_dh_get_group</strong> <em>(gnutls_session_t <var>session</var>, gnutls_datum_t * <var>raw_gen</var>, gnutls_datum_t * <var>raw_prime</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p><var>raw_gen</var>: will hold the generator.
</p>
<p><var>raw_prime</var>: will hold the prime.
</p>
<p>This function will return the group parameters used in the last
Diffie-Hellman key exchange with the peer.  These are the prime and
the generator used.  This function should be used for both
anonymous and ephemeral Diffie-Hellman.  The output parameters must
be freed with <code>gnutls_free()</code> .
</p>
<p>Note, that the prime and generator are exported as non-negative
integers and may include a leading zero byte.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p></dd></dl>

<a name="gnutls_005fdh_005fget_005fpeers_005fpublic_005fbits-1"></a>
<h4 class="subheading">gnutls_dh_get_peers_public_bits</h4>
<a name="gnutls_005fdh_005fget_005fpeers_005fpublic_005fbits"></a><dl>
<dt><a name="index-gnutls_005fdh_005fget_005fpeers_005fpublic_005fbits"></a>Function: <em>int</em> <strong>gnutls_dh_get_peers_public_bits</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p>Get the Diffie-Hellman public key bit size.  Can be used for both
anonymous and ephemeral Diffie-Hellman.
</p>
<p><strong>Returns:</strong> The public key bit size used in the last Diffie-Hellman
key exchange with the peer, or a negative error code in case of error.
</p></dd></dl>

<a name="gnutls_005fdh_005fget_005fprime_005fbits-1"></a>
<h4 class="subheading">gnutls_dh_get_prime_bits</h4>
<a name="gnutls_005fdh_005fget_005fprime_005fbits"></a><dl>
<dt><a name="index-gnutls_005fdh_005fget_005fprime_005fbits"></a>Function: <em>int</em> <strong>gnutls_dh_get_prime_bits</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p>This function will return the bits of the prime used in the last
Diffie-Hellman key exchange with the peer.  Should be used for both
anonymous and ephemeral Diffie-Hellman.  Note that some ciphers,
like RSA and DSA without DHE, do not use a Diffie-Hellman key
exchange, and then this function will return 0.
</p>
<p><strong>Returns:</strong> The Diffie-Hellman bit strength is returned, or 0 if no
Diffie-Hellman key exchange was done, or a negative error code on
failure.
</p></dd></dl>

<a name="gnutls_005fdh_005fget_005fpubkey-1"></a>
<h4 class="subheading">gnutls_dh_get_pubkey</h4>
<a name="gnutls_005fdh_005fget_005fpubkey"></a><dl>
<dt><a name="index-gnutls_005fdh_005fget_005fpubkey"></a>Function: <em>int</em> <strong>gnutls_dh_get_pubkey</strong> <em>(gnutls_session_t <var>session</var>, gnutls_datum_t * <var>raw_key</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p><var>raw_key</var>: will hold the public key.
</p>
<p>This function will return the peer&rsquo;s public key used in the last
Diffie-Hellman key exchange.  This function should be used for both
anonymous and ephemeral Diffie-Hellman.  The output parameters must
be freed with <code>gnutls_free()</code> .
</p>
<p>Note, that public key is exported as non-negative
integer and may include a leading zero byte.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p></dd></dl>

<a name="gnutls_005fdh_005fget_005fsecret_005fbits-1"></a>
<h4 class="subheading">gnutls_dh_get_secret_bits</h4>
<a name="gnutls_005fdh_005fget_005fsecret_005fbits"></a><dl>
<dt><a name="index-gnutls_005fdh_005fget_005fsecret_005fbits"></a>Function: <em>int</em> <strong>gnutls_dh_get_secret_bits</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p>This function will return the bits used in the last Diffie-Hellman
key exchange with the peer.  Should be used for both anonymous and
ephemeral Diffie-Hellman.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p></dd></dl>

<a name="gnutls_005fdh_005fparams_005fcpy-1"></a>
<h4 class="subheading">gnutls_dh_params_cpy</h4>
<a name="gnutls_005fdh_005fparams_005fcpy"></a><dl>
<dt><a name="index-gnutls_005fdh_005fparams_005fcpy"></a>Function: <em>int</em> <strong>gnutls_dh_params_cpy</strong> <em>(gnutls_dh_params_t <var>dst</var>, gnutls_dh_params_t <var>src</var>)</em></dt>
<dd><p><var>dst</var>: Is the destination parameters, which should be initialized.
</p>
<p><var>src</var>: Is the source parameters
</p>
<p>This function will copy the DH parameters structure from source
to destination.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p></dd></dl>

<a name="gnutls_005fdh_005fparams_005fdeinit-1"></a>
<h4 class="subheading">gnutls_dh_params_deinit</h4>
<a name="gnutls_005fdh_005fparams_005fdeinit"></a><dl>
<dt><a name="index-gnutls_005fdh_005fparams_005fdeinit"></a>Function: <em>void</em> <strong>gnutls_dh_params_deinit</strong> <em>(gnutls_dh_params_t <var>dh_params</var>)</em></dt>
<dd><p><var>dh_params</var>: The parameters
</p>
<p>This function will deinitialize the DH parameters type.
</p></dd></dl>

<a name="gnutls_005fdh_005fparams_005fexport2_005fpkcs3-1"></a>
<h4 class="subheading">gnutls_dh_params_export2_pkcs3</h4>
<a name="gnutls_005fdh_005fparams_005fexport2_005fpkcs3"></a><dl>
<dt><a name="index-gnutls_005fdh_005fparams_005fexport2_005fpkcs3"></a>Function: <em>int</em> <strong>gnutls_dh_params_export2_pkcs3</strong> <em>(gnutls_dh_params_t <var>params</var>, gnutls_x509_crt_fmt_t <var>format</var>, gnutls_datum_t * <var>out</var>)</em></dt>
<dd><p><var>params</var>: Holds the DH parameters
</p>
<p><var>format</var>: the format of output params. One of PEM or DER.
</p>
<p><var>out</var>: will contain a PKCS3 DHParams structure PEM or DER encoded
</p>
<p>This function will export the given dh parameters to a PKCS3
DHParams structure. This is the format generated by &quot;openssl dhparam&quot; tool.
The data in  <code>out</code> will be allocated using <code>gnutls_malloc()</code> .
</p>
<p>If the structure is PEM encoded, it will have a header
of &quot;BEGIN DH PARAMETERS&quot;.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p>
<p><strong>Since:</strong> 3.1.3
</p></dd></dl>

<a name="gnutls_005fdh_005fparams_005fexport_005fpkcs3-1"></a>
<h4 class="subheading">gnutls_dh_params_export_pkcs3</h4>
<a name="gnutls_005fdh_005fparams_005fexport_005fpkcs3"></a><dl>
<dt><a name="index-gnutls_005fdh_005fparams_005fexport_005fpkcs3"></a>Function: <em>int</em> <strong>gnutls_dh_params_export_pkcs3</strong> <em>(gnutls_dh_params_t <var>params</var>, gnutls_x509_crt_fmt_t <var>format</var>, unsigned char * <var>params_data</var>, size_t * <var>params_data_size</var>)</em></dt>
<dd><p><var>params</var>: Holds the DH parameters
</p>
<p><var>format</var>: the format of output params. One of PEM or DER.
</p>
<p><var>params_data</var>: will contain a PKCS3 DHParams structure PEM or DER encoded
</p>
<p><var>params_data_size</var>: holds the size of params_data (and will be replaced by the actual size of parameters)
</p>
<p>This function will export the given dh parameters to a PKCS3
DHParams structure. This is the format generated by &quot;openssl dhparam&quot; tool.
If the buffer provided is not long enough to hold the output, then
GNUTLS_E_SHORT_MEMORY_BUFFER will be returned.
</p>
<p>If the structure is PEM encoded, it will have a header
of &quot;BEGIN DH PARAMETERS&quot;.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p></dd></dl>

<a name="gnutls_005fdh_005fparams_005fexport_005fraw-1"></a>
<h4 class="subheading">gnutls_dh_params_export_raw</h4>
<a name="gnutls_005fdh_005fparams_005fexport_005fraw"></a><dl>
<dt><a name="index-gnutls_005fdh_005fparams_005fexport_005fraw"></a>Function: <em>int</em> <strong>gnutls_dh_params_export_raw</strong> <em>(gnutls_dh_params_t <var>params</var>, gnutls_datum_t * <var>prime</var>, gnutls_datum_t * <var>generator</var>, unsigned int * <var>bits</var>)</em></dt>
<dd><p><var>params</var>: Holds the DH parameters
</p>
<p><var>prime</var>: will hold the new prime
</p>
<p><var>generator</var>: will hold the new generator
</p>
<p><var>bits</var>: if non null will hold the secret key&rsquo;s number of bits
</p>
<p>This function will export the pair of prime and generator for use
in the Diffie-Hellman key exchange.  The new parameters will be
allocated using <code>gnutls_malloc()</code>  and will be stored in the
appropriate datum.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p></dd></dl>

<a name="gnutls_005fdh_005fparams_005fgenerate2-1"></a>
<h4 class="subheading">gnutls_dh_params_generate2</h4>
<a name="gnutls_005fdh_005fparams_005fgenerate2"></a><dl>
<dt><a name="index-gnutls_005fdh_005fparams_005fgenerate2"></a>Function: <em>int</em> <strong>gnutls_dh_params_generate2</strong> <em>(gnutls_dh_params_t <var>dparams</var>, unsigned int <var>bits</var>)</em></dt>
<dd><p><var>dparams</var>: The parameters
</p>
<p><var>bits</var>: is the prime&rsquo;s number of bits
</p>
<p>This function will generate a new pair of prime and generator for use in
the Diffie-Hellman key exchange. The new parameters will be allocated using
<code>gnutls_malloc()</code>  and will be stored in the appropriate datum.
This function is normally slow.
</p>
<p>Do not set the number of bits directly, use <code>gnutls_sec_param_to_pk_bits()</code>  to
get bits for <code>GNUTLS_PK_DSA</code> .
Also note that the DH parameters are only useful to servers.
Since clients use the parameters sent by the server, it&rsquo;s of
no use to call this in client side.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p></dd></dl>

<a name="gnutls_005fdh_005fparams_005fimport_005fdsa-1"></a>
<h4 class="subheading">gnutls_dh_params_import_dsa</h4>
<a name="gnutls_005fdh_005fparams_005fimport_005fdsa"></a><dl>
<dt><a name="index-gnutls_005fdh_005fparams_005fimport_005fdsa"></a>Function: <em>int</em> <strong>gnutls_dh_params_import_dsa</strong> <em>(gnutls_dh_params_t <var>dh_params</var>, gnutls_x509_privkey_t <var>key</var>)</em></dt>
<dd><p><var>dh_params</var>: The parameters
</p>
<p><var>key</var>: holds a DSA private key
</p>
<p>This function will import the prime and generator of the DSA key for use 
in the Diffie-Hellman key exchange.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p></dd></dl>

<a name="gnutls_005fdh_005fparams_005fimport_005fpkcs3-1"></a>
<h4 class="subheading">gnutls_dh_params_import_pkcs3</h4>
<a name="gnutls_005fdh_005fparams_005fimport_005fpkcs3"></a><dl>
<dt><a name="index-gnutls_005fdh_005fparams_005fimport_005fpkcs3"></a>Function: <em>int</em> <strong>gnutls_dh_params_import_pkcs3</strong> <em>(gnutls_dh_params_t <var>params</var>, const gnutls_datum_t * <var>pkcs3_params</var>, gnutls_x509_crt_fmt_t <var>format</var>)</em></dt>
<dd><p><var>params</var>: The parameters
</p>
<p><var>pkcs3_params</var>: should contain a PKCS3 DHParams structure PEM or DER encoded
</p>
<p><var>format</var>: the format of params. PEM or DER.
</p>
<p>This function will extract the DHParams found in a PKCS3 formatted
structure. This is the format generated by &quot;openssl dhparam&quot; tool.
</p>
<p>If the structure is PEM encoded, it should have a header
of &quot;BEGIN DH PARAMETERS&quot;.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p></dd></dl>

<a name="gnutls_005fdh_005fparams_005fimport_005fraw-1"></a>
<h4 class="subheading">gnutls_dh_params_import_raw</h4>
<a name="gnutls_005fdh_005fparams_005fimport_005fraw"></a><dl>
<dt><a name="index-gnutls_005fdh_005fparams_005fimport_005fraw"></a>Function: <em>int</em> <strong>gnutls_dh_params_import_raw</strong> <em>(gnutls_dh_params_t <var>dh_params</var>, const gnutls_datum_t * <var>prime</var>, const gnutls_datum_t * <var>generator</var>)</em></dt>
<dd><p><var>dh_params</var>: The parameters
</p>
<p><var>prime</var>: holds the new prime
</p>
<p><var>generator</var>: holds the new generator
</p>
<p>This function will replace the pair of prime and generator for use
in the Diffie-Hellman key exchange.  The new parameters should be
stored in the appropriate gnutls_datum.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p></dd></dl>

<a name="gnutls_005fdh_005fparams_005fimport_005fraw2-1"></a>
<h4 class="subheading">gnutls_dh_params_import_raw2</h4>
<a name="gnutls_005fdh_005fparams_005fimport_005fraw2"></a><dl>
<dt><a name="index-gnutls_005fdh_005fparams_005fimport_005fraw2"></a>Function: <em>int</em> <strong>gnutls_dh_params_import_raw2</strong> <em>(gnutls_dh_params_t <var>dh_params</var>, const gnutls_datum_t * <var>prime</var>, const gnutls_datum_t * <var>generator</var>, unsigned <var>key_bits</var>)</em></dt>
<dd><p><var>dh_params</var>: The parameters
</p>
<p><var>prime</var>: holds the new prime
</p>
<p><var>generator</var>: holds the new generator
</p>
<p><var>key_bits</var>: the private key bits (set to zero when unknown)
</p>
<p>This function will replace the pair of prime and generator for use
in the Diffie-Hellman key exchange.  The new parameters should be
stored in the appropriate gnutls_datum.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p></dd></dl>

<a name="gnutls_005fdh_005fparams_005finit-1"></a>
<h4 class="subheading">gnutls_dh_params_init</h4>
<a name="gnutls_005fdh_005fparams_005finit"></a><dl>
<dt><a name="index-gnutls_005fdh_005fparams_005finit"></a>Function: <em>int</em> <strong>gnutls_dh_params_init</strong> <em>(gnutls_dh_params_t * <var>dh_params</var>)</em></dt>
<dd><p><var>dh_params</var>: The parameters
</p>
<p>This function will initialize the DH parameters type.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p></dd></dl>

<a name="gnutls_005fdh_005fset_005fprime_005fbits-1"></a>
<h4 class="subheading">gnutls_dh_set_prime_bits</h4>
<a name="gnutls_005fdh_005fset_005fprime_005fbits"></a><dl>
<dt><a name="index-gnutls_005fdh_005fset_005fprime_005fbits"></a>Function: <em>void</em> <strong>gnutls_dh_set_prime_bits</strong> <em>(gnutls_session_t <var>session</var>, unsigned int <var>bits</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>bits</var>: is the number of bits
</p>
<p>This function sets the number of bits, for use in a Diffie-Hellman
key exchange.  This is used both in DH ephemeral and DH anonymous
cipher suites.  This will set the minimum size of the prime that
will be used for the handshake.
</p>
<p>In the client side it sets the minimum accepted number of bits.  If
a server sends a prime with less bits than that
<code>GNUTLS_E_DH_PRIME_UNACCEPTABLE</code>  will be returned by the handshake.
</p>
<p>Note that this function will warn via the audit log for value that
are believed to be weak.
</p>
<p>The function has no effect in server side.
</p>
<p>Note that since 3.1.7 this function is deprecated. The minimum
number of bits is set by the priority string level.
Also this function must be called after <code>gnutls_priority_set_direct()</code> 
or the set value may be overridden by the selected priority options.
</p></dd></dl>

<a name="gnutls_005fdigest_005fget_005fid-1"></a>
<h4 class="subheading">gnutls_digest_get_id</h4>
<a name="gnutls_005fdigest_005fget_005fid"></a><dl>
<dt><a name="index-gnutls_005fdigest_005fget_005fid"></a>Function: <em>gnutls_digest_algorithm_t</em> <strong>gnutls_digest_get_id</strong> <em>(const char * <var>name</var>)</em></dt>
<dd><p><var>name</var>: is a digest algorithm name
</p>
<p>Convert a string to a <code>gnutls_digest_algorithm_t</code>  value.  The names are
compared in a case insensitive way.
</p>
<p><strong>Returns:</strong> a <code>gnutls_digest_algorithm_t</code>  id of the specified MAC
algorithm string, or <code>GNUTLS_DIG_UNKNOWN</code>  on failure.
</p></dd></dl>

<a name="gnutls_005fdigest_005fget_005fname-1"></a>
<h4 class="subheading">gnutls_digest_get_name</h4>
<a name="gnutls_005fdigest_005fget_005fname"></a><dl>
<dt><a name="index-gnutls_005fdigest_005fget_005fname"></a>Function: <em>const char *</em> <strong>gnutls_digest_get_name</strong> <em>(gnutls_digest_algorithm_t <var>algorithm</var>)</em></dt>
<dd><p><var>algorithm</var>: is a digest algorithm
</p>
<p>Convert a <code>gnutls_digest_algorithm_t</code>  value to a string.
</p>
<p><strong>Returns:</strong> a string that contains the name of the specified digest
algorithm, or <code>NULL</code> .
</p></dd></dl>

<a name="gnutls_005fdigest_005fget_005foid-1"></a>
<h4 class="subheading">gnutls_digest_get_oid</h4>
<a name="gnutls_005fdigest_005fget_005foid"></a><dl>
<dt><a name="index-gnutls_005fdigest_005fget_005foid"></a>Function: <em>const char *</em> <strong>gnutls_digest_get_oid</strong> <em>(gnutls_digest_algorithm_t <var>algorithm</var>)</em></dt>
<dd><p><var>algorithm</var>: is a digest algorithm
</p>
<p>Convert a <code>gnutls_digest_algorithm_t</code>  value to its object identifier.
</p>
<p><strong>Returns:</strong> a string that contains the object identifier of the specified digest
algorithm, or <code>NULL</code> .
</p>
<p><strong>Since:</strong> 3.4.3
</p></dd></dl>

<a name="gnutls_005fdigest_005flist-1"></a>
<h4 class="subheading">gnutls_digest_list</h4>
<a name="gnutls_005fdigest_005flist"></a><dl>
<dt><a name="index-gnutls_005fdigest_005flist"></a>Function: <em>const gnutls_digest_algorithm_t *</em> <strong>gnutls_digest_list</strong> <em>( <var>void</var>)</em></dt>
<dd>
<p>Get a list of hash (digest) algorithms supported by GnuTLS.
</p>
<p>This function is not thread safe.
</p>
<p><strong>Returns:</strong> Return a (0)-terminated list of <code>gnutls_digest_algorithm_t</code> 
integers indicating the available digests.
</p></dd></dl>

<a name="gnutls_005fecc_005fcurve_005fget-1"></a>
<h4 class="subheading">gnutls_ecc_curve_get</h4>
<a name="gnutls_005fecc_005fcurve_005fget"></a><dl>
<dt><a name="index-gnutls_005fecc_005fcurve_005fget"></a>Function: <em>gnutls_ecc_curve_t</em> <strong>gnutls_ecc_curve_get</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Returns the currently used elliptic curve. Only valid
when using an elliptic curve ciphersuite.
</p>
<p><strong>Returns:</strong> the currently used curve, a <code>gnutls_ecc_curve_t</code> 
type.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<a name="gnutls_005fecc_005fcurve_005fget_005fid-1"></a>
<h4 class="subheading">gnutls_ecc_curve_get_id</h4>
<a name="gnutls_005fecc_005fcurve_005fget_005fid"></a><dl>
<dt><a name="index-gnutls_005fecc_005fcurve_005fget_005fid"></a>Function: <em>gnutls_ecc_curve_t</em> <strong>gnutls_ecc_curve_get_id</strong> <em>(const char * <var>name</var>)</em></dt>
<dd><p><var>name</var>: is a curve name
</p>
<p>The names are compared in a case insensitive way.
</p>
<p><strong>Returns:</strong> return a <code>gnutls_ecc_curve_t</code>  value corresponding to
the specified curve, or <code>GNUTLS_ECC_CURVE_INVALID</code>  on error.
</p>
<p><strong>Since:</strong> 3.4.3
</p></dd></dl>

<a name="gnutls_005fecc_005fcurve_005fget_005fname-1"></a>
<h4 class="subheading">gnutls_ecc_curve_get_name</h4>
<a name="gnutls_005fecc_005fcurve_005fget_005fname"></a><dl>
<dt><a name="index-gnutls_005fecc_005fcurve_005fget_005fname"></a>Function: <em>const char *</em> <strong>gnutls_ecc_curve_get_name</strong> <em>(gnutls_ecc_curve_t <var>curve</var>)</em></dt>
<dd><p><var>curve</var>: is an ECC curve
</p>
<p>Convert a <code>gnutls_ecc_curve_t</code>  value to a string.
</p>
<p><strong>Returns:</strong> a string that contains the name of the specified
curve or <code>NULL</code> .
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<a name="gnutls_005fecc_005fcurve_005fget_005foid-1"></a>
<h4 class="subheading">gnutls_ecc_curve_get_oid</h4>
<a name="gnutls_005fecc_005fcurve_005fget_005foid"></a><dl>
<dt><a name="index-gnutls_005fecc_005fcurve_005fget_005foid"></a>Function: <em>const char *</em> <strong>gnutls_ecc_curve_get_oid</strong> <em>(gnutls_ecc_curve_t <var>curve</var>)</em></dt>
<dd><p><var>curve</var>: is an ECC curve
</p>
<p>Convert a <code>gnutls_ecc_curve_t</code>  value to its object identifier.
</p>
<p><strong>Returns:</strong> a string that contains the OID of the specified
curve or <code>NULL</code> .
</p>
<p><strong>Since:</strong> 3.4.3
</p></dd></dl>

<a name="gnutls_005fecc_005fcurve_005fget_005fpk-1"></a>
<h4 class="subheading">gnutls_ecc_curve_get_pk</h4>
<a name="gnutls_005fecc_005fcurve_005fget_005fpk"></a><dl>
<dt><a name="index-gnutls_005fecc_005fcurve_005fget_005fpk"></a>Function: <em>gnutls_pk_algorithm_t</em> <strong>gnutls_ecc_curve_get_pk</strong> <em>(gnutls_ecc_curve_t <var>curve</var>)</em></dt>
<dd><p><var>curve</var>: is an ECC curve
</p>

<p><strong>Returns:</strong> the public key algorithm associated with the named curve or <code>GNUTLS_PK_UNKNOWN</code> .
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<a name="gnutls_005fecc_005fcurve_005fget_005fsize-1"></a>
<h4 class="subheading">gnutls_ecc_curve_get_size</h4>
<a name="gnutls_005fecc_005fcurve_005fget_005fsize"></a><dl>
<dt><a name="index-gnutls_005fecc_005fcurve_005fget_005fsize"></a>Function: <em>int</em> <strong>gnutls_ecc_curve_get_size</strong> <em>(gnutls_ecc_curve_t <var>curve</var>)</em></dt>
<dd><p><var>curve</var>: is an ECC curve
</p>

<p><strong>Returns:</strong> the size in bytes of the curve or 0 on failure.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<a name="gnutls_005fecc_005fcurve_005flist-1"></a>
<h4 class="subheading">gnutls_ecc_curve_list</h4>
<a name="gnutls_005fecc_005fcurve_005flist"></a><dl>
<dt><a name="index-gnutls_005fecc_005fcurve_005flist"></a>Function: <em>const gnutls_ecc_curve_t *</em> <strong>gnutls_ecc_curve_list</strong> <em>( <var>void</var>)</em></dt>
<dd>
<p>Get the list of supported elliptic curves.
</p>
<p>This function is not thread safe.
</p>
<p><strong>Returns:</strong> Return a (0)-terminated list of <code>gnutls_ecc_curve_t</code> 
integers indicating the available curves.
</p></dd></dl>

<a name="gnutls_005ferror_005fis_005ffatal-1"></a>
<h4 class="subheading">gnutls_error_is_fatal</h4>
<a name="gnutls_005ferror_005fis_005ffatal"></a><dl>
<dt><a name="index-gnutls_005ferror_005fis_005ffatal-1"></a>Function: <em>int</em> <strong>gnutls_error_is_fatal</strong> <em>(int <var>error</var>)</em></dt>
<dd><p><var>error</var>: is a GnuTLS error code, a negative error code
</p>
<p>If a GnuTLS function returns a negative error code you may feed that
value to this function to see if the error condition is fatal to
a TLS session (i.e., must be terminated). 
</p>
<p>Note that you may also want to check the error code manually, since some
non-fatal errors to the protocol (such as a warning alert or
a rehandshake request) may be fatal for your program.
</p>
<p>This function is only useful if you are dealing with errors from
functions that relate to a TLS session (e.g., record layer or handshake 
layer handling functions).
</p>
<p><strong>Returns:</strong> Non-zero value on fatal errors or zero on non-fatal.
</p></dd></dl>

<a name="gnutls_005ferror_005fto_005falert-1"></a>
<h4 class="subheading">gnutls_error_to_alert</h4>
<a name="gnutls_005ferror_005fto_005falert"></a><dl>
<dt><a name="index-gnutls_005ferror_005fto_005falert-1"></a>Function: <em>int</em> <strong>gnutls_error_to_alert</strong> <em>(int <var>err</var>, int * <var>level</var>)</em></dt>
<dd><p><var>err</var>: is a negative integer
</p>
<p><var>level</var>: the alert level will be stored there
</p>
<p>Get an alert depending on the error code returned by a gnutls
function.  All alerts sent by this function should be considered
fatal.  The only exception is when  <code>err</code> is <code>GNUTLS_E_REHANDSHAKE</code> ,
where a warning alert should be sent to the peer indicating that no
renegotiation will be performed.
</p>
<p>If there is no mapping to a valid alert the alert to indicate
internal error is returned.
</p>
<p><strong>Returns:</strong> the alert code to use for a particular error code.
</p></dd></dl>

<a name="gnutls_005fest_005frecord_005foverhead_005fsize-1"></a>
<h4 class="subheading">gnutls_est_record_overhead_size</h4>
<a name="gnutls_005fest_005frecord_005foverhead_005fsize"></a><dl>
<dt><a name="index-gnutls_005fest_005frecord_005foverhead_005fsize"></a>Function: <em>size_t</em> <strong>gnutls_est_record_overhead_size</strong> <em>(gnutls_protocol_t <var>version</var>, gnutls_cipher_algorithm_t <var>cipher</var>, gnutls_mac_algorithm_t <var>mac</var>, gnutls_compression_method_t <var>comp</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>version</var>: is a <code>gnutls_protocol_t</code>  value
</p>
<p><var>cipher</var>: is a <code>gnutls_cipher_algorithm_t</code>  value
</p>
<p><var>mac</var>: is a <code>gnutls_mac_algorithm_t</code>  value
</p>
<p><var>comp</var>: is a <code>gnutls_compression_method_t</code>  value
</p>
<p><var>flags</var>: must be zero
</p>
<p>This function will return the set size in bytes of the overhead
due to TLS (or DTLS) per record.
</p>
<p>Note that this function may provide inacurate values when TLS
extensions that modify the record format are negotiated. In these
cases a more accurate value can be obtained using <code>gnutls_record_overhead_size()</code>  
after a completed handshake.
</p>
<p><strong>Since:</strong> 3.2.2
</p></dd></dl>

<a name="gnutls_005fext_005fget_005fdata-1"></a>
<h4 class="subheading">gnutls_ext_get_data</h4>
<a name="gnutls_005fext_005fget_005fdata"></a><dl>
<dt><a name="index-gnutls_005fext_005fget_005fdata"></a>Function: <em>int</em> <strong>gnutls_ext_get_data</strong> <em>(gnutls_session_t <var>session</var>, unsigned <var>type</var>, gnutls_ext_priv_data_t * <var>data</var>)</em></dt>
<dd><p><var>session</var>: a <code>gnutls_session_t</code>  opaque pointer
</p>
<p><var>type</var>: the numeric id of the extension
</p>
<p><var>data</var>: a pointer to the private data to retrieve
</p>
<p>This function retrieves any data previously stored with <code>gnutls_ext_set_data()</code> .
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<a name="gnutls_005fext_005fget_005fname-1"></a>
<h4 class="subheading">gnutls_ext_get_name</h4>
<a name="gnutls_005fext_005fget_005fname"></a><dl>
<dt><a name="index-gnutls_005fext_005fget_005fname"></a>Function: <em>const char *</em> <strong>gnutls_ext_get_name</strong> <em>(unsigned int <var>ext</var>)</em></dt>
<dd><p><var>ext</var>: is a TLS extension numeric ID
</p>
<p>Convert a TLS extension numeric ID to a printable string.
</p>
<p><strong>Returns:</strong> a pointer to a string that contains the name of the
specified cipher, or <code>NULL</code> .
</p></dd></dl>

<a name="gnutls_005fext_005fregister-1"></a>
<h4 class="subheading">gnutls_ext_register</h4>
<a name="gnutls_005fext_005fregister"></a><dl>
<dt><a name="index-gnutls_005fext_005fregister"></a>Function: <em>int</em> <strong>gnutls_ext_register</strong> <em>(const char * <var>name</var>, int <var>type</var>, gnutls_ext_parse_type_t <var>parse_type</var>, gnutls_ext_recv_func <var>recv_func</var>, gnutls_ext_send_func <var>send_func</var>, gnutls_ext_deinit_data_func <var>deinit_func</var>, gnutls_ext_pack_func <var>pack_func</var>, gnutls_ext_unpack_func <var>unpack_func</var>)</em></dt>
<dd><p><var>name</var>: the name of the extension to register
</p>
<p><var>type</var>: the numeric id of the extension
</p>
<p><var>parse_type</var>: the parse type of the extension (see gnutls_ext_parse_type_t)
</p>
<p><var>recv_func</var>: a function to receive the data
</p>
<p><var>send_func</var>: a function to send the data
</p>
<p><var>deinit_func</var>: a function deinitialize any private data
</p>
<p><var>pack_func</var>: a function which serializes the extension&rsquo;s private data (used on session packing for resumption)
</p>
<p><var>unpack_func</var>: a function which will deserialize the extension&rsquo;s private data
</p>
<p>This function will register a new extension type. The extension will remain
registered until <code>gnutls_global_deinit()</code>  is called. If the extension type
is already registered then <code>GNUTLS_E_ALREADY_REGISTERED</code>  will be returned.
</p>
<p>Each registered extension can store temporary data into the gnutls_session_t
structure using <code>gnutls_ext_set_data()</code> , and they can be retrieved using
<code>gnutls_ext_get_data()</code> .
</p>
<p>This function is not thread safe.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<a name="gnutls_005fext_005fset_005fdata-1"></a>
<h4 class="subheading">gnutls_ext_set_data</h4>
<a name="gnutls_005fext_005fset_005fdata"></a><dl>
<dt><a name="index-gnutls_005fext_005fset_005fdata"></a>Function: <em>void</em> <strong>gnutls_ext_set_data</strong> <em>(gnutls_session_t <var>session</var>, unsigned <var>type</var>, gnutls_ext_priv_data_t <var>data</var>)</em></dt>
<dd><p><var>session</var>: a <code>gnutls_session_t</code>  opaque pointer
</p>
<p><var>type</var>: the numeric id of the extension
</p>
<p><var>data</var>: the private data to set
</p>
<p>This function allows an extension handler to store data in the current session
and retrieve them later on. The set data will be deallocated using
the gnutls_ext_deinit_data_func.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<a name="gnutls_005ffingerprint-1"></a>
<h4 class="subheading">gnutls_fingerprint</h4>
<a name="gnutls_005ffingerprint"></a><dl>
<dt><a name="index-gnutls_005ffingerprint"></a>Function: <em>int</em> <strong>gnutls_fingerprint</strong> <em>(gnutls_digest_algorithm_t <var>algo</var>, const gnutls_datum_t * <var>data</var>, void * <var>result</var>, size_t * <var>result_size</var>)</em></dt>
<dd><p><var>algo</var>: is a digest algorithm
</p>
<p><var>data</var>: is the data
</p>
<p><var>result</var>: is the place where the result will be copied (may be null).
</p>
<p><var>result_size</var>: should hold the size of the result. The actual size
of the returned result will also be copied there.
</p>
<p>This function will calculate a fingerprint (actually a hash), of
the given data.  The result is not printable data.  You should
convert it to hex, or to something else printable.
</p>
<p>This is the usual way to calculate a fingerprint of an X.509 DER
encoded certificate.  Note however that the fingerprint of an
OpenPGP certificate is not just a hash and cannot be calculated with this
function.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p></dd></dl>

<a name="gnutls_005ffips140_005fmode_005fenabled-1"></a>
<h4 class="subheading">gnutls_fips140_mode_enabled</h4>
<a name="gnutls_005ffips140_005fmode_005fenabled"></a><dl>
<dt><a name="index-gnutls_005ffips140_005fmode_005fenabled"></a>Function: <em>unsigned</em> <strong>gnutls_fips140_mode_enabled</strong> <em>( <var>void</var>)</em></dt>
<dd>
<p>Checks whether this library is in FIPS140 mode.
</p>
<p><strong>Returns:</strong> return non-zero if true or zero if false.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fglobal_005fdeinit-1"></a>
<h4 class="subheading">gnutls_global_deinit</h4>
<a name="gnutls_005fglobal_005fdeinit"></a><dl>
<dt><a name="index-gnutls_005fglobal_005fdeinit"></a>Function: <em>void</em> <strong>gnutls_global_deinit</strong> <em>( <var>void</var>)</em></dt>
<dd>
<p>This function deinitializes the global data, that were initialized
using <code>gnutls_global_init()</code> .
</p></dd></dl>

<a name="gnutls_005fglobal_005finit-1"></a>
<h4 class="subheading">gnutls_global_init</h4>
<a name="gnutls_005fglobal_005finit"></a><dl>
<dt><a name="index-gnutls_005fglobal_005finit"></a>Function: <em>int</em> <strong>gnutls_global_init</strong> <em>( <var>void</var>)</em></dt>
<dd>
<p>This function performs any required precalculations, detects
the supported CPU capabilities and initializes the underlying
cryptographic backend. In order to free any resources 
taken by this call you should <code>gnutls_global_deinit()</code>  
when gnutls usage is no longer needed.
</p>
<p>This function increments a global counter, so that
<code>gnutls_global_deinit()</code>  only releases resources when it has been
called as many times as <code>gnutls_global_init()</code> .  This is useful when
GnuTLS is used by more than one library in an application.  This
function can be called many times, but will only do something the
first time.
</p>
<p>Since GnuTLS 3.3.0 this function is automatically called on library
constructor. Since the same version this function is also thread safe.
The automatic initialization can be avoided if the environment variable
<code>GNUTLS_NO_EXPLICIT_INIT</code>  is set to be 1.
</p>
<p>A subsequent call of this function if the initial has failed will
return the same error code.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p></dd></dl>

<a name="gnutls_005fglobal_005fset_005faudit_005flog_005ffunction-1"></a>
<h4 class="subheading">gnutls_global_set_audit_log_function</h4>
<a name="gnutls_005fglobal_005fset_005faudit_005flog_005ffunction"></a><dl>
<dt><a name="index-gnutls_005fglobal_005fset_005faudit_005flog_005ffunction-1"></a>Function: <em>void</em> <strong>gnutls_global_set_audit_log_function</strong> <em>(gnutls_audit_log_func <var>log_func</var>)</em></dt>
<dd><p><var>log_func</var>: it is the audit log function
</p>
<p>This is the function to set the audit logging function. This
is a function to report important issues, such as possible
attacks in the protocol. This is different from <code>gnutls_global_set_log_function()</code> 
because it will report also session-specific events. The session
parameter will be null if there is no corresponding TLS session.
</p>
<p><code>gnutls_audit_log_func</code> is of the form,
void (*gnutls_audit_log_func)( gnutls_session_t, const char*);
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<a name="gnutls_005fglobal_005fset_005flog_005ffunction-1"></a>
<h4 class="subheading">gnutls_global_set_log_function</h4>
<a name="gnutls_005fglobal_005fset_005flog_005ffunction"></a><dl>
<dt><a name="index-gnutls_005fglobal_005fset_005flog_005ffunction"></a>Function: <em>void</em> <strong>gnutls_global_set_log_function</strong> <em>(gnutls_log_func <var>log_func</var>)</em></dt>
<dd><p><var>log_func</var>: it&rsquo;s a log function
</p>
<p>This is the function where you set the logging function gnutls is
going to use.  This function only accepts a character array.
Normally you may not use this function since it is only used for
debugging purposes.
</p>
<p><code>gnutls_log_func</code> is of the form,
void (*gnutls_log_func)( int level, const char*);
</p></dd></dl>

<a name="gnutls_005fglobal_005fset_005flog_005flevel-1"></a>
<h4 class="subheading">gnutls_global_set_log_level</h4>
<a name="gnutls_005fglobal_005fset_005flog_005flevel"></a><dl>
<dt><a name="index-gnutls_005fglobal_005fset_005flog_005flevel"></a>Function: <em>void</em> <strong>gnutls_global_set_log_level</strong> <em>(int <var>level</var>)</em></dt>
<dd><p><var>level</var>: it&rsquo;s an integer from 0 to 99.
</p>
<p>This is the function that allows you to set the log level.  The
level is an integer between 0 and 9.  Higher values mean more
verbosity. The default value is 0.  Larger values should only be
used with care, since they may reveal sensitive information.
</p>
<p>Use a log level over 10 to enable all debugging options.
</p></dd></dl>

<a name="gnutls_005fglobal_005fset_005fmutex-1"></a>
<h4 class="subheading">gnutls_global_set_mutex</h4>
<a name="gnutls_005fglobal_005fset_005fmutex"></a><dl>
<dt><a name="index-gnutls_005fglobal_005fset_005fmutex-1"></a>Function: <em>void</em> <strong>gnutls_global_set_mutex</strong> <em>(mutex_init_func <var>init</var>, mutex_deinit_func <var>deinit</var>, mutex_lock_func <var>lock</var>, mutex_unlock_func <var>unlock</var>)</em></dt>
<dd><p><var>init</var>: mutex initialization function
</p>
<p><var>deinit</var>: mutex deinitialization function
</p>
<p><var>lock</var>: mutex locking function
</p>
<p><var>unlock</var>: mutex unlocking function
</p>
<p>With this function you are allowed to override the default mutex
locks used in some parts of gnutls and dependent libraries. This function
should be used if you have complete control of your program and libraries.
Do not call this function from a library, or preferably from any application
unless really needed to. GnuTLS will use the appropriate locks for the running
system.
</p>
<p>This function must be called prior to any other gnutls function.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<a name="gnutls_005fglobal_005fset_005ftime_005ffunction-1"></a>
<h4 class="subheading">gnutls_global_set_time_function</h4>
<a name="gnutls_005fglobal_005fset_005ftime_005ffunction"></a><dl>
<dt><a name="index-gnutls_005fglobal_005fset_005ftime_005ffunction"></a>Function: <em>void</em> <strong>gnutls_global_set_time_function</strong> <em>(gnutls_time_func <var>time_func</var>)</em></dt>
<dd><p><var>time_func</var>: it&rsquo;s the system time function, a <code>gnutls_time_func()</code>  callback.
</p>
<p>This is the function where you can override the default system time
function.  The application provided function should behave the same
as the standard function.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<a name="gnutls_005fhandshake-1"></a>
<h4 class="subheading">gnutls_handshake</h4>
<a name="gnutls_005fhandshake"></a><dl>
<dt><a name="index-gnutls_005fhandshake-1"></a>Function: <em>int</em> <strong>gnutls_handshake</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function does the handshake of the TLS/SSL protocol, and
initializes the TLS connection.
</p>
<p>This function will fail if any problem is encountered, and will
return a negative error code. In case of a client, if the client
has asked to resume a session, but the server couldn&rsquo;t, then a
full handshake will be performed.
</p>
<p>The non-fatal errors expected by this function are:
<code>GNUTLS_E_INTERRUPTED</code> , <code>GNUTLS_E_AGAIN</code> , 
<code>GNUTLS_E_WARNING_ALERT_RECEIVED</code> , and <code>GNUTLS_E_GOT_APPLICATION_DATA</code> ,
the latter only in a case of rehandshake.
</p>
<p>The former two interrupt the handshake procedure due to the lower
layer being interrupted, and the latter because of an alert that
may be sent by a server (it is always a good idea to check any
received alerts). On these errors call this function again, until it
returns 0; cf.  <code>gnutls_record_get_direction()</code>  and
<code>gnutls_error_is_fatal()</code> . In DTLS sessions the non-fatal error
<code>GNUTLS_E_LARGE_PACKET</code>  is also possible, and indicates that
the MTU should be adjusted.
</p>
<p>If this function is called by a server after a rehandshake request
then <code>GNUTLS_E_GOT_APPLICATION_DATA</code>  or
<code>GNUTLS_E_WARNING_ALERT_RECEIVED</code>  may be returned.  Note that these
are non fatal errors, only in the specific case of a rehandshake.
Their meaning is that the client rejected the rehandshake request or
in the case of <code>GNUTLS_E_GOT_APPLICATION_DATA</code>  it could also mean that
some data were pending. A client may receive that error code if
it initiates the handshake and the server doesn&rsquo;t agreed.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p></dd></dl>

<a name="gnutls_005fhandshake_005fdescription_005fget_005fname-1"></a>
<h4 class="subheading">gnutls_handshake_description_get_name</h4>
<a name="gnutls_005fhandshake_005fdescription_005fget_005fname"></a><dl>
<dt><a name="index-gnutls_005fhandshake_005fdescription_005fget_005fname"></a>Function: <em>const char     *</em> <strong>gnutls_handshake_description_get_name</strong> <em>(gnutls_handshake_description_t         <var>type</var>)</em></dt>
<dd><p><var>type</var>: is a handshake message description
</p>
<p>Convert a <code>gnutls_handshake_description_t</code>  value to a string.
</p>
<p><strong>Returns:</strong> a string that contains the name of the specified handshake
message or <code>NULL</code> .
</p></dd></dl>

<a name="gnutls_005fhandshake_005fget_005flast_005fin-1"></a>
<h4 class="subheading">gnutls_handshake_get_last_in</h4>
<a name="gnutls_005fhandshake_005fget_005flast_005fin"></a><dl>
<dt><a name="index-gnutls_005fhandshake_005fget_005flast_005fin"></a>Function: <em>gnutls_handshake_description_t</em> <strong>gnutls_handshake_get_last_in</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function is only useful to check where the last performed
handshake failed.  If the previous handshake succeed or was not
performed at all then no meaningful value will be returned.
</p>
<p>Check <code>gnutls_handshake_description_t</code>  in gnutls.h for the
available handshake descriptions.
</p>
<p><strong>Returns:</strong> the last handshake message type received, a
<code>gnutls_handshake_description_t</code> .
</p></dd></dl>

<a name="gnutls_005fhandshake_005fget_005flast_005fout-1"></a>
<h4 class="subheading">gnutls_handshake_get_last_out</h4>
<a name="gnutls_005fhandshake_005fget_005flast_005fout"></a><dl>
<dt><a name="index-gnutls_005fhandshake_005fget_005flast_005fout"></a>Function: <em>gnutls_handshake_description_t</em> <strong>gnutls_handshake_get_last_out</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function is only useful to check where the last performed
handshake failed.  If the previous handshake succeed or was not
performed at all then no meaningful value will be returned.
</p>
<p>Check <code>gnutls_handshake_description_t</code>  in gnutls.h for the
available handshake descriptions.
</p>
<p><strong>Returns:</strong> the last handshake message type sent, a
<code>gnutls_handshake_description_t</code> .
</p></dd></dl>

<a name="gnutls_005fhandshake_005fset_005fhook_005ffunction-1"></a>
<h4 class="subheading">gnutls_handshake_set_hook_function</h4>
<a name="gnutls_005fhandshake_005fset_005fhook_005ffunction"></a><dl>
<dt><a name="index-gnutls_005fhandshake_005fset_005fhook_005ffunction"></a>Function: <em>void</em> <strong>gnutls_handshake_set_hook_function</strong> <em>(gnutls_session_t <var>session</var>, unsigned int <var>htype</var>, int <var>post</var>, gnutls_handshake_hook_func <var>func</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type
</p>
<p><var>htype</var>: the <code>gnutls_handshake_description_t</code>  of the message to hook at
</p>
<p><var>post</var>: <code>GNUTLS_HOOK_</code> * depending on when the hook function should be called
</p>
<p><var>func</var>: is the function to be called
</p>
<p>This function will set a callback to be called after or before the specified
handshake message has been received or generated. This is a
generalization of <code>gnutls_handshake_set_post_client_hello_function()</code> .
</p>
<p>To call the hook function prior to the message being sent/generated use
<code>GNUTLS_HOOK_PRE</code>  as  <code>post</code> parameter, <code>GNUTLS_HOOK_POST</code>  to call
after, and <code>GNUTLS_HOOK_BOTH</code>  for both cases.
</p>
<p>This callback must return 0 on success or a gnutls error code to
terminate the handshake.
</p>
<p>Note to hook at all handshake messages use an  <code>htype</code> of <code>GNUTLS_HANDSHAKE_ANY</code> .
</p>
<p><strong>Warning:</strong> You should not use this function to terminate the
handshake based on client input unless you know what you are
doing. Before the handshake is finished there is no way to know if
there is a man-in-the-middle attack being performed.
</p></dd></dl>

<a name="gnutls_005fhandshake_005fset_005fmax_005fpacket_005flength-1"></a>
<h4 class="subheading">gnutls_handshake_set_max_packet_length</h4>
<a name="gnutls_005fhandshake_005fset_005fmax_005fpacket_005flength"></a><dl>
<dt><a name="index-gnutls_005fhandshake_005fset_005fmax_005fpacket_005flength"></a>Function: <em>void</em> <strong>gnutls_handshake_set_max_packet_length</strong> <em>(gnutls_session_t <var>session</var>, size_t <var>max</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>max</var>: is the maximum number.
</p>
<p>This function will set the maximum size of all handshake messages.
Handshakes over this size are rejected with
<code>GNUTLS_E_HANDSHAKE_TOO_LARGE</code>  error code.  The default value is
48kb which is typically large enough.  Set this to 0 if you do not
want to set an upper limit.
</p>
<p>The reason for restricting the handshake message sizes are to
limit Denial of Service attacks.
</p></dd></dl>

<a name="gnutls_005fhandshake_005fset_005fpost_005fclient_005fhello_005ffunction-1"></a>
<h4 class="subheading">gnutls_handshake_set_post_client_hello_function</h4>
<a name="gnutls_005fhandshake_005fset_005fpost_005fclient_005fhello_005ffunction"></a><dl>
<dt><a name="index-gnutls_005fhandshake_005fset_005fpost_005fclient_005fhello_005ffunction"></a>Function: <em>void</em> <strong>gnutls_handshake_set_post_client_hello_function</strong> <em>(gnutls_session_t <var>session</var>, gnutls_handshake_simple_hook_func <var>func</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>func</var>: is the function to be called
</p>
<p>This function will set a callback to be called after the client
hello has been received (callback valid in server side only). This
allows the server to adjust settings based on received extensions.
</p>
<p>Those settings could be ciphersuites, requesting certificate, or
anything else except for version negotiation (this is done before
the hello message is parsed).
</p>
<p>This callback must return 0 on success or a gnutls error code to
terminate the handshake.
</p>
<p>Since GnuTLS 3.3.5 the callback is
allowed to return <code>GNUTLS_E_AGAIN</code>  or <code>GNUTLS_E_INTERRUPTED</code>  to
put the handshake on hold. In that case <code>gnutls_handshake()</code> 
will return <code>GNUTLS_E_INTERRUPTED</code>  and can be resumed when needed.
</p>
<p><strong>Warning:</strong> You should not use this function to terminate the
handshake based on client input unless you know what you are
doing. Before the handshake is finished there is no way to know if
there is a man-in-the-middle attack being performed.
</p></dd></dl>

<a name="gnutls_005fhandshake_005fset_005fprivate_005fextensions-1"></a>
<h4 class="subheading">gnutls_handshake_set_private_extensions</h4>
<a name="gnutls_005fhandshake_005fset_005fprivate_005fextensions"></a><dl>
<dt><a name="index-gnutls_005fhandshake_005fset_005fprivate_005fextensions"></a>Function: <em>void</em> <strong>gnutls_handshake_set_private_extensions</strong> <em>(gnutls_session_t <var>session</var>, int <var>allow</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>allow</var>: is an integer (0 or 1)
</p>
<p>This function will enable or disable the use of private cipher
suites (the ones that start with 0xFF).  By default or if  <code>allow</code> is 0 then these cipher suites will not be advertised nor used.
</p>
<p>Currently GnuTLS does not include such cipher-suites or
compression algorithms.
</p>
<p>Enabling the private ciphersuites when talking to other than
gnutls servers and clients may cause interoperability problems.
</p></dd></dl>

<a name="gnutls_005fhandshake_005fset_005frandom-1"></a>
<h4 class="subheading">gnutls_handshake_set_random</h4>
<a name="gnutls_005fhandshake_005fset_005frandom"></a><dl>
<dt><a name="index-gnutls_005fhandshake_005fset_005frandom"></a>Function: <em>int</em> <strong>gnutls_handshake_set_random</strong> <em>(gnutls_session_t <var>session</var>, const gnutls_datum_t * <var>random</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>random</var>: a random value of 32-bytes
</p>
<p>This function will explicitly set the server or client hello 
random value in the subsequent TLS handshake. The random value 
should be a 32-byte value.
</p>
<p>Note that this function should not normally be used as gnutls
will select automatically a random value for the handshake.
</p>
<p>This function should not be used when resuming a session.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, or an error code.
</p>
<p>Since 3.1.9
</p></dd></dl>

<a name="gnutls_005fhandshake_005fset_005ftimeout-1"></a>
<h4 class="subheading">gnutls_handshake_set_timeout</h4>
<a name="gnutls_005fhandshake_005fset_005ftimeout"></a><dl>
<dt><a name="index-gnutls_005fhandshake_005fset_005ftimeout-1"></a>Function: <em>void</em> <strong>gnutls_handshake_set_timeout</strong> <em>(gnutls_session_t <var>session</var>, unsigned int <var>ms</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>ms</var>: is a timeout value in milliseconds
</p>
<p>This function sets the timeout for the TLS handshake process
to the provided value. Use an  <code>ms</code> value of zero to disable
timeout, or <code>GNUTLS_DEFAULT_HANDSHAKE_TIMEOUT</code>  for a reasonable
default value. For the DTLS protocol, the more detailed
<code>gnutls_dtls_set_timeouts()</code>  is provided.
</p>
<p>This function requires to set a pull timeout callback. See
<code>gnutls_transport_set_pull_timeout_function()</code> .
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>

<a name="gnutls_005fheartbeat_005fallowed-1"></a>
<h4 class="subheading">gnutls_heartbeat_allowed</h4>
<a name="gnutls_005fheartbeat_005fallowed"></a><dl>
<dt><a name="index-gnutls_005fheartbeat_005fallowed"></a>Function: <em>int</em> <strong>gnutls_heartbeat_allowed</strong> <em>(gnutls_session_t <var>session</var>, unsigned int <var>type</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>type</var>: one of <code>GNUTLS_HB_LOCAL_ALLOWED_TO_SEND</code>  and <code>GNUTLS_HB_PEER_ALLOWED_TO_SEND</code> 
</p>
<p>This function will check whether heartbeats are allowed
to be sent or received in this session. 
</p>
<p><strong>Returns:</strong> Non zero if heartbeats are allowed.
</p>
<p><strong>Since:</strong> 3.1.2
</p></dd></dl>

<a name="gnutls_005fheartbeat_005fenable-1"></a>
<h4 class="subheading">gnutls_heartbeat_enable</h4>
<a name="gnutls_005fheartbeat_005fenable"></a><dl>
<dt><a name="index-gnutls_005fheartbeat_005fenable"></a>Function: <em>void</em> <strong>gnutls_heartbeat_enable</strong> <em>(gnutls_session_t <var>session</var>, unsigned int <var>type</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>type</var>: one of the GNUTLS_HB_* flags
</p>
<p>If this function is called with the <code>GNUTLS_HB_PEER_ALLOWED_TO_SEND</code> 
 <code>type</code> , GnuTLS will allow heartbeat messages to be received. Moreover it also
request the peer to accept heartbeat messages.
</p>
<p>If the  <code>type</code> used is <code>GNUTLS_HB_LOCAL_ALLOWED_TO_SEND</code> , then the peer
will be asked to accept heartbeat messages but not send ones.
</p>
<p>The function <code>gnutls_heartbeat_allowed()</code>  can be used to test Whether
locally generated heartbeat messages can be accepted by the peer.
</p>
<p><strong>Since:</strong> 3.1.2
</p></dd></dl>

<a name="gnutls_005fheartbeat_005fget_005ftimeout-1"></a>
<h4 class="subheading">gnutls_heartbeat_get_timeout</h4>
<a name="gnutls_005fheartbeat_005fget_005ftimeout"></a><dl>
<dt><a name="index-gnutls_005fheartbeat_005fget_005ftimeout"></a>Function: <em>unsigned int</em> <strong>gnutls_heartbeat_get_timeout</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function will return the milliseconds remaining
for a retransmission of the previously sent ping
message. This function is useful when ping is used in
non-blocking mode, to estimate when to call <code>gnutls_heartbeat_ping()</code> 
if no packets have been received.
</p>
<p><strong>Returns:</strong> the remaining time in milliseconds.
</p>
<p><strong>Since:</strong> 3.1.2
</p></dd></dl>

<a name="gnutls_005fheartbeat_005fping-1"></a>
<h4 class="subheading">gnutls_heartbeat_ping</h4>
<a name="gnutls_005fheartbeat_005fping"></a><dl>
<dt><a name="index-gnutls_005fheartbeat_005fping"></a>Function: <em>int</em> <strong>gnutls_heartbeat_ping</strong> <em>(gnutls_session_t <var>session</var>, size_t <var>data_size</var>, unsigned int <var>max_tries</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>data_size</var>: is the length of the ping payload.
</p>
<p><var>max_tries</var>: if flags is <code>GNUTLS_HEARTBEAT_WAIT</code>  then this sets the number of retransmissions. Use zero for indefinite (until timeout).
</p>
<p><var>flags</var>: if <code>GNUTLS_HEARTBEAT_WAIT</code>  then wait for pong or timeout instead of returning immediately.
</p>
<p>This function sends a ping to the peer. If the  <code>flags</code> is set
to <code>GNUTLS_HEARTBEAT_WAIT</code>  then it waits for a reply from the peer.
</p>
<p>Note that it is highly recommended to use this function with the
flag <code>GNUTLS_HEARTBEAT_WAIT</code> , or you need to handle retransmissions
and timeouts manually.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.1.2
</p></dd></dl>

<a name="gnutls_005fheartbeat_005fpong-1"></a>
<h4 class="subheading">gnutls_heartbeat_pong</h4>
<a name="gnutls_005fheartbeat_005fpong"></a><dl>
<dt><a name="index-gnutls_005fheartbeat_005fpong"></a>Function: <em>int</em> <strong>gnutls_heartbeat_pong</strong> <em>(gnutls_session_t <var>session</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function replies to a ping by sending a pong to the peer.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.1.2
</p></dd></dl>

<a name="gnutls_005fheartbeat_005fset_005ftimeouts-1"></a>
<h4 class="subheading">gnutls_heartbeat_set_timeouts</h4>
<a name="gnutls_005fheartbeat_005fset_005ftimeouts"></a><dl>
<dt><a name="index-gnutls_005fheartbeat_005fset_005ftimeouts"></a>Function: <em>void</em> <strong>gnutls_heartbeat_set_timeouts</strong> <em>(gnutls_session_t <var>session</var>, unsigned int <var>retrans_timeout</var>, unsigned int <var>total_timeout</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>retrans_timeout</var>: The time at which a retransmission will occur in milliseconds
</p>
<p><var>total_timeout</var>: The time at which the connection will be aborted, in milliseconds.
</p>
<p>This function will override the timeouts for the DTLS heartbeat
protocol. The retransmission timeout is the time after which a
message from the peer is not received, the previous request will
be retransmitted. The total timeout is the time after which the
handshake will be aborted with <code>GNUTLS_E_TIMEDOUT</code> .
</p>
<p><strong>Since:</strong> 3.1.2
</p></dd></dl>

<a name="gnutls_005fhex2bin-1"></a>
<h4 class="subheading">gnutls_hex2bin</h4>
<a name="gnutls_005fhex2bin"></a><dl>
<dt><a name="index-gnutls_005fhex2bin"></a>Function: <em>int</em> <strong>gnutls_hex2bin</strong> <em>(const char * <var>hex_data</var>, size_t <var>hex_size</var>, void * <var>bin_data</var>, size_t * <var>bin_size</var>)</em></dt>
<dd><p><var>hex_data</var>: string with data in hex format
</p>
<p><var>hex_size</var>: size of hex data
</p>
<p><var>bin_data</var>: output array with binary data
</p>
<p><var>bin_size</var>: when calling should hold maximum size of  <code>bin_data</code> ,
on return will hold actual length of  <code>bin_data</code> .
</p>
<p>Convert a buffer with hex data to binary data. This function
unlike <code>gnutls_hex_decode()</code>  can parse hex data with separators
between numbers. That is, it ignores any non-hex characters.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 2.4.0
</p></dd></dl>

<a name="gnutls_005fhex_005fdecode-1"></a>
<h4 class="subheading">gnutls_hex_decode</h4>
<a name="gnutls_005fhex_005fdecode"></a><dl>
<dt><a name="index-gnutls_005fhex_005fdecode"></a>Function: <em>int</em> <strong>gnutls_hex_decode</strong> <em>(const gnutls_datum_t * <var>hex_data</var>, void * <var>result</var>, size_t * <var>result_size</var>)</em></dt>
<dd><p><var>hex_data</var>: contain the encoded data
</p>
<p><var>result</var>: the place where decoded data will be copied
</p>
<p><var>result_size</var>: holds the size of the result
</p>
<p>This function will decode the given encoded data, using the hex
encoding used by PSK password files.
</p>
<p>Initially  <code>result_size</code> must hold the maximum size available in
 <code>result</code> , and on return it will contain the number of bytes written.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the buffer given is not
long enough, <code>GNUTLS_E_PARSING_ERROR</code>  on invalid hex data, or 0 on success.
</p></dd></dl>

<a name="gnutls_005fhex_005fdecode2-1"></a>
<h4 class="subheading">gnutls_hex_decode2</h4>
<a name="gnutls_005fhex_005fdecode2"></a><dl>
<dt><a name="index-gnutls_005fhex_005fdecode2"></a>Function: <em>int</em> <strong>gnutls_hex_decode2</strong> <em>(const gnutls_datum_t * <var>hex_data</var>, gnutls_datum_t * <var>result</var>)</em></dt>
<dd><p><var>hex_data</var>: contain the encoded data
</p>
<p><var>result</var>: the result in an allocated string
</p>
<p>This function will decode the given encoded data, using the hex
encoding used by PSK password files.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_PARSING_ERROR</code>  on invalid hex data, or 0 on success.
</p></dd></dl>

<a name="gnutls_005fhex_005fencode-1"></a>
<h4 class="subheading">gnutls_hex_encode</h4>
<a name="gnutls_005fhex_005fencode"></a><dl>
<dt><a name="index-gnutls_005fhex_005fencode"></a>Function: <em>int</em> <strong>gnutls_hex_encode</strong> <em>(const gnutls_datum_t * <var>data</var>, char * <var>result</var>, size_t * <var>result_size</var>)</em></dt>
<dd><p><var>data</var>: contain the raw data
</p>
<p><var>result</var>: the place where hex data will be copied
</p>
<p><var>result_size</var>: holds the size of the result
</p>
<p>This function will convert the given data to printable data, using
the hex encoding, as used in the PSK password files.
</p>
<p>Note that the size of the result includes the null terminator.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the buffer given is not
long enough, or 0 on success.
</p></dd></dl>

<a name="gnutls_005fhex_005fencode2-1"></a>
<h4 class="subheading">gnutls_hex_encode2</h4>
<a name="gnutls_005fhex_005fencode2"></a><dl>
<dt><a name="index-gnutls_005fhex_005fencode2"></a>Function: <em>int</em> <strong>gnutls_hex_encode2</strong> <em>(const gnutls_datum_t * <var>data</var>, gnutls_datum_t * <var>result</var>)</em></dt>
<dd><p><var>data</var>: contain the raw data
</p>
<p><var>result</var>: the result in an allocated string
</p>
<p>This function will convert the given data to printable data, using
the hex encoding, as used in the PSK password files.
</p>
<p>Note that the size of the result does NOT include the null terminator.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p></dd></dl>

<a name="gnutls_005finit-1"></a>
<h4 class="subheading">gnutls_init</h4>
<a name="gnutls_005finit"></a><dl>
<dt><a name="index-gnutls_005finit-1"></a>Function: <em>int</em> <strong>gnutls_init</strong> <em>(gnutls_session_t * <var>session</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>session</var>: is a pointer to a <code>gnutls_session_t</code>  type.
</p>
<p><var>flags</var>: indicate if this session is to be used for server or client.
</p>
<p>This function initializes the provided session. Every
session must be initialized before use, and must be deinitialized
after used by calling <code>gnutls_deinit()</code> .
</p>
<p><code>flags</code> can be any combination of flags from <code>gnutls_init_flags_t</code> .
</p>
<p>Note that since version 3.1.2 this function enables some common
TLS extensions such as session tickets and OCSP certificate status
request in client side by default. To prevent that use the <code>GNUTLS_NO_EXTENSIONS</code> 
flag.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, or an error code.
</p></dd></dl>

<a name="gnutls_005fkey_005fgenerate-1"></a>
<h4 class="subheading">gnutls_key_generate</h4>
<a name="gnutls_005fkey_005fgenerate"></a><dl>
<dt><a name="index-gnutls_005fkey_005fgenerate"></a>Function: <em>int</em> <strong>gnutls_key_generate</strong> <em>(gnutls_datum_t * <var>key</var>, unsigned int <var>key_size</var>)</em></dt>
<dd><p><var>key</var>: is a pointer to a <code>gnutls_datum_t</code>  which will contain a newly
created key
</p>
<p><var>key_size</var>: the number of bytes of the key
</p>
<p>Generates a random key of  <code>key_size</code> bytes.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, or an
error code.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<a name="gnutls_005fkx_005fget-1"></a>
<h4 class="subheading">gnutls_kx_get</h4>
<a name="gnutls_005fkx_005fget"></a><dl>
<dt><a name="index-gnutls_005fkx_005fget"></a>Function: <em>gnutls_kx_algorithm_t</em> <strong>gnutls_kx_get</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Get currently used key exchange algorithm.
</p>
<p><strong>Returns:</strong> the key exchange algorithm used in the last handshake, a
<code>gnutls_kx_algorithm_t</code>  value.
</p></dd></dl>

<a name="gnutls_005fkx_005fget_005fid-1"></a>
<h4 class="subheading">gnutls_kx_get_id</h4>
<a name="gnutls_005fkx_005fget_005fid"></a><dl>
<dt><a name="index-gnutls_005fkx_005fget_005fid"></a>Function: <em>gnutls_kx_algorithm_t</em> <strong>gnutls_kx_get_id</strong> <em>(const char * <var>name</var>)</em></dt>
<dd><p><var>name</var>: is a KX name
</p>
<p>Convert a string to a <code>gnutls_kx_algorithm_t</code>  value.  The names are
compared in a case insensitive way.
</p>
<p><strong>Returns:</strong> an id of the specified KX algorithm, or <code>GNUTLS_KX_UNKNOWN</code> 
on error.
</p></dd></dl>

<a name="gnutls_005fkx_005fget_005fname-1"></a>
<h4 class="subheading">gnutls_kx_get_name</h4>
<a name="gnutls_005fkx_005fget_005fname"></a><dl>
<dt><a name="index-gnutls_005fkx_005fget_005fname"></a>Function: <em>const char *</em> <strong>gnutls_kx_get_name</strong> <em>(gnutls_kx_algorithm_t <var>algorithm</var>)</em></dt>
<dd><p><var>algorithm</var>: is a key exchange algorithm
</p>
<p>Convert a <code>gnutls_kx_algorithm_t</code>  value to a string.
</p>
<p><strong>Returns:</strong> a pointer to a string that contains the name of the
specified key exchange algorithm, or <code>NULL</code> .
</p></dd></dl>

<a name="gnutls_005fkx_005flist-1"></a>
<h4 class="subheading">gnutls_kx_list</h4>
<a name="gnutls_005fkx_005flist"></a><dl>
<dt><a name="index-gnutls_005fkx_005flist"></a>Function: <em>const gnutls_kx_algorithm_t *</em> <strong>gnutls_kx_list</strong> <em>( <var>void</var>)</em></dt>
<dd>
<p>Get a list of supported key exchange algorithms.
</p>
<p>This function is not thread safe.
</p>
<p><strong>Returns:</strong> a (0)-terminated list of <code>gnutls_kx_algorithm_t</code>  integers
indicating the available key exchange algorithms.
</p></dd></dl>

<a name="gnutls_005fload_005ffile-1"></a>
<h4 class="subheading">gnutls_load_file</h4>
<a name="gnutls_005fload_005ffile"></a><dl>
<dt><a name="index-gnutls_005fload_005ffile"></a>Function: <em>int</em> <strong>gnutls_load_file</strong> <em>(const char * <var>filename</var>, gnutls_datum_t * <var>data</var>)</em></dt>
<dd><p><var>filename</var>: the name of the file to load
</p>
<p><var>data</var>: Where the file will be stored
</p>
<p>This function will load a file into a datum. The data are
zero terminated but the terminating null is not included in length.
The returned data are allocated using <code>gnutls_malloc()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p>
<p>Since 3.1.0
</p></dd></dl>

<a name="gnutls_005fmac_005fget-1"></a>
<h4 class="subheading">gnutls_mac_get</h4>
<a name="gnutls_005fmac_005fget"></a><dl>
<dt><a name="index-gnutls_005fmac_005fget"></a>Function: <em>gnutls_mac_algorithm_t</em> <strong>gnutls_mac_get</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Get currently used MAC algorithm.
</p>
<p><strong>Returns:</strong> the currently used mac algorithm, a
<code>gnutls_mac_algorithm_t</code>  value.
</p></dd></dl>

<a name="gnutls_005fmac_005fget_005fid-1"></a>
<h4 class="subheading">gnutls_mac_get_id</h4>
<a name="gnutls_005fmac_005fget_005fid"></a><dl>
<dt><a name="index-gnutls_005fmac_005fget_005fid"></a>Function: <em>gnutls_mac_algorithm_t</em> <strong>gnutls_mac_get_id</strong> <em>(const char * <var>name</var>)</em></dt>
<dd><p><var>name</var>: is a MAC algorithm name
</p>
<p>Convert a string to a <code>gnutls_mac_algorithm_t</code>  value.  The names are
compared in a case insensitive way.
</p>
<p><strong>Returns:</strong> a <code>gnutls_mac_algorithm_t</code>  id of the specified MAC
algorithm string, or <code>GNUTLS_MAC_UNKNOWN</code>  on failure.
</p></dd></dl>

<a name="gnutls_005fmac_005fget_005fkey_005fsize-1"></a>
<h4 class="subheading">gnutls_mac_get_key_size</h4>
<a name="gnutls_005fmac_005fget_005fkey_005fsize"></a><dl>
<dt><a name="index-gnutls_005fmac_005fget_005fkey_005fsize"></a>Function: <em>size_t</em> <strong>gnutls_mac_get_key_size</strong> <em>(gnutls_mac_algorithm_t <var>algorithm</var>)</em></dt>
<dd><p><var>algorithm</var>: is an encryption algorithm
</p>
<p>Returns the size of the MAC key used in TLS. 
</p>
<p><strong>Returns:</strong> length (in bytes) of the given MAC key size, or 0 if the
given MAC algorithm is invalid.
</p></dd></dl>

<a name="gnutls_005fmac_005fget_005fname-1"></a>
<h4 class="subheading">gnutls_mac_get_name</h4>
<a name="gnutls_005fmac_005fget_005fname"></a><dl>
<dt><a name="index-gnutls_005fmac_005fget_005fname"></a>Function: <em>const char *</em> <strong>gnutls_mac_get_name</strong> <em>(gnutls_mac_algorithm_t <var>algorithm</var>)</em></dt>
<dd><p><var>algorithm</var>: is a MAC algorithm
</p>
<p>Convert a <code>gnutls_mac_algorithm_t</code>  value to a string.
</p>
<p><strong>Returns:</strong> a string that contains the name of the specified MAC
algorithm, or <code>NULL</code> .
</p></dd></dl>

<a name="gnutls_005fmac_005flist-1"></a>
<h4 class="subheading">gnutls_mac_list</h4>
<a name="gnutls_005fmac_005flist"></a><dl>
<dt><a name="index-gnutls_005fmac_005flist"></a>Function: <em>const gnutls_mac_algorithm_t *</em> <strong>gnutls_mac_list</strong> <em>( <var>void</var>)</em></dt>
<dd>
<p>Get a list of hash algorithms for use as MACs.  Note that not
necessarily all MACs are supported in TLS cipher suites.  
This function is not thread safe.
</p>
<p><strong>Returns:</strong> Return a (0)-terminated list of <code>gnutls_mac_algorithm_t</code> 
integers indicating the available MACs.
</p></dd></dl>

<a name="gnutls_005fmemcmp-1"></a>
<h4 class="subheading">gnutls_memcmp</h4>
<a name="gnutls_005fmemcmp"></a><dl>
<dt><a name="index-gnutls_005fmemcmp"></a>Function: <em>int</em> <strong>gnutls_memcmp</strong> <em>(const void * <var>s1</var>, const void * <var>s2</var>, size_t <var>n</var>)</em></dt>
<dd><p><var>s1</var>: the first address to compare
</p>
<p><var>s2</var>: the second address to compare
</p>
<p><var>n</var>: the size of memory to compare
</p>
<p>This function will operate similarly to <code>memcmp()</code> , but will operate
on time that depends only on the size of the string. That is will
not return early if the strings don&rsquo;t match on the first byte.
</p>
<p><strong>Returns:</strong> non zero on difference and zero if the buffers are identical.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<a name="gnutls_005fmemset-1"></a>
<h4 class="subheading">gnutls_memset</h4>
<a name="gnutls_005fmemset"></a><dl>
<dt><a name="index-gnutls_005fmemset"></a>Function: <em>void</em> <strong>gnutls_memset</strong> <em>(void * <var>data</var>, int <var>c</var>, size_t <var>size</var>)</em></dt>
<dd><p><var>data</var>: the memory to set
</p>
<p><var>c</var>: the constant byte to fill the memory with
</p>
<p><var>size</var>: the size of memory
</p>
<p>This function will operate similarly to <code>memset()</code> , but will
not be optimized out by the compiler.
</p>
<p><strong>Returns:</strong> void.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<a name="gnutls_005focsp_005fstatus_005frequest_005fenable_005fclient-1"></a>
<h4 class="subheading">gnutls_ocsp_status_request_enable_client</h4>
<a name="gnutls_005focsp_005fstatus_005frequest_005fenable_005fclient"></a><dl>
<dt><a name="index-gnutls_005focsp_005fstatus_005frequest_005fenable_005fclient"></a>Function: <em>int</em> <strong>gnutls_ocsp_status_request_enable_client</strong> <em>(gnutls_session_t <var>session</var>, gnutls_datum_t * <var>responder_id</var>, size_t <var>responder_id_size</var>, gnutls_datum_t * <var>extensions</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>responder_id</var>: array with <code>gnutls_datum_t</code>  with DER data of responder id
</p>
<p><var>responder_id_size</var>: number of members in  <code>responder_id</code> array
</p>
<p><var>extensions</var>: a <code>gnutls_datum_t</code>  with DER encoded OCSP extensions
</p>
<p>This function is to be used by clients to request OCSP response
from the server, using the &quot;status_request&quot; TLS extension.  Only
OCSP status type is supported. A typical server has a single
OCSP response cached, so  <code>responder_id</code> and  <code>extensions</code> should be null.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p>
<p><strong>Since:</strong> 3.1.3
</p></dd></dl>

<a name="gnutls_005focsp_005fstatus_005frequest_005fget-1"></a>
<h4 class="subheading">gnutls_ocsp_status_request_get</h4>
<a name="gnutls_005focsp_005fstatus_005frequest_005fget"></a><dl>
<dt><a name="index-gnutls_005focsp_005fstatus_005frequest_005fget"></a>Function: <em>int</em> <strong>gnutls_ocsp_status_request_get</strong> <em>(gnutls_session_t <var>session</var>, gnutls_datum_t * <var>response</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>response</var>: a <code>gnutls_datum_t</code>  with DER encoded OCSP response
</p>
<p>This function returns the OCSP status response received
from the TLS server. The  <code>response</code> should be treated as
constant. If no OCSP response is available then
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  is returned.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p>
<p><strong>Since:</strong> 3.1.3
</p></dd></dl>

<a name="gnutls_005focsp_005fstatus_005frequest_005fis_005fchecked-1"></a>
<h4 class="subheading">gnutls_ocsp_status_request_is_checked</h4>
<a name="gnutls_005focsp_005fstatus_005frequest_005fis_005fchecked"></a><dl>
<dt><a name="index-gnutls_005focsp_005fstatus_005frequest_005fis_005fchecked"></a>Function: <em>int</em> <strong>gnutls_ocsp_status_request_is_checked</strong> <em>(gnutls_session_t <var>session</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p><var>flags</var>: should be zero or <code>GNUTLS_OCSP_SR_IS_AVAIL</code> 
</p>
<p>When flags are zero this function returns non-zero if a valid OCSP status
response was included in the TLS handshake. That is, an OCSP status response
which is not too old or superseded. It returns zero otherwise.
</p>
<p>When the flag <code>GNUTLS_OCSP_SR_IS_AVAIL</code>  is specified, the function
returns non-zero if an OCSP status response was included in the handshake
even if it was invalid. Otherwise, if no OCSP status response was included,
it returns zero. The <code>GNUTLS_OCSP_SR_IS_AVAIL</code>  flag was introduced in GnuTLS 3.4.0.
</p>
<p>This is a helper function when needing to decide whether to perform an
explicit OCSP validity check on the peer&rsquo;s certificate. Should be called after
any of gnutls_certificate_verify_peers*() are called.
</p>
<p><strong>Returns:</strong> non zero if the response was valid, or a zero if it wasn&rsquo;t sent,
or sent and was invalid.
</p>
<p><strong>Since:</strong> 3.1.4
</p></dd></dl>

<a name="gnutls_005foid_005fto_005fdigest-1"></a>
<h4 class="subheading">gnutls_oid_to_digest</h4>
<a name="gnutls_005foid_005fto_005fdigest"></a><dl>
<dt><a name="index-gnutls_005foid_005fto_005fdigest"></a>Function: <em>gnutls_digest_algorithm_t</em> <strong>gnutls_oid_to_digest</strong> <em>(const char * <var>oid</var>)</em></dt>
<dd><p><var>oid</var>: is an object identifier
</p>
<p>Converts a textual object identifier to a <code>gnutls_digest_algorithm_t</code>  value.
</p>
<p><strong>Returns:</strong> a <code>gnutls_digest_algorithm_t</code>  id of the specified digest
algorithm, or <code>GNUTLS_DIG_UNKNOWN</code>  on failure.
</p>
<p><strong>Since:</strong> 3.4.3
</p></dd></dl>

<a name="gnutls_005foid_005fto_005fecc_005fcurve-1"></a>
<h4 class="subheading">gnutls_oid_to_ecc_curve</h4>
<a name="gnutls_005foid_005fto_005fecc_005fcurve"></a><dl>
<dt><a name="index-gnutls_005foid_005fto_005fecc_005fcurve"></a>Function: <em>gnutls_ecc_curve_t</em> <strong>gnutls_oid_to_ecc_curve</strong> <em>(const char * <var>oid</var>)</em></dt>
<dd><p><var>oid</var>: is a curve&rsquo;s OID
</p>

<p><strong>Returns:</strong> return a <code>gnutls_ecc_curve_t</code>  value corresponding to
the specified OID, or <code>GNUTLS_ECC_CURVE_INVALID</code>  on error.
</p>
<p><strong>Since:</strong> 3.4.3
</p></dd></dl>

<a name="gnutls_005foid_005fto_005fpk-1"></a>
<h4 class="subheading">gnutls_oid_to_pk</h4>
<a name="gnutls_005foid_005fto_005fpk"></a><dl>
<dt><a name="index-gnutls_005foid_005fto_005fpk"></a>Function: <em>gnutls_pk_algorithm_t</em> <strong>gnutls_oid_to_pk</strong> <em>(const char * <var>oid</var>)</em></dt>
<dd><p><var>oid</var>: is an object identifier
</p>
<p>Converts a textual object identifier to a <code>gnutls_pk_algorithm_t</code>  value.
</p>
<p><strong>Returns:</strong> a <code>gnutls_pk_algorithm_t</code>  id of the specified digest
algorithm, or <code>GNUTLS_PK_UNKNOWN</code>  on failure.
</p>
<p><strong>Since:</strong> 3.4.3
</p></dd></dl>

<a name="gnutls_005foid_005fto_005fsign-1"></a>
<h4 class="subheading">gnutls_oid_to_sign</h4>
<a name="gnutls_005foid_005fto_005fsign"></a><dl>
<dt><a name="index-gnutls_005foid_005fto_005fsign"></a>Function: <em>gnutls_sign_algorithm_t</em> <strong>gnutls_oid_to_sign</strong> <em>(const char * <var>oid</var>)</em></dt>
<dd><p><var>oid</var>: is an object identifier
</p>
<p>Converts a textual object identifier to a <code>gnutls_sign_algorithm_t</code>  value.
</p>
<p><strong>Returns:</strong> a <code>gnutls_sign_algorithm_t</code>  id of the specified digest
algorithm, or <code>GNUTLS_SIGN_UNKNOWN</code>  on failure.
</p>
<p><strong>Since:</strong> 3.4.3
</p></dd></dl>

<a name="gnutls_005fopenpgp_005fsend_005fcert-1"></a>
<h4 class="subheading">gnutls_openpgp_send_cert</h4>
<a name="gnutls_005fopenpgp_005fsend_005fcert"></a><dl>
<dt><a name="index-gnutls_005fopenpgp_005fsend_005fcert"></a>Function: <em>void</em> <strong>gnutls_openpgp_send_cert</strong> <em>(gnutls_session_t <var>session</var>, gnutls_openpgp_crt_status_t <var>status</var>)</em></dt>
<dd><p><var>session</var>: a <code>gnutls_session_t</code>  type.
</p>
<p><var>status</var>: is one of GNUTLS_OPENPGP_CERT, or GNUTLS_OPENPGP_CERT_FINGERPRINT
</p>
<p>This function will order gnutls to send the key fingerprint
instead of the key in the initial handshake procedure. This should
be used with care and only when there is indication or knowledge
that the server can obtain the client&rsquo;s key.
</p></dd></dl>

<a name="gnutls_005fpacket_005fdeinit-1"></a>
<h4 class="subheading">gnutls_packet_deinit</h4>
<a name="gnutls_005fpacket_005fdeinit"></a><dl>
<dt><a name="index-gnutls_005fpacket_005fdeinit"></a>Function: <em>void</em> <strong>gnutls_packet_deinit</strong> <em>(gnutls_packet_t <var>packet</var>)</em></dt>
<dd><p><var>packet</var>: is a pointer to a <code>gnutls_packet_st</code>  structure.
</p>
<p>This function will deinitialize all data associated with
the received packet.
</p>
<p><strong>Since:</strong> 3.3.5
</p></dd></dl>

<a name="gnutls_005fpacket_005fget-1"></a>
<h4 class="subheading">gnutls_packet_get</h4>
<a name="gnutls_005fpacket_005fget"></a><dl>
<dt><a name="index-gnutls_005fpacket_005fget"></a>Function: <em>void</em> <strong>gnutls_packet_get</strong> <em>(gnutls_packet_t <var>packet</var>, gnutls_datum_t * <var>data</var>, unsigned char * <var>sequence</var>)</em></dt>
<dd><p><var>packet</var>: is a <code>gnutls_packet_t</code>  type.
</p>
<p><var>data</var>: will contain the data present in the  <code>packet</code> structure (may be <code>NULL</code> )
</p>
<p><var>sequence</var>: the 8-bytes of the packet sequence number (may be <code>NULL</code> )
</p>
<p>This function returns the data and sequence number associated with
the received packet.
</p>
<p><strong>Since:</strong> 3.3.5
</p></dd></dl>

<a name="gnutls_005fpem_005fbase64_005fdecode-1"></a>
<h4 class="subheading">gnutls_pem_base64_decode</h4>
<a name="gnutls_005fpem_005fbase64_005fdecode"></a><dl>
<dt><a name="index-gnutls_005fpem_005fbase64_005fdecode"></a>Function: <em>int</em> <strong>gnutls_pem_base64_decode</strong> <em>(const char * <var>header</var>, const gnutls_datum_t * <var>b64_data</var>, unsigned char * <var>result</var>, size_t * <var>result_size</var>)</em></dt>
<dd><p><var>header</var>: A null terminated string with the PEM header (eg. CERTIFICATE)
</p>
<p><var>b64_data</var>: contain the encoded data
</p>
<p><var>result</var>: the place where decoded data will be copied
</p>
<p><var>result_size</var>: holds the size of the result
</p>
<p>This function will decode the given encoded data.  If the header
given is non null this function will search for &quot;&mdash;&ndash;BEGIN header&quot;
and decode only this part.  Otherwise it will decode the first PEM
packet found.
</p>
<p><strong>Returns:</strong> On success <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  is returned if the buffer given is
not long enough, or 0 on success.
</p></dd></dl>

<a name="gnutls_005fpem_005fbase64_005fdecode2-1"></a>
<h4 class="subheading">gnutls_pem_base64_decode2</h4>
<a name="gnutls_005fpem_005fbase64_005fdecode2"></a><dl>
<dt><a name="index-gnutls_005fpem_005fbase64_005fdecode2"></a>Function: <em>int</em> <strong>gnutls_pem_base64_decode2</strong> <em>(const char * <var>header</var>, const gnutls_datum_t * <var>b64_data</var>, gnutls_datum_t * <var>result</var>)</em></dt>
<dd><p><var>header</var>: The PEM header (eg. CERTIFICATE)
</p>
<p><var>b64_data</var>: contains the encoded data
</p>
<p><var>result</var>: the place where decoded data lie
</p>
<p>This function will decode the given encoded data. The decoded data
will be allocated, and stored into result.  If the header given is
non null this function will search for &quot;&mdash;&ndash;BEGIN header&quot; and
decode only this part. Otherwise it will decode the first PEM
packet found.
</p>
<p>You should use <code>gnutls_free()</code>  to free the returned data.
</p>
<p>Note, that prior to GnuTLS 3.4.0 this function was available
under the name <code>gnutls_pem_base64_decode_alloc()</code> . There is
compatibility macro pointing to this function.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<a name="gnutls_005fpem_005fbase64_005fencode-1"></a>
<h4 class="subheading">gnutls_pem_base64_encode</h4>
<a name="gnutls_005fpem_005fbase64_005fencode"></a><dl>
<dt><a name="index-gnutls_005fpem_005fbase64_005fencode"></a>Function: <em>int</em> <strong>gnutls_pem_base64_encode</strong> <em>(const char * <var>msg</var>, const gnutls_datum_t * <var>data</var>, char * <var>result</var>, size_t * <var>result_size</var>)</em></dt>
<dd><p><var>msg</var>: is a message to be put in the header
</p>
<p><var>data</var>: contain the raw data
</p>
<p><var>result</var>: the place where base64 data will be copied
</p>
<p><var>result_size</var>: holds the size of the result
</p>
<p>This function will convert the given data to printable data, using
the base64 encoding. This is the encoding used in PEM messages.
</p>
<p>The output string will be null terminated, although the size will
not include the terminating null.
</p>
<p><strong>Returns:</strong> On success <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  is returned if the buffer given is
not long enough, or 0 on success.
</p></dd></dl>

<a name="gnutls_005fpem_005fbase64_005fencode2-1"></a>
<h4 class="subheading">gnutls_pem_base64_encode2</h4>
<a name="gnutls_005fpem_005fbase64_005fencode2"></a><dl>
<dt><a name="index-gnutls_005fpem_005fbase64_005fencode2"></a>Function: <em>int</em> <strong>gnutls_pem_base64_encode2</strong> <em>(const char * <var>msg</var>, const gnutls_datum_t * <var>data</var>, gnutls_datum_t * <var>result</var>)</em></dt>
<dd><p><var>msg</var>: is a message to be put in the encoded header
</p>
<p><var>data</var>: contains the raw data
</p>
<p><var>result</var>: will hold the newly allocated encoded data
</p>
<p>This function will convert the given data to printable data, using
the base64 encoding.  This is the encoding used in PEM messages.
This function will allocate the required memory to hold the encoded
data.
</p>
<p>You should use <code>gnutls_free()</code>  to free the returned data.
</p>
<p>Note, that prior to GnuTLS 3.4.0 this function was available
under the name <code>gnutls_pem_base64_encode_alloc()</code> . There is
compatibility macro pointing to this function.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<a name="gnutls_005fperror-1"></a>
<h4 class="subheading">gnutls_perror</h4>
<a name="gnutls_005fperror"></a><dl>
<dt><a name="index-gnutls_005fperror"></a>Function: <em>void</em> <strong>gnutls_perror</strong> <em>(int <var>error</var>)</em></dt>
<dd><p><var>error</var>: is a GnuTLS error code, a negative error code
</p>
<p>This function is like <code>perror()</code> . The only difference is that it
accepts an error number returned by a gnutls function.
</p></dd></dl>

<a name="gnutls_005fpk_005falgorithm_005fget_005fname-1"></a>
<h4 class="subheading">gnutls_pk_algorithm_get_name</h4>
<a name="gnutls_005fpk_005falgorithm_005fget_005fname"></a><dl>
<dt><a name="index-gnutls_005fpk_005falgorithm_005fget_005fname"></a>Function: <em>const char *</em> <strong>gnutls_pk_algorithm_get_name</strong> <em>(gnutls_pk_algorithm_t <var>algorithm</var>)</em></dt>
<dd><p><var>algorithm</var>: is a pk algorithm
</p>
<p>Convert a <code>gnutls_pk_algorithm_t</code>  value to a string.
</p>
<p><strong>Returns:</strong> a string that contains the name of the specified public
key algorithm, or <code>NULL</code> .
</p></dd></dl>

<a name="gnutls_005fpk_005fbits_005fto_005fsec_005fparam-1"></a>
<h4 class="subheading">gnutls_pk_bits_to_sec_param</h4>
<a name="gnutls_005fpk_005fbits_005fto_005fsec_005fparam"></a><dl>
<dt><a name="index-gnutls_005fpk_005fbits_005fto_005fsec_005fparam-1"></a>Function: <em>gnutls_sec_param_t</em> <strong>gnutls_pk_bits_to_sec_param</strong> <em>(gnutls_pk_algorithm_t <var>algo</var>, unsigned int <var>bits</var>)</em></dt>
<dd><p><var>algo</var>: is a public key algorithm
</p>
<p><var>bits</var>: is the number of bits
</p>
<p>This is the inverse of <code>gnutls_sec_param_to_pk_bits()</code> . Given an algorithm
and the number of bits, it will return the security parameter. This is
a rough indication.
</p>
<p><strong>Returns:</strong> The security parameter.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<a name="gnutls_005fpk_005fget_005fid-1"></a>
<h4 class="subheading">gnutls_pk_get_id</h4>
<a name="gnutls_005fpk_005fget_005fid"></a><dl>
<dt><a name="index-gnutls_005fpk_005fget_005fid"></a>Function: <em>gnutls_pk_algorithm_t</em> <strong>gnutls_pk_get_id</strong> <em>(const char * <var>name</var>)</em></dt>
<dd><p><var>name</var>: is a string containing a public key algorithm name.
</p>
<p>Convert a string to a <code>gnutls_pk_algorithm_t</code>  value.  The names are
compared in a case insensitive way.  For example,
gnutls_pk_get_id(&quot;RSA&quot;) will return <code>GNUTLS_PK_RSA</code> .
</p>
<p><strong>Returns:</strong> a <code>gnutls_pk_algorithm_t</code>  id of the specified public key
algorithm string, or <code>GNUTLS_PK_UNKNOWN</code>  on failures.
</p>
<p><strong>Since:</strong> 2.6.0
</p></dd></dl>

<a name="gnutls_005fpk_005fget_005fname-1"></a>
<h4 class="subheading">gnutls_pk_get_name</h4>
<a name="gnutls_005fpk_005fget_005fname"></a><dl>
<dt><a name="index-gnutls_005fpk_005fget_005fname"></a>Function: <em>const char *</em> <strong>gnutls_pk_get_name</strong> <em>(gnutls_pk_algorithm_t <var>algorithm</var>)</em></dt>
<dd><p><var>algorithm</var>: is a public key algorithm
</p>
<p>Convert a <code>gnutls_pk_algorithm_t</code>  value to a string.
</p>
<p><strong>Returns:</strong> a pointer to a string that contains the name of the
specified public key algorithm, or <code>NULL</code> .
</p>
<p><strong>Since:</strong> 2.6.0
</p></dd></dl>

<a name="gnutls_005fpk_005fget_005foid-1"></a>
<h4 class="subheading">gnutls_pk_get_oid</h4>
<a name="gnutls_005fpk_005fget_005foid"></a><dl>
<dt><a name="index-gnutls_005fpk_005fget_005foid"></a>Function: <em>const char *</em> <strong>gnutls_pk_get_oid</strong> <em>(gnutls_pk_algorithm_t <var>algorithm</var>)</em></dt>
<dd><p><var>algorithm</var>: is a public key algorithm
</p>
<p>Convert a <code>gnutls_pk_algorithm_t</code>  value to its object identifier string.
</p>
<p><strong>Returns:</strong> a pointer to a string that contains the object identifier of the
specified public key algorithm, or <code>NULL</code> .
</p>
<p><strong>Since:</strong> 3.4.3
</p></dd></dl>

<a name="gnutls_005fpk_005flist-1"></a>
<h4 class="subheading">gnutls_pk_list</h4>
<a name="gnutls_005fpk_005flist"></a><dl>
<dt><a name="index-gnutls_005fpk_005flist"></a>Function: <em>const gnutls_pk_algorithm_t *</em> <strong>gnutls_pk_list</strong> <em>( <var>void</var>)</em></dt>
<dd>
<p>Get a list of supported public key algorithms.
</p>
<p>This function is not thread safe.
</p>
<p><strong>Returns:</strong> a (0)-terminated list of <code>gnutls_pk_algorithm_t</code>  integers
indicating the available ciphers.
</p>
<p><strong>Since:</strong> 2.6.0
</p></dd></dl>

<a name="gnutls_005fpk_005fto_005fsign-1"></a>
<h4 class="subheading">gnutls_pk_to_sign</h4>
<a name="gnutls_005fpk_005fto_005fsign"></a><dl>
<dt><a name="index-gnutls_005fpk_005fto_005fsign"></a>Function: <em>gnutls_sign_algorithm_t</em> <strong>gnutls_pk_to_sign</strong> <em>(gnutls_pk_algorithm_t <var>pk</var>, gnutls_digest_algorithm_t <var>hash</var>)</em></dt>
<dd><p><var>pk</var>: is a public key algorithm
</p>
<p><var>hash</var>: a hash algorithm
</p>
<p>This function maps public key and hash algorithms combinations
to signature algorithms.
</p>
<p><strong>Returns:</strong> return a <code>gnutls_sign_algorithm_t</code>  value, or <code>GNUTLS_SIGN_UNKNOWN</code>  on error.
</p></dd></dl>

<a name="gnutls_005fprf-1"></a>
<h4 class="subheading">gnutls_prf</h4>
<a name="gnutls_005fprf"></a><dl>
<dt><a name="index-gnutls_005fprf"></a>Function: <em>int</em> <strong>gnutls_prf</strong> <em>(gnutls_session_t <var>session</var>, size_t <var>label_size</var>, const char * <var>label</var>, int <var>server_random_first</var>, size_t <var>extra_size</var>, const char * <var>extra</var>, size_t <var>outsize</var>, char * <var>out</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>label_size</var>: length of the  <code>label</code> variable.
</p>
<p><var>label</var>: label used in PRF computation, typically a short string.
</p>
<p><var>server_random_first</var>: non-zero if server random field should be first in seed
</p>
<p><var>extra_size</var>: length of the  <code>extra</code> variable.
</p>
<p><var>extra</var>: optional extra data to seed the PRF with.
</p>
<p><var>outsize</var>: size of pre-allocated output buffer to hold the output.
</p>
<p><var>out</var>: pre-allocated buffer to hold the generated data.
</p>
<p>Applies the TLS Pseudo-Random-Function (PRF) on the master secret
and the provided data, seeded with the client and server random fields.
For the key expansion specified in RFC5705 see <code>gnutls_prf_rfc5705()</code> .
</p>
<p>The  <code>label</code> variable usually contains a string denoting the purpose
for the generated data.  The  <code>server_random_first</code> indicates whether
the client random field or the server random field should be first
in the seed.  Non-zero indicates that the server random field is first,
0 that the client random field is first.
</p>
<p>The  <code>extra</code> variable can be used to add more data to the seed, after
the random variables.  It can be used to make sure the
generated output is strongly connected to some additional data
(e.g., a string used in user authentication).
</p>
<p>The output is placed in  <code>out</code> , which must be pre-allocated.
</p>
<p><strong>Note:</strong> This function produces identical output with <code>gnutls_prf_rfc5705()</code> 
when  <code>server_random_first</code> is set to 0 and  <code>extra</code> is <code>NULL</code> .
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, or an error code.
</p></dd></dl>

<a name="gnutls_005fprf_005fraw-1"></a>
<h4 class="subheading">gnutls_prf_raw</h4>
<a name="gnutls_005fprf_005fraw"></a><dl>
<dt><a name="index-gnutls_005fprf_005fraw"></a>Function: <em>int</em> <strong>gnutls_prf_raw</strong> <em>(gnutls_session_t <var>session</var>, size_t <var>label_size</var>, const char * <var>label</var>, size_t <var>seed_size</var>, const char * <var>seed</var>, size_t <var>outsize</var>, char * <var>out</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>label_size</var>: length of the  <code>label</code> variable.
</p>
<p><var>label</var>: label used in PRF computation, typically a short string.
</p>
<p><var>seed_size</var>: length of the  <code>seed</code> variable.
</p>
<p><var>seed</var>: optional extra data to seed the PRF with.
</p>
<p><var>outsize</var>: size of pre-allocated output buffer to hold the output.
</p>
<p><var>out</var>: pre-allocated buffer to hold the generated data.
</p>
<p>Apply the TLS Pseudo-Random-Function (PRF) on the master secret
and the provided data.
</p>
<p>The  <code>label</code> variable usually contains a string denoting the purpose
for the generated data.  The  <code>seed</code> usually contains data such as the
client and server random, perhaps together with some additional
data that is added to guarantee uniqueness of the output for a
particular purpose.
</p>
<p>Because the output is not guaranteed to be unique for a particular
session unless  <code>seed</code> includes the client random and server random
fields (the PRF would output the same data on another connection
resumed from the first one), it is not recommended to use this
function directly.  The <code>gnutls_prf()</code>  function seeds the PRF with the
client and server random fields directly, and is recommended if you
want to generate pseudo random data unique for each session.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, or an error code.
</p></dd></dl>

<a name="gnutls_005fprf_005frfc5705-1"></a>
<h4 class="subheading">gnutls_prf_rfc5705</h4>
<a name="gnutls_005fprf_005frfc5705"></a><dl>
<dt><a name="index-gnutls_005fprf_005frfc5705"></a>Function: <em>int</em> <strong>gnutls_prf_rfc5705</strong> <em>(gnutls_session_t <var>session</var>, size_t <var>label_size</var>, const char * <var>label</var>, size_t <var>context_size</var>, const char * <var>context</var>, size_t <var>outsize</var>, char * <var>out</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>label_size</var>: length of the  <code>label</code> variable.
</p>
<p><var>label</var>: label used in PRF computation, typically a short string.
</p>
<p><var>context_size</var>: length of the  <code>extra</code> variable.
</p>
<p><var>context</var>: optional extra data to seed the PRF with.
</p>
<p><var>outsize</var>: size of pre-allocated output buffer to hold the output.
</p>
<p><var>out</var>: pre-allocated buffer to hold the generated data.
</p>
<p>Applies the TLS Pseudo-Random-Function (PRF) on the master secret
and the provided data, seeded with the client and server random fields,
as specified in RFC5705.
</p>
<p>The  <code>label</code> variable usually contains a string denoting the purpose
for the generated data.  The  <code>server_random_first</code> indicates whether
the client random field or the server random field should be first
in the seed.  Non-zero indicates that the server random field is first,
0 that the client random field is first.
</p>
<p>The  <code>context</code> variable can be used to add more data to the seed, after
the random variables.  It can be used to make sure the
generated output is strongly connected to some additional data
(e.g., a string used in user authentication). 
</p>
<p>The output is placed in  <code>out</code> , which must be pre-allocated.
</p>
<p>Note that, to provide the RFC5705 context, the  <code>context</code> variable
must be non-null.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, or an error code.
</p>
<p><strong>Since:</strong> 3.4.4
</p></dd></dl>

<a name="gnutls_005fpriority_005fcertificate_005ftype_005flist-1"></a>
<h4 class="subheading">gnutls_priority_certificate_type_list</h4>
<a name="gnutls_005fpriority_005fcertificate_005ftype_005flist"></a><dl>
<dt><a name="index-gnutls_005fpriority_005fcertificate_005ftype_005flist"></a>Function: <em>int</em> <strong>gnutls_priority_certificate_type_list</strong> <em>(gnutls_priority_t <var>pcache</var>, const unsigned int ** <var>list</var>)</em></dt>
<dd><p><var>pcache</var>: is a <code>gnutls_prioritity_t</code>  type.
</p>
<p><var>list</var>: will point to an integer list
</p>
<p>Get a list of available certificate types in the priority
structure. 
</p>
<p><strong>Returns:</strong> the number of certificate types, or an error code.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<a name="gnutls_005fpriority_005fcipher_005flist-1"></a>
<h4 class="subheading">gnutls_priority_cipher_list</h4>
<a name="gnutls_005fpriority_005fcipher_005flist"></a><dl>
<dt><a name="index-gnutls_005fpriority_005fcipher_005flist"></a>Function: <em>int</em> <strong>gnutls_priority_cipher_list</strong> <em>(gnutls_priority_t <var>pcache</var>, const unsigned int ** <var>list</var>)</em></dt>
<dd><p><var>pcache</var>: is a <code>gnutls_prioritity_t</code>  type.
</p>
<p><var>list</var>: will point to an integer list
</p>
<p>Get a list of available ciphers in the priority
structure. 
</p>
<p><strong>Returns:</strong> the number of curves, or an error code.
</p>
<p><strong>Since:</strong> 3.2.3
</p></dd></dl>

<a name="gnutls_005fpriority_005fcompression_005flist-1"></a>
<h4 class="subheading">gnutls_priority_compression_list</h4>
<a name="gnutls_005fpriority_005fcompression_005flist"></a><dl>
<dt><a name="index-gnutls_005fpriority_005fcompression_005flist"></a>Function: <em>int</em> <strong>gnutls_priority_compression_list</strong> <em>(gnutls_priority_t <var>pcache</var>, const unsigned int ** <var>list</var>)</em></dt>
<dd><p><var>pcache</var>: is a <code>gnutls_prioritity_t</code>  type.
</p>
<p><var>list</var>: will point to an integer list
</p>
<p>Get a list of available compression method in the priority
structure. 
</p>
<p><strong>Returns:</strong> the number of methods, or an error code.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<a name="gnutls_005fpriority_005fdeinit-1"></a>
<h4 class="subheading">gnutls_priority_deinit</h4>
<a name="gnutls_005fpriority_005fdeinit"></a><dl>
<dt><a name="index-gnutls_005fpriority_005fdeinit"></a>Function: <em>void</em> <strong>gnutls_priority_deinit</strong> <em>(gnutls_priority_t <var>priority_cache</var>)</em></dt>
<dd><p><var>priority_cache</var>: is a <code>gnutls_prioritity_t</code>  type.
</p>
<p>Deinitializes the priority cache.
</p></dd></dl>

<a name="gnutls_005fpriority_005fecc_005fcurve_005flist-1"></a>
<h4 class="subheading">gnutls_priority_ecc_curve_list</h4>
<a name="gnutls_005fpriority_005fecc_005fcurve_005flist"></a><dl>
<dt><a name="index-gnutls_005fpriority_005fecc_005fcurve_005flist"></a>Function: <em>int</em> <strong>gnutls_priority_ecc_curve_list</strong> <em>(gnutls_priority_t <var>pcache</var>, const unsigned int ** <var>list</var>)</em></dt>
<dd><p><var>pcache</var>: is a <code>gnutls_prioritity_t</code>  type.
</p>
<p><var>list</var>: will point to an integer list
</p>
<p>Get a list of available elliptic curves in the priority
structure. 
</p>
<p><strong>Returns:</strong> the number of curves, or an error code.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<a name="gnutls_005fpriority_005fget_005fcipher_005fsuite_005findex-1"></a>
<h4 class="subheading">gnutls_priority_get_cipher_suite_index</h4>
<a name="gnutls_005fpriority_005fget_005fcipher_005fsuite_005findex"></a><dl>
<dt><a name="index-gnutls_005fpriority_005fget_005fcipher_005fsuite_005findex"></a>Function: <em>int</em> <strong>gnutls_priority_get_cipher_suite_index</strong> <em>(gnutls_priority_t <var>pcache</var>, unsigned int <var>idx</var>, unsigned int * <var>sidx</var>)</em></dt>
<dd><p><var>pcache</var>: is a <code>gnutls_prioritity_t</code>  type.
</p>
<p><var>idx</var>: is an index number.
</p>
<p><var>sidx</var>: internal index of cipher suite to get information about.
</p>
<p>Provides the internal ciphersuite index to be used with
<code>gnutls_cipher_suite_info()</code> . The index  <code>idx</code> provided is an 
index kept at the priorities structure. It might be that a valid
priorities index does not correspond to a ciphersuite and in 
that case <code>GNUTLS_E_UNKNOWN_CIPHER_SUITE</code>  will be returned. 
Once the last available index is crossed then 
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  will be returned.
</p>
<p><strong>Returns:</strong> On success it returns <code>GNUTLS_E_SUCCESS</code>  (0), or a negative error value otherwise.
</p>
<p><strong>Since:</strong> 3.0.9
</p></dd></dl>

<a name="gnutls_005fpriority_005finit-1"></a>
<h4 class="subheading">gnutls_priority_init</h4>
<a name="gnutls_005fpriority_005finit"></a><dl>
<dt><a name="index-gnutls_005fpriority_005finit"></a>Function: <em>int</em> <strong>gnutls_priority_init</strong> <em>(gnutls_priority_t * <var>priority_cache</var>, const char * <var>priorities</var>, const char ** <var>err_pos</var>)</em></dt>
<dd><p><var>priority_cache</var>: is a <code>gnutls_prioritity_t</code>  type.
</p>
<p><var>priorities</var>: is a string describing priorities (may be <code>NULL</code> )
</p>
<p><var>err_pos</var>: In case of an error this will have the position in the string the error occurred
</p>
<p>Sets priorities for the ciphers, key exchange methods, macs and
compression methods. The  <code>priority_cache</code> should be deinitialized
using <code>gnutls_priority_deinit()</code> .
</p>
<p>The <code>priorities</code>  option allows you to specify a colon
separated list of the cipher priorities to enable.
Some keywords are defined to provide quick access
to common preferences.
</p>
<p>Unless there is a special need, use the &quot;NORMAL&quot; keyword to
apply a reasonable security level, or &quot;NORMAL:<code>COMPAT</code> &quot; for compatibility.
</p>
<p>&quot;PERFORMANCE&quot; means all the &quot;secure&quot; ciphersuites are enabled,
limited to 128 bit ciphers and sorted by terms of speed
performance.
</p>
<p>&quot;LEGACY&quot; the NORMAL settings for GnuTLS 3.2.x or earlier. There is
no verification profile set, and the allowed DH primes are considered
weak today.
</p>
<p>&quot;NORMAL&quot; means all &quot;secure&quot; ciphersuites. The 256-bit ciphers are
included as a fallback only.  The ciphers are sorted by security
margin.
</p>
<p>&quot;PFS&quot; means all &quot;secure&quot; ciphersuites that support perfect forward secrecy. 
The 256-bit ciphers are included as a fallback only.  
The ciphers are sorted by security margin.
</p>
<p>&quot;SECURE128&quot; means all &quot;secure&quot; ciphersuites of security level 128-bit
or more.
</p>
<p>&quot;SECURE192&quot; means all &quot;secure&quot; ciphersuites of security level 192-bit
or more.
</p>
<p>&quot;SUITEB128&quot; means all the NSA SuiteB ciphersuites with security level
of 128.
</p>
<p>&quot;SUITEB192&quot; means all the NSA SuiteB ciphersuites with security level
of 192.
</p>
<p>&quot;NONE&quot; means nothing is enabled.  This disables even protocols and
compression methods.
</p>
<p>&quot;&nbsp;<code>KEYWORD1</code> ,KEYWORD2,...&quot; The system administrator imposed settings.
The provided keyword(s) will be expanded from a configuration-time
provided file - default is: /etc/gnutls/default-priorities.
Any attributes that follow it, will be appended to the expanded
string. If multiple keywords are provided, separated by commas,
then the first keyword that exists in the configuration file
will be used. At least one of the keywords must exist, or this
function will return an error. Typical usage would be to specify
an application specified keyword first, followed by &quot;SYSTEM&quot; as
a default fallback. e.g., &quot; <code>LIBVIRT</code> ,SYSTEM:!-VERS-SSL3.0&quot; will
first try to find a config file entry matching &quot;LIBVIRT&quot;, but if
that does not exist will use the entry for &quot;SYSTEM&quot;. If &quot;SYSTEM&quot;
does not exist either, an error will be returned. In all cases,
the SSL3.0 protocol will be disabled. The system priority file
entries should be formatted as &quot;KEYWORD=VALUE&quot;, e.g.,
&quot;SYSTEM=NORMAL:+ARCFOUR-128&quot;.
</p>
<p>Special keywords are &quot;!&quot;, &quot;-&quot; and &quot;+&quot;.
&quot;!&quot; or &quot;-&quot; appended with an algorithm will remove this algorithm.
&quot;+&quot; appended with an algorithm will add this algorithm.
</p>
<p>Check the GnuTLS manual section &quot;Priority strings&quot; for detailed
information.
</p>
<p><strong>Examples:</strong> 
&quot;NONE:+VERS-TLS-ALL:+MAC-ALL:+RSA:+AES-128-CBC:+SIGN-ALL:+COMP-NULL&quot;
</p>
<p>&quot;NORMAL:+ARCFOUR-128&quot; means normal ciphers plus ARCFOUR-128.
</p>
<p>&quot;SECURE128:-VERS-SSL3.0:+COMP-DEFLATE&quot; means that only secure ciphers are
enabled, SSL3.0 is disabled, and libz compression enabled.
</p>
<p>&quot;NONE:+VERS-TLS-ALL:+AES-128-CBC:+RSA:+SHA1:+COMP-NULL:+SIGN-RSA-SHA1&quot;, 
</p>
<p>&quot;NONE:+VERS-TLS-ALL:+AES-128-CBC:+ECDHE-RSA:+SHA1:+COMP-NULL:+SIGN-RSA-SHA1:+CURVE-SECP256R1&quot;, 
</p>
<p>&quot;SECURE256:+SECURE128&quot;,
</p>
<p>Note that &quot;NORMAL:<code>COMPAT</code> &quot; is the most compatible mode.
</p>
<p>A <code>NULL</code>   <code>priorities</code> string indicates the default priorities to be
used (this is available since GnuTLS 3.3.0).
</p>
<p><strong>Returns:</strong> On syntax error <code>GNUTLS_E_INVALID_REQUEST</code>  is returned,
<code>GNUTLS_E_SUCCESS</code>  on success, or an error code.
</p></dd></dl>

<a name="gnutls_005fpriority_005fkx_005flist-1"></a>
<h4 class="subheading">gnutls_priority_kx_list</h4>
<a name="gnutls_005fpriority_005fkx_005flist"></a><dl>
<dt><a name="index-gnutls_005fpriority_005fkx_005flist"></a>Function: <em>int</em> <strong>gnutls_priority_kx_list</strong> <em>(gnutls_priority_t <var>pcache</var>, const unsigned int ** <var>list</var>)</em></dt>
<dd><p><var>pcache</var>: is a <code>gnutls_prioritity_t</code>  type.
</p>
<p><var>list</var>: will point to an integer list
</p>
<p>Get a list of available key exchange methods in the priority
structure. 
</p>
<p><strong>Returns:</strong> the number of curves, or an error code.
</p>
<p><strong>Since:</strong> 3.2.3
</p></dd></dl>

<a name="gnutls_005fpriority_005fmac_005flist-1"></a>
<h4 class="subheading">gnutls_priority_mac_list</h4>
<a name="gnutls_005fpriority_005fmac_005flist"></a><dl>
<dt><a name="index-gnutls_005fpriority_005fmac_005flist"></a>Function: <em>int</em> <strong>gnutls_priority_mac_list</strong> <em>(gnutls_priority_t <var>pcache</var>, const unsigned int ** <var>list</var>)</em></dt>
<dd><p><var>pcache</var>: is a <code>gnutls_prioritity_t</code>  type.
</p>
<p><var>list</var>: will point to an integer list
</p>
<p>Get a list of available MAC algorithms in the priority
structure. 
</p>
<p><strong>Returns:</strong> the number of curves, or an error code.
</p>
<p><strong>Since:</strong> 3.2.3
</p></dd></dl>

<a name="gnutls_005fpriority_005fprotocol_005flist-1"></a>
<h4 class="subheading">gnutls_priority_protocol_list</h4>
<a name="gnutls_005fpriority_005fprotocol_005flist"></a><dl>
<dt><a name="index-gnutls_005fpriority_005fprotocol_005flist"></a>Function: <em>int</em> <strong>gnutls_priority_protocol_list</strong> <em>(gnutls_priority_t <var>pcache</var>, const unsigned int ** <var>list</var>)</em></dt>
<dd><p><var>pcache</var>: is a <code>gnutls_prioritity_t</code>  type.
</p>
<p><var>list</var>: will point to an integer list
</p>
<p>Get a list of available TLS version numbers in the priority
structure. 
</p>
<p><strong>Returns:</strong> the number of protocols, or an error code.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<a name="gnutls_005fpriority_005fset-1"></a>
<h4 class="subheading">gnutls_priority_set</h4>
<a name="gnutls_005fpriority_005fset"></a><dl>
<dt><a name="index-gnutls_005fpriority_005fset"></a>Function: <em>int</em> <strong>gnutls_priority_set</strong> <em>(gnutls_session_t <var>session</var>, gnutls_priority_t <var>priority</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>priority</var>: is a <code>gnutls_priority_t</code>  type.
</p>
<p>Sets the priorities to use on the ciphers, key exchange methods,
macs and compression methods.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, or an error code.
</p></dd></dl>

<a name="gnutls_005fpriority_005fset_005fdirect-1"></a>
<h4 class="subheading">gnutls_priority_set_direct</h4>
<a name="gnutls_005fpriority_005fset_005fdirect"></a><dl>
<dt><a name="index-gnutls_005fpriority_005fset_005fdirect"></a>Function: <em>int</em> <strong>gnutls_priority_set_direct</strong> <em>(gnutls_session_t <var>session</var>, const char * <var>priorities</var>, const char ** <var>err_pos</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>priorities</var>: is a string describing priorities
</p>
<p><var>err_pos</var>: In case of an error this will have the position in the string the error occurred
</p>
<p>Sets the priorities to use on the ciphers, key exchange methods,
macs and compression methods.  This function avoids keeping a
priority cache and is used to directly set string priorities to a
TLS session.  For documentation check the <code>gnutls_priority_init()</code> .
</p>
<p>To simply use a reasonable default, consider using <code>gnutls_set_default_priority()</code> .
</p>
<p><strong>Returns:</strong> On syntax error <code>GNUTLS_E_INVALID_REQUEST</code>  is returned,
<code>GNUTLS_E_SUCCESS</code>  on success, or an error code.
</p></dd></dl>

<a name="gnutls_005fpriority_005fsign_005flist-1"></a>
<h4 class="subheading">gnutls_priority_sign_list</h4>
<a name="gnutls_005fpriority_005fsign_005flist"></a><dl>
<dt><a name="index-gnutls_005fpriority_005fsign_005flist"></a>Function: <em>int</em> <strong>gnutls_priority_sign_list</strong> <em>(gnutls_priority_t <var>pcache</var>, const unsigned int ** <var>list</var>)</em></dt>
<dd><p><var>pcache</var>: is a <code>gnutls_prioritity_t</code>  type.
</p>
<p><var>list</var>: will point to an integer list
</p>
<p>Get a list of available signature algorithms in the priority
structure. 
</p>
<p><strong>Returns:</strong> the number of algorithms, or an error code.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<a name="gnutls_005fpriority_005fstring_005flist-1"></a>
<h4 class="subheading">gnutls_priority_string_list</h4>
<a name="gnutls_005fpriority_005fstring_005flist"></a><dl>
<dt><a name="index-gnutls_005fpriority_005fstring_005flist"></a>Function: <em>const char *</em> <strong>gnutls_priority_string_list</strong> <em>(unsigned <var>iter</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>iter</var>: an integer counter starting from zero
</p>
<p><var>flags</var>: one of <code>GNUTLS_PRIORITY_LIST_INIT_KEYWORDS</code> , <code>GNUTLS_PRIORITY_LIST_SPECIAL</code> 
</p>
<p>Can be used to iterate all available priority strings.
Due to internal implementation details, there are cases where this
function can return the empty string. In that case that string should be ignored.
When no strings are available it returns <code>NULL</code> .
</p>
<p><strong>Returns:</strong> a priority string
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<a name="gnutls_005fprotocol_005fget_005fid-1"></a>
<h4 class="subheading">gnutls_protocol_get_id</h4>
<a name="gnutls_005fprotocol_005fget_005fid"></a><dl>
<dt><a name="index-gnutls_005fprotocol_005fget_005fid"></a>Function: <em>gnutls_protocol_t</em> <strong>gnutls_protocol_get_id</strong> <em>(const char * <var>name</var>)</em></dt>
<dd><p><var>name</var>: is a protocol name
</p>
<p>The names are compared in a case insensitive way.
</p>
<p><strong>Returns:</strong> an id of the specified protocol, or
<code>GNUTLS_VERSION_UNKNOWN</code>  on error.
</p></dd></dl>

<a name="gnutls_005fprotocol_005fget_005fname-1"></a>
<h4 class="subheading">gnutls_protocol_get_name</h4>
<a name="gnutls_005fprotocol_005fget_005fname"></a><dl>
<dt><a name="index-gnutls_005fprotocol_005fget_005fname"></a>Function: <em>const char *</em> <strong>gnutls_protocol_get_name</strong> <em>(gnutls_protocol_t <var>version</var>)</em></dt>
<dd><p><var>version</var>: is a (gnutls) version number
</p>
<p>Convert a <code>gnutls_protocol_t</code>  value to a string.
</p>
<p><strong>Returns:</strong> a string that contains the name of the specified TLS
version (e.g., &quot;TLS1.0&quot;), or <code>NULL</code> .
</p></dd></dl>

<a name="gnutls_005fprotocol_005fget_005fversion-1"></a>
<h4 class="subheading">gnutls_protocol_get_version</h4>
<a name="gnutls_005fprotocol_005fget_005fversion"></a><dl>
<dt><a name="index-gnutls_005fprotocol_005fget_005fversion"></a>Function: <em>gnutls_protocol_t</em> <strong>gnutls_protocol_get_version</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Get TLS version, a <code>gnutls_protocol_t</code>  value.
</p>
<p><strong>Returns:</strong> The version of the currently used protocol.
</p></dd></dl>

<a name="gnutls_005fprotocol_005flist-1"></a>
<h4 class="subheading">gnutls_protocol_list</h4>
<a name="gnutls_005fprotocol_005flist"></a><dl>
<dt><a name="index-gnutls_005fprotocol_005flist"></a>Function: <em>const gnutls_protocol_t *</em> <strong>gnutls_protocol_list</strong> <em>( <var>void</var>)</em></dt>
<dd>
<p>Get a list of supported protocols, e.g. SSL 3.0, TLS 1.0 etc.
</p>
<p>This function is not thread safe.
</p>
<p><strong>Returns:</strong> a (0)-terminated list of <code>gnutls_protocol_t</code>  integers
indicating the available protocols.
</p></dd></dl>

<a name="gnutls_005fpsk_005fallocate_005fclient_005fcredentials-1"></a>
<h4 class="subheading">gnutls_psk_allocate_client_credentials</h4>
<a name="gnutls_005fpsk_005fallocate_005fclient_005fcredentials"></a><dl>
<dt><a name="index-gnutls_005fpsk_005fallocate_005fclient_005fcredentials"></a>Function: <em>int</em> <strong>gnutls_psk_allocate_client_credentials</strong> <em>(gnutls_psk_client_credentials_t *            <var>sc</var>)</em></dt>
<dd><p><var>sc</var>: is a pointer to a <code>gnutls_psk_server_credentials_t</code>  type.
</p>
<p>Allocate a gnutls_psk_client_credentials_t structure.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p></dd></dl>

<a name="gnutls_005fpsk_005fallocate_005fserver_005fcredentials-1"></a>
<h4 class="subheading">gnutls_psk_allocate_server_credentials</h4>
<a name="gnutls_005fpsk_005fallocate_005fserver_005fcredentials"></a><dl>
<dt><a name="index-gnutls_005fpsk_005fallocate_005fserver_005fcredentials"></a>Function: <em>int</em> <strong>gnutls_psk_allocate_server_credentials</strong> <em>(gnutls_psk_server_credentials_t *            <var>sc</var>)</em></dt>
<dd><p><var>sc</var>: is a pointer to a <code>gnutls_psk_server_credentials_t</code>  type.
</p>
<p>Allocate a gnutls_psk_server_credentials_t structure.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p></dd></dl>

<a name="gnutls_005fpsk_005fclient_005fget_005fhint-1"></a>
<h4 class="subheading">gnutls_psk_client_get_hint</h4>
<a name="gnutls_005fpsk_005fclient_005fget_005fhint"></a><dl>
<dt><a name="index-gnutls_005fpsk_005fclient_005fget_005fhint"></a>Function: <em>const char *</em> <strong>gnutls_psk_client_get_hint</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p>The PSK identity hint may give the client help in deciding which
username to use.  This should only be called in case of PSK
authentication and in case of a client.
</p>
<p><strong>Returns:</strong> the identity hint of the peer, or <code>NULL</code>  in case of an error.
</p>
<p><strong>Since:</strong> 2.4.0
</p></dd></dl>

<a name="gnutls_005fpsk_005ffree_005fclient_005fcredentials-1"></a>
<h4 class="subheading">gnutls_psk_free_client_credentials</h4>
<a name="gnutls_005fpsk_005ffree_005fclient_005fcredentials"></a><dl>
<dt><a name="index-gnutls_005fpsk_005ffree_005fclient_005fcredentials"></a>Function: <em>void</em> <strong>gnutls_psk_free_client_credentials</strong> <em>(gnutls_psk_client_credentials_t <var>sc</var>)</em></dt>
<dd><p><var>sc</var>: is a <code>gnutls_psk_client_credentials_t</code>  type.
</p>
<p>Free a gnutls_psk_client_credentials_t structure.
</p></dd></dl>

<a name="gnutls_005fpsk_005ffree_005fserver_005fcredentials-1"></a>
<h4 class="subheading">gnutls_psk_free_server_credentials</h4>
<a name="gnutls_005fpsk_005ffree_005fserver_005fcredentials"></a><dl>
<dt><a name="index-gnutls_005fpsk_005ffree_005fserver_005fcredentials"></a>Function: <em>void</em> <strong>gnutls_psk_free_server_credentials</strong> <em>(gnutls_psk_server_credentials_t <var>sc</var>)</em></dt>
<dd><p><var>sc</var>: is a <code>gnutls_psk_server_credentials_t</code>  type.
</p>
<p>Free a gnutls_psk_server_credentials_t structure.
</p></dd></dl>

<a name="gnutls_005fpsk_005fserver_005fget_005fusername-1"></a>
<h4 class="subheading">gnutls_psk_server_get_username</h4>
<a name="gnutls_005fpsk_005fserver_005fget_005fusername"></a><dl>
<dt><a name="index-gnutls_005fpsk_005fserver_005fget_005fusername"></a>Function: <em>const char *</em> <strong>gnutls_psk_server_get_username</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p>This should only be called in case of PSK authentication and in
case of a server.
</p>
<p><strong>Returns:</strong> the username of the peer, or <code>NULL</code>  in case of an error.
</p></dd></dl>

<a name="gnutls_005fpsk_005fset_005fclient_005fcredentials-1"></a>
<h4 class="subheading">gnutls_psk_set_client_credentials</h4>
<a name="gnutls_005fpsk_005fset_005fclient_005fcredentials"></a><dl>
<dt><a name="index-gnutls_005fpsk_005fset_005fclient_005fcredentials"></a>Function: <em>int</em> <strong>gnutls_psk_set_client_credentials</strong> <em>(gnutls_psk_client_credentials_t <var>res</var>, const char * <var>username</var>, const gnutls_datum_t * <var>key</var>, gnutls_psk_key_flags <var>flags</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_psk_client_credentials_t</code>  type.
</p>
<p><var>username</var>: is the user&rsquo;s zero-terminated userid
</p>
<p><var>key</var>: is the user&rsquo;s key
</p>
<p><var>flags</var>: indicate the format of the key, either
<code>GNUTLS_PSK_KEY_RAW</code>  or <code>GNUTLS_PSK_KEY_HEX</code> .
</p>
<p>This function sets the username and password, in a
gnutls_psk_client_credentials_t type.  Those will be used in
PSK authentication.   <code>username</code> should be an ASCII string or UTF-8
strings prepared using the &quot;SASLprep&quot; profile of &quot;stringprep&quot;.  The
key can be either in raw byte format or in Hex format (without the
0x prefix).
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p></dd></dl>

<a name="gnutls_005fpsk_005fset_005fclient_005fcredentials_005ffunction-1"></a>
<h4 class="subheading">gnutls_psk_set_client_credentials_function</h4>
<a name="gnutls_005fpsk_005fset_005fclient_005fcredentials_005ffunction"></a><dl>
<dt><a name="index-gnutls_005fpsk_005fset_005fclient_005fcredentials_005ffunction-1"></a>Function: <em>void</em> <strong>gnutls_psk_set_client_credentials_function</strong> <em>(gnutls_psk_client_credentials_t         <var>cred</var>, gnutls_psk_client_credentials_function         * <var>func</var>)</em></dt>
<dd><p><var>cred</var>: is a <code>gnutls_psk_server_credentials_t</code>  type.
</p>
<p><var>func</var>: is the callback function
</p>
<p>This function can be used to set a callback to retrieve the username and
password for client PSK authentication.
The callback&rsquo;s function form is:
int (*callback)(gnutls_session_t, char** username,
gnutls_datum_t* key);
</p>
<p>The  <code>username</code> and  <code>key</code> -&gt;data must be allocated using <code>gnutls_malloc()</code> .
 <code>username</code> should be ASCII strings or UTF-8 strings prepared using
the &quot;SASLprep&quot; profile of &quot;stringprep&quot;.
</p>
<p>The callback function will be called once per handshake.
</p>
<p>The callback function should return 0 on success.
-1 indicates an error.
</p></dd></dl>

<a name="gnutls_005fpsk_005fset_005fparams_005ffunction-1"></a>
<h4 class="subheading">gnutls_psk_set_params_function</h4>
<a name="gnutls_005fpsk_005fset_005fparams_005ffunction"></a><dl>
<dt><a name="index-gnutls_005fpsk_005fset_005fparams_005ffunction"></a>Function: <em>void</em> <strong>gnutls_psk_set_params_function</strong> <em>(gnutls_psk_server_credentials_t <var>res</var>, gnutls_params_function * <var>func</var>)</em></dt>
<dd><p><var>res</var>: is a gnutls_psk_server_credentials_t type
</p>
<p><var>func</var>: is the function to be called
</p>
<p>This function will set a callback in order for the server to get
the Diffie-Hellman or RSA parameters for PSK authentication.  The
callback should return <code>GNUTLS_E_SUCCESS</code>  (0) on success.
</p></dd></dl>

<a name="gnutls_005fpsk_005fset_005fserver_005fcredentials_005ffile-1"></a>
<h4 class="subheading">gnutls_psk_set_server_credentials_file</h4>
<a name="gnutls_005fpsk_005fset_005fserver_005fcredentials_005ffile"></a><dl>
<dt><a name="index-gnutls_005fpsk_005fset_005fserver_005fcredentials_005ffile-1"></a>Function: <em>int</em> <strong>gnutls_psk_set_server_credentials_file</strong> <em>(gnutls_psk_server_credentials_t            <var>res</var>, const char * <var>password_file</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_psk_server_credentials_t</code>  type.
</p>
<p><var>password_file</var>: is the PSK password file (passwd.psk)
</p>
<p>This function sets the password file, in a
<code>gnutls_psk_server_credentials_t</code>  type.  This password file
holds usernames and keys and will be used for PSK authentication.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p></dd></dl>

<a name="gnutls_005fpsk_005fset_005fserver_005fcredentials_005ffunction-1"></a>
<h4 class="subheading">gnutls_psk_set_server_credentials_function</h4>
<a name="gnutls_005fpsk_005fset_005fserver_005fcredentials_005ffunction"></a><dl>
<dt><a name="index-gnutls_005fpsk_005fset_005fserver_005fcredentials_005ffunction"></a>Function: <em>void</em> <strong>gnutls_psk_set_server_credentials_function</strong> <em>(gnutls_psk_server_credentials_t         <var>cred</var>, gnutls_psk_server_credentials_function         * <var>func</var>)</em></dt>
<dd><p><var>cred</var>: is a <code>gnutls_psk_server_credentials_t</code>  type.
</p>
<p><var>func</var>: is the callback function
</p>
<p>This function can be used to set a callback to retrieve the user&rsquo;s PSK credentials.
The callback&rsquo;s function form is:
int (*callback)(gnutls_session_t, const char* username,
gnutls_datum_t* key);
</p>
<p><code>username</code> contains the actual username.
The  <code>key</code> must be filled in using the <code>gnutls_malloc()</code> .
</p>
<p>In case the callback returned a negative number then gnutls will
assume that the username does not exist.
</p>
<p>The callback function will only be called once per handshake.  The
callback function should return 0 on success, while -1 indicates
an error.
</p></dd></dl>

<a name="gnutls_005fpsk_005fset_005fserver_005fcredentials_005fhint-1"></a>
<h4 class="subheading">gnutls_psk_set_server_credentials_hint</h4>
<a name="gnutls_005fpsk_005fset_005fserver_005fcredentials_005fhint"></a><dl>
<dt><a name="index-gnutls_005fpsk_005fset_005fserver_005fcredentials_005fhint"></a>Function: <em>int</em> <strong>gnutls_psk_set_server_credentials_hint</strong> <em>(gnutls_psk_server_credentials_t <var>res</var>, const char * <var>hint</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_psk_server_credentials_t</code>  type.
</p>
<p><var>hint</var>: is the PSK identity hint string
</p>
<p>This function sets the identity hint, in a
<code>gnutls_psk_server_credentials_t</code>  type.  This hint is sent to
the client to help it chose a good PSK credential (i.e., username
and password).
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p>
<p><strong>Since:</strong> 2.4.0
</p></dd></dl>

<a name="gnutls_005fpsk_005fset_005fserver_005fdh_005fparams-1"></a>
<h4 class="subheading">gnutls_psk_set_server_dh_params</h4>
<a name="gnutls_005fpsk_005fset_005fserver_005fdh_005fparams"></a><dl>
<dt><a name="index-gnutls_005fpsk_005fset_005fserver_005fdh_005fparams"></a>Function: <em>void</em> <strong>gnutls_psk_set_server_dh_params</strong> <em>(gnutls_psk_server_credentials_t <var>res</var>, gnutls_dh_params_t <var>dh_params</var>)</em></dt>
<dd><p><var>res</var>: is a gnutls_psk_server_credentials_t type
</p>
<p><var>dh_params</var>: is a structure that holds Diffie-Hellman parameters.
</p>
<p>This function will set the Diffie-Hellman parameters for an
anonymous server to use. These parameters will be used in
Diffie-Hellman exchange with PSK cipher suites.
</p></dd></dl>

<a name="gnutls_005fpsk_005fset_005fserver_005fparams_005ffunction-1"></a>
<h4 class="subheading">gnutls_psk_set_server_params_function</h4>
<a name="gnutls_005fpsk_005fset_005fserver_005fparams_005ffunction"></a><dl>
<dt><a name="index-gnutls_005fpsk_005fset_005fserver_005fparams_005ffunction"></a>Function: <em>void</em> <strong>gnutls_psk_set_server_params_function</strong> <em>(gnutls_psk_server_credentials_t <var>res</var>, gnutls_params_function * <var>func</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code>  type
</p>
<p><var>func</var>: is the function to be called
</p>
<p>This function will set a callback in order for the server to get
the Diffie-Hellman parameters for PSK authentication.  The callback
should return <code>GNUTLS_E_SUCCESS</code>  (0) on success.
</p></dd></dl>

<a name="gnutls_005frandom_005fart-1"></a>
<h4 class="subheading">gnutls_random_art</h4>
<a name="gnutls_005frandom_005fart"></a><dl>
<dt><a name="index-gnutls_005frandom_005fart"></a>Function: <em>int</em> <strong>gnutls_random_art</strong> <em>(gnutls_random_art_t <var>type</var>, const char * <var>key_type</var>, unsigned int <var>key_size</var>, void * <var>fpr</var>, size_t <var>fpr_size</var>, gnutls_datum_t * <var>art</var>)</em></dt>
<dd><p><var>type</var>: The type of the random art (for now only <code>GNUTLS_RANDOM_ART_OPENSSH</code>  is supported)
</p>
<p><var>key_type</var>: The type of the key (RSA, DSA etc.)
</p>
<p><var>key_size</var>: The size of the key in bits
</p>
<p><var>fpr</var>: The fingerprint of the key
</p>
<p><var>fpr_size</var>: The size of the fingerprint
</p>
<p><var>art</var>: The returned random art
</p>
<p>This function will convert a given fingerprint to an &quot;artistic&quot;
image. The returned image is allocated using <code>gnutls_malloc()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p></dd></dl>

<a name="gnutls_005frange_005fsplit-1"></a>
<h4 class="subheading">gnutls_range_split</h4>
<a name="gnutls_005frange_005fsplit"></a><dl>
<dt><a name="index-gnutls_005frange_005fsplit"></a>Function: <em>int</em> <strong>gnutls_range_split</strong> <em>(gnutls_session_t <var>session</var>, const gnutls_range_st * <var>orig</var>, gnutls_range_st * <var>next</var>, gnutls_range_st * <var>remainder</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type
</p>
<p><var>orig</var>: is the original range provided by the user
</p>
<p><var>next</var>: is the returned range that can be conveyed in a TLS record
</p>
<p><var>remainder</var>: is the returned remaining range
</p>
<p>This function should be used when it is required to hide the length
of very long data that cannot be directly provided to <code>gnutls_record_send_range()</code> .
In that case this function should be called with the desired length
hiding range in  <code>orig</code> . The returned  <code>next</code> value should then be used in
the next call to <code>gnutls_record_send_range()</code>  with the partial data.
That process should be repeated until  <code>remainder</code> is (0,0).
</p>
<p><strong>Returns:</strong> 0 in case splitting succeeds, non zero in case of error.
Note that  <code>orig</code> is not changed, while the values of  <code>next</code> and  <code>remainder</code> are modified to store the resulting values.
</p></dd></dl>

<a name="gnutls_005frecord_005fcan_005fuse_005flength_005fhiding-1"></a>
<h4 class="subheading">gnutls_record_can_use_length_hiding</h4>
<a name="gnutls_005frecord_005fcan_005fuse_005flength_005fhiding"></a><dl>
<dt><a name="index-gnutls_005frecord_005fcan_005fuse_005flength_005fhiding"></a>Function: <em>int</em> <strong>gnutls_record_can_use_length_hiding</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>If the session supports length-hiding padding, you can
invoke <code>gnutls_range_send_message()</code>  to send a message whose
length is hidden in the given range. If the session does not
support length hiding padding, you can use the standard
<code>gnutls_record_send()</code>  function, or <code>gnutls_range_send_message()</code> 
making sure that the range is the same as the length of the
message you are trying to send.
</p>
<p><strong>Returns:</strong> true (1) if the current session supports length-hiding
padding, false (0) if the current session does not.
</p></dd></dl>

<a name="gnutls_005frecord_005fcheck_005fcorked-1"></a>
<h4 class="subheading">gnutls_record_check_corked</h4>
<a name="gnutls_005frecord_005fcheck_005fcorked"></a><dl>
<dt><a name="index-gnutls_005frecord_005fcheck_005fcorked"></a>Function: <em>size_t</em> <strong>gnutls_record_check_corked</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function checks if there pending corked
data in the gnutls buffers &ndash;see <code>gnutls_record_cork()</code> . 
</p>
<p><strong>Returns:</strong> Returns the size of the corked data or zero.
</p>
<p><strong>Since:</strong> 3.2.8
</p></dd></dl>

<a name="gnutls_005frecord_005fcheck_005fpending-1"></a>
<h4 class="subheading">gnutls_record_check_pending</h4>
<a name="gnutls_005frecord_005fcheck_005fpending"></a><dl>
<dt><a name="index-gnutls_005frecord_005fcheck_005fpending-1"></a>Function: <em>size_t</em> <strong>gnutls_record_check_pending</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function checks if there are unread data
in the gnutls buffers. If the return value is
non-zero the next call to <code>gnutls_record_recv()</code> 
is guaranteed not to block.
</p>
<p><strong>Returns:</strong> Returns the size of the data or zero.
</p></dd></dl>

<a name="gnutls_005frecord_005fcork-1"></a>
<h4 class="subheading">gnutls_record_cork</h4>
<a name="gnutls_005frecord_005fcork"></a><dl>
<dt><a name="index-gnutls_005frecord_005fcork-1"></a>Function: <em>void</em> <strong>gnutls_record_cork</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>If called, <code>gnutls_record_send()</code>  will no longer send any records.
Any sent records will be cached until <code>gnutls_record_uncork()</code>  is called.
</p>
<p>This function is safe to use with DTLS after GnuTLS 3.3.0.
</p>
<p><strong>Since:</strong> 3.1.9
</p></dd></dl>

<a name="gnutls_005frecord_005fdisable_005fpadding-1"></a>
<h4 class="subheading">gnutls_record_disable_padding</h4>
<a name="gnutls_005frecord_005fdisable_005fpadding"></a><dl>
<dt><a name="index-gnutls_005frecord_005fdisable_005fpadding"></a>Function: <em>void</em> <strong>gnutls_record_disable_padding</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Used to disabled padding in TLS 1.0 and above.  Normally you do not
need to use this function, but there are buggy clients that
complain if a server pads the encrypted data.  This of course will
disable protection against statistical attacks on the data.
</p>
<p>This functions is defunt since 3.1.7. Random padding is disabled
by default unless requested using <code>gnutls_range_send_message()</code> .
</p></dd></dl>

<a name="gnutls_005frecord_005fdiscard_005fqueued-1"></a>
<h4 class="subheading">gnutls_record_discard_queued</h4>
<a name="gnutls_005frecord_005fdiscard_005fqueued"></a><dl>
<dt><a name="index-gnutls_005frecord_005fdiscard_005fqueued"></a>Function: <em>size_t</em> <strong>gnutls_record_discard_queued</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function discards all queued to be sent packets in a TLS or DTLS session.
These are the packets queued after an interrupted <code>gnutls_record_send()</code> .
</p>
<p><strong>Returns:</strong> The number of bytes discarded.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<a name="gnutls_005frecord_005fget_005fdirection-1"></a>
<h4 class="subheading">gnutls_record_get_direction</h4>
<a name="gnutls_005frecord_005fget_005fdirection"></a><dl>
<dt><a name="index-gnutls_005frecord_005fget_005fdirection-1"></a>Function: <em>int</em> <strong>gnutls_record_get_direction</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function provides information about the internals of the
record protocol and is only useful if a prior gnutls function call,
e.g.  <code>gnutls_handshake()</code> , was interrupted for some reason. That
is, if a function returned <code>GNUTLS_E_INTERRUPTED</code>  or
<code>GNUTLS_E_AGAIN</code> . In such a case, you might want to call <code>select()</code> 
or <code>poll()</code>  before restoring the interrupted gnutls function.
</p>
<p>This function&rsquo;s output is unreliable if you are using the same
 <code>session</code> in different threads, for sending and receiving.
</p>
<p><strong>Returns:</strong> 0 if interrupted while trying to read data, or 1 while trying to write data.
</p></dd></dl>

<a name="gnutls_005frecord_005fget_005fmax_005fsize-1"></a>
<h4 class="subheading">gnutls_record_get_max_size</h4>
<a name="gnutls_005frecord_005fget_005fmax_005fsize"></a><dl>
<dt><a name="index-gnutls_005frecord_005fget_005fmax_005fsize"></a>Function: <em>size_t</em> <strong>gnutls_record_get_max_size</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Get the record size.  The maximum record size is negotiated by the
client after the first handshake message.
</p>
<p><strong>Returns:</strong> The maximum record packet size in this connection.
</p></dd></dl>

<a name="gnutls_005frecord_005fget_005fstate-1"></a>
<h4 class="subheading">gnutls_record_get_state</h4>
<a name="gnutls_005frecord_005fget_005fstate"></a><dl>
<dt><a name="index-gnutls_005frecord_005fget_005fstate"></a>Function: <em>int</em> <strong>gnutls_record_get_state</strong> <em>(gnutls_session_t <var>session</var>, unsigned <var>read</var>, gnutls_datum_t * <var>mac_key</var>, gnutls_datum_t * <var>IV</var>, gnutls_datum_t * <var>cipher_key</var>, unsigned char <var>seq_number[8]</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type
</p>
<p><var>read</var>: if non-zero the read parameters are returned, otherwise the write
</p>
<p><var>mac_key</var>: the key used for MAC (if a MAC is used)
</p>
<p><var>IV</var>: the initialization vector or nonce used
</p>
<p><var>cipher_key</var>: the cipher key
</p>
<p><var>seq_number[8]</var>: &ndash; undescribed &ndash;
</p>
<p>This function will return the parameters of the current record state.
These are only useful to be provided to an external off-loading device
or subsystem.
</p>
<p>In that case, to sync the state you must call <code>gnutls_record_set_state()</code> .
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, or an error code.
</p>
<p>Since 3.4.0
</p></dd></dl>

<a name="gnutls_005frecord_005foverhead_005fsize-1"></a>
<h4 class="subheading">gnutls_record_overhead_size</h4>
<a name="gnutls_005frecord_005foverhead_005fsize"></a><dl>
<dt><a name="index-gnutls_005frecord_005foverhead_005fsize"></a>Function: <em>size_t</em> <strong>gnutls_record_overhead_size</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is <code>gnutls_session_t</code> 
</p>
<p>This function will return the set size in bytes of the overhead
due to TLS (or DTLS) per record.
</p>
<p><strong>Since:</strong> 3.2.2
</p></dd></dl>

<a name="gnutls_005frecord_005frecv-1"></a>
<h4 class="subheading">gnutls_record_recv</h4>
<a name="gnutls_005frecord_005frecv"></a><dl>
<dt><a name="index-gnutls_005frecord_005frecv-1"></a>Function: <em>ssize_t</em> <strong>gnutls_record_recv</strong> <em>(gnutls_session_t <var>session</var>, void * <var>data</var>, size_t <var>data_size</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>data</var>: the buffer that the data will be read into
</p>
<p><var>data_size</var>: the number of requested bytes
</p>
<p>This function has the similar semantics with <code>recv()</code> .  The only
difference is that it accepts a GnuTLS session, and uses different
error codes.
In the special case that the peer requests a renegotiation, the
caller will receive an error code of <code>GNUTLS_E_REHANDSHAKE</code> .  In case
of a client, this message may be simply ignored, replied with an alert
<code>GNUTLS_A_NO_RENEGOTIATION</code> , or replied with a new handshake,
depending on the client&rsquo;s will. A server receiving this error code
can only initiate a new handshake or terminate the session.
</p>
<p>If <code>EINTR</code>  is returned by the internal push function (the default
is <code>recv()</code> ) then <code>GNUTLS_E_INTERRUPTED</code>  will be returned.  If
<code>GNUTLS_E_INTERRUPTED</code>  or <code>GNUTLS_E_AGAIN</code>  is returned, you must
call this function again to get the data.  See also
<code>gnutls_record_get_direction()</code> .
</p>
<p><strong>Returns:</strong> The number of bytes received and zero on EOF (for stream
connections).  A negative error code is returned in case of an error.  
The number of bytes received might be less than the requested  <code>data_size</code> .
</p></dd></dl>

<a name="gnutls_005frecord_005frecv_005fpacket-1"></a>
<h4 class="subheading">gnutls_record_recv_packet</h4>
<a name="gnutls_005frecord_005frecv_005fpacket"></a><dl>
<dt><a name="index-gnutls_005frecord_005frecv_005fpacket"></a>Function: <em>ssize_t</em> <strong>gnutls_record_recv_packet</strong> <em>(gnutls_session_t <var>session</var>, gnutls_packet_t * <var>packet</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>packet</var>: the structure that will hold the packet data
</p>
<p>This is a lower-level function than <code>gnutls_record_recv()</code>  and allows
to directly receive the whole decrypted packet. That avoids a
memory copy, and is intended to be used by applications seeking high
performance.
</p>
<p>The received packet is accessed using <code>gnutls_packet_get()</code>  and 
must be deinitialized using <code>gnutls_packet_deinit()</code> . The returned
packet will be <code>NULL</code>  if the return value is zero (EOF).
</p>
<p><strong>Returns:</strong> The number of bytes received and zero on EOF (for stream
connections).  A negative error code is returned in case of an error.  
</p>
<p><strong>Since:</strong> 3.3.5
</p></dd></dl>

<a name="gnutls_005frecord_005frecv_005fseq-1"></a>
<h4 class="subheading">gnutls_record_recv_seq</h4>
<a name="gnutls_005frecord_005frecv_005fseq"></a><dl>
<dt><a name="index-gnutls_005frecord_005frecv_005fseq-1"></a>Function: <em>ssize_t</em> <strong>gnutls_record_recv_seq</strong> <em>(gnutls_session_t <var>session</var>, void * <var>data</var>, size_t <var>data_size</var>, unsigned char * <var>seq</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>data</var>: the buffer that the data will be read into
</p>
<p><var>data_size</var>: the number of requested bytes
</p>
<p><var>seq</var>: is the packet&rsquo;s 64-bit sequence number. Should have space for 8 bytes.
</p>
<p>This function is the same as <code>gnutls_record_recv()</code> , except that
it returns in addition to data, the sequence number of the data.
This is useful in DTLS where record packets might be received
out-of-order. The returned 8-byte sequence number is an
integer in big-endian format and should be
treated as a unique message identification. 
</p>
<p><strong>Returns:</strong> The number of bytes received and zero on EOF.  A negative
error code is returned in case of an error.  The number of bytes
received might be less than  <code>data_size</code> .
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<a name="gnutls_005frecord_005fsend-1"></a>
<h4 class="subheading">gnutls_record_send</h4>
<a name="gnutls_005frecord_005fsend"></a><dl>
<dt><a name="index-gnutls_005frecord_005fsend-1"></a>Function: <em>ssize_t</em> <strong>gnutls_record_send</strong> <em>(gnutls_session_t <var>session</var>, const void * <var>data</var>, size_t <var>data_size</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>data</var>: contains the data to send
</p>
<p><var>data_size</var>: is the length of the data
</p>
<p>This function has the similar semantics with <code>send()</code> .  The only
difference is that it accepts a GnuTLS session, and uses different
error codes.
Note that if the send buffer is full, <code>send()</code>  will block this
function.  See the <code>send()</code>  documentation for more information.  
</p>
<p>You can replace the default push function which is <code>send()</code> , by using
<code>gnutls_transport_set_push_function()</code> .
</p>
<p>If the EINTR is returned by the internal push function 
then <code>GNUTLS_E_INTERRUPTED</code>  will be returned. If
<code>GNUTLS_E_INTERRUPTED</code>  or <code>GNUTLS_E_AGAIN</code>  is returned, you must
call this function again, with the exact same parameters; alternatively
you could provide a <code>NULL</code>  pointer for data, and 0 for
size. cf. <code>gnutls_record_get_direction()</code> . 
</p>
<p>Note that in DTLS this function will return the <code>GNUTLS_E_LARGE_PACKET</code> 
error code if the send data exceed the data MTU value - as returned
by <code>gnutls_dtls_get_data_mtu()</code> . The errno value EMSGSIZE
also maps to <code>GNUTLS_E_LARGE_PACKET</code> . 
Note that since 3.2.13 this function can be called under cork in DTLS
mode, and will refuse to send data over the MTU size by returning
<code>GNUTLS_E_LARGE_PACKET</code> .
</p>
<p><strong>Returns:</strong> The number of bytes sent, or a negative error code.  The
number of bytes sent might be less than  <code>data_size</code> .  The maximum
number of bytes this function can send in a single call depends
on the negotiated maximum record size.
</p></dd></dl>

<a name="gnutls_005frecord_005fsend_005frange-1"></a>
<h4 class="subheading">gnutls_record_send_range</h4>
<a name="gnutls_005frecord_005fsend_005frange"></a><dl>
<dt><a name="index-gnutls_005frecord_005fsend_005frange"></a>Function: <em>ssize_t</em> <strong>gnutls_record_send_range</strong> <em>(gnutls_session_t <var>session</var>, const void * <var>data</var>, size_t <var>data_size</var>, const gnutls_range_st * <var>range</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>data</var>: contains the data to send.
</p>
<p><var>data_size</var>: is the length of the data.
</p>
<p><var>range</var>: is the range of lengths in which the real data length must be hidden.
</p>
<p>This function operates like <code>gnutls_record_send()</code>  but, while
<code>gnutls_record_send()</code>  adds minimal padding to each TLS record,
this function uses the TLS extra-padding feature to conceal the real
data size within the range of lengths provided.
Some TLS sessions do not support extra padding (e.g. stream ciphers in standard
TLS or SSL3 sessions). To know whether the current session supports extra
padding, and hence length hiding, use the <code>gnutls_record_can_use_length_hiding()</code> 
function.
</p>
<p><strong>Note:</strong> This function currently is only limited to blocking sockets.
</p>
<p><strong>Returns:</strong> The number of bytes sent (that is data_size in a successful invocation),
or a negative error code.
</p></dd></dl>

<a name="gnutls_005frecord_005fset_005fmax_005fsize-1"></a>
<h4 class="subheading">gnutls_record_set_max_size</h4>
<a name="gnutls_005frecord_005fset_005fmax_005fsize"></a><dl>
<dt><a name="index-gnutls_005frecord_005fset_005fmax_005fsize"></a>Function: <em>ssize_t</em> <strong>gnutls_record_set_max_size</strong> <em>(gnutls_session_t <var>session</var>, size_t <var>size</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>size</var>: is the new size
</p>
<p>This function sets the maximum record packet size in this
connection.  This property can only be set to clients.  The server
may choose not to accept the requested size.
</p>
<p>Acceptable values are 512(=2^9), 1024(=2^10), 2048(=2^11) and
4096(=2^12).  The requested record size does get in effect
immediately only while sending data. The receive part will take
effect after a successful handshake.
</p>
<p>This function uses a TLS extension called &rsquo;max record size&rsquo;.  Not
all TLS implementations use or even understand this extension.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p></dd></dl>

<a name="gnutls_005frecord_005fset_005fstate-1"></a>
<h4 class="subheading">gnutls_record_set_state</h4>
<a name="gnutls_005frecord_005fset_005fstate"></a><dl>
<dt><a name="index-gnutls_005frecord_005fset_005fstate"></a>Function: <em>int</em> <strong>gnutls_record_set_state</strong> <em>(gnutls_session_t <var>session</var>, unsigned <var>read</var>, unsigned char <var>seq_number[8]</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type
</p>
<p><var>read</var>: if non-zero the read parameters are returned, otherwise the write
</p>
<p><var>seq_number[8]</var>: &ndash; undescribed &ndash;
</p>
<p>This function will set the sequence number in the current record state.
This function is useful if sending and receiving are offloaded from
gnutls. That is, if <code>gnutls_record_get_state()</code>  was used.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, or an error code.
</p>
<p>Since 3.4.0
</p></dd></dl>

<a name="gnutls_005frecord_005fset_005ftimeout-1"></a>
<h4 class="subheading">gnutls_record_set_timeout</h4>
<a name="gnutls_005frecord_005fset_005ftimeout"></a><dl>
<dt><a name="index-gnutls_005frecord_005fset_005ftimeout"></a>Function: <em>void</em> <strong>gnutls_record_set_timeout</strong> <em>(gnutls_session_t <var>session</var>, unsigned int <var>ms</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>ms</var>: is a timeout value in milliseconds
</p>
<p>This function sets the receive timeout for the record layer
to the provided value. Use an  <code>ms</code> value of zero to disable
timeout (the default), or <code>GNUTLS_INDEFINITE_TIMEOUT</code> , to
set an indefinite timeout.
</p>
<p>This function requires to set a pull timeout callback. See
<code>gnutls_transport_set_pull_timeout_function()</code> .
</p>
<p><strong>Since:</strong> 3.1.7
</p></dd></dl>

<a name="gnutls_005frecord_005funcork-1"></a>
<h4 class="subheading">gnutls_record_uncork</h4>
<a name="gnutls_005frecord_005funcork"></a><dl>
<dt><a name="index-gnutls_005frecord_005funcork-1"></a>Function: <em>int</em> <strong>gnutls_record_uncork</strong> <em>(gnutls_session_t <var>session</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>flags</var>: Could be zero or <code>GNUTLS_RECORD_WAIT</code> 
</p>
<p>This resets the effect of <code>gnutls_record_cork()</code> , and flushes any pending
data. If the <code>GNUTLS_RECORD_WAIT</code>  flag is specified then this
function will block until the data is sent or a fatal error
occurs (i.e., the function will retry on <code>GNUTLS_E_AGAIN</code>  and
<code>GNUTLS_E_INTERRUPTED</code> ).
</p>
<p>If the flag <code>GNUTLS_RECORD_WAIT</code>  is not specified and the function
is interrupted then the <code>GNUTLS_E_AGAIN</code>  or <code>GNUTLS_E_INTERRUPTED</code> 
errors will be returned. To obtain the data left in the corked
buffer use <code>gnutls_record_check_corked()</code> .
</p>
<p><strong>Returns:</strong> On success the number of transmitted data is returned, or 
otherwise a negative error code. 
</p>
<p><strong>Since:</strong> 3.1.9
</p></dd></dl>

<a name="gnutls_005frehandshake-1"></a>
<h4 class="subheading">gnutls_rehandshake</h4>
<a name="gnutls_005frehandshake"></a><dl>
<dt><a name="index-gnutls_005frehandshake-1"></a>Function: <em>int</em> <strong>gnutls_rehandshake</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function will renegotiate security parameters with the
client.  This should only be called in case of a server.
</p>
<p>This message informs the peer that we want to renegotiate
parameters (perform a handshake).
</p>
<p>If this function succeeds (returns 0), you must call the
<code>gnutls_handshake()</code>  function in order to negotiate the new
parameters.
</p>
<p>Since TLS is full duplex some application data might have been
sent during peer&rsquo;s processing of this message. In that case
one should call <code>gnutls_record_recv()</code>  until GNUTLS_E_REHANDSHAKE
is returned to clear any pending data. Care must be taken, if
rehandshake is mandatory, to terminate if it does not start after
some threshold.
</p>
<p>If the client does not wish to renegotiate parameters he 
should reply with an alert message, thus the return code will be
<code>GNUTLS_E_WARNING_ALERT_RECEIVED</code>  and the alert will be
<code>GNUTLS_A_NO_RENEGOTIATION</code> .  A client may also choose to ignore
this message.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p></dd></dl>

<a name="gnutls_005fsafe_005frenegotiation_005fstatus-1"></a>
<h4 class="subheading">gnutls_safe_renegotiation_status</h4>
<a name="gnutls_005fsafe_005frenegotiation_005fstatus"></a><dl>
<dt><a name="index-gnutls_005fsafe_005frenegotiation_005fstatus-1"></a>Function: <em>int</em> <strong>gnutls_safe_renegotiation_status</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Can be used to check whether safe renegotiation is being used
in the current session.
</p>
<p><strong>Returns:</strong> 0 when safe renegotiation is not used and non (0) when
safe renegotiation is used.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>

<a name="gnutls_005fsec_005fparam_005fget_005fname-1"></a>
<h4 class="subheading">gnutls_sec_param_get_name</h4>
<a name="gnutls_005fsec_005fparam_005fget_005fname"></a><dl>
<dt><a name="index-gnutls_005fsec_005fparam_005fget_005fname"></a>Function: <em>const char *</em> <strong>gnutls_sec_param_get_name</strong> <em>(gnutls_sec_param_t <var>param</var>)</em></dt>
<dd><p><var>param</var>: is a security parameter
</p>
<p>Convert a <code>gnutls_sec_param_t</code>  value to a string.
</p>
<p><strong>Returns:</strong> a pointer to a string that contains the name of the
specified security level, or <code>NULL</code> .
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<a name="gnutls_005fsec_005fparam_005fto_005fpk_005fbits-1"></a>
<h4 class="subheading">gnutls_sec_param_to_pk_bits</h4>
<a name="gnutls_005fsec_005fparam_005fto_005fpk_005fbits"></a><dl>
<dt><a name="index-gnutls_005fsec_005fparam_005fto_005fpk_005fbits-1"></a>Function: <em>unsigned int</em> <strong>gnutls_sec_param_to_pk_bits</strong> <em>(gnutls_pk_algorithm_t <var>algo</var>, gnutls_sec_param_t <var>param</var>)</em></dt>
<dd><p><var>algo</var>: is a public key algorithm
</p>
<p><var>param</var>: is a security parameter
</p>
<p>When generating private and public key pairs a difficult question
is which size of &quot;bits&quot; the modulus will be in RSA and the group size
in DSA. The easy answer is 1024, which is also wrong. This function
will convert a human understandable security parameter to an
appropriate size for the specific algorithm.
</p>
<p><strong>Returns:</strong> The number of bits, or (0).
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<a name="gnutls_005fsec_005fparam_005fto_005fsymmetric_005fbits-1"></a>
<h4 class="subheading">gnutls_sec_param_to_symmetric_bits</h4>
<a name="gnutls_005fsec_005fparam_005fto_005fsymmetric_005fbits"></a><dl>
<dt><a name="index-gnutls_005fsec_005fparam_005fto_005fsymmetric_005fbits"></a>Function: <em>unsigned int</em> <strong>gnutls_sec_param_to_symmetric_bits</strong> <em>(gnutls_sec_param_t <var>param</var>)</em></dt>
<dd><p><var>param</var>: is a security parameter
</p>
<p>This function will return the number of bits that correspond to
symmetric cipher strength for the given security parameter.
</p>
<p><strong>Returns:</strong> The number of bits, or (0).
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fserver_005fname_005fget-1"></a>
<h4 class="subheading">gnutls_server_name_get</h4>
<a name="gnutls_005fserver_005fname_005fget"></a><dl>
<dt><a name="index-gnutls_005fserver_005fname_005fget"></a>Function: <em>int</em> <strong>gnutls_server_name_get</strong> <em>(gnutls_session_t <var>session</var>, void * <var>data</var>, size_t * <var>data_length</var>, unsigned int * <var>type</var>, unsigned int <var>indx</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>data</var>: will hold the data
</p>
<p><var>data_length</var>: will hold the data length. Must hold the maximum size of data.
</p>
<p><var>type</var>: will hold the server name indicator type
</p>
<p><var>indx</var>: is the index of the server_name
</p>
<p>This function will allow you to get the name indication (if any), a
client has sent.  The name indication may be any of the enumeration
gnutls_server_name_type_t.
</p>
<p>If  <code>type</code> is GNUTLS_NAME_DNS, then this function is to be used by
servers that support virtual hosting, and the data will be a null
terminated IDNA ACE string (prior to GnuTLS 3.4.0 it was a UTF-8 string).
</p>
<p>If  <code>data</code> has not enough size to hold the server name
GNUTLS_E_SHORT_MEMORY_BUFFER is returned, and  <code>data_length</code> will
hold the required size.
</p>
<p><code>index</code> is used to retrieve more than one server names (if sent by
the client).  The first server name has an index of 0, the second 1
and so on.  If no name with the given index exists
GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE is returned.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, on UTF-8
decoding error <code>GNUTLS_E_IDNA_ERROR</code>  is returned, otherwise a negative
error code is returned.
</p></dd></dl>

<a name="gnutls_005fserver_005fname_005fset-1"></a>
<h4 class="subheading">gnutls_server_name_set</h4>
<a name="gnutls_005fserver_005fname_005fset"></a><dl>
<dt><a name="index-gnutls_005fserver_005fname_005fset"></a>Function: <em>int</em> <strong>gnutls_server_name_set</strong> <em>(gnutls_session_t <var>session</var>, gnutls_server_name_type_t <var>type</var>, const void * <var>name</var>, size_t <var>name_length</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>type</var>: specifies the indicator type
</p>
<p><var>name</var>: is a string that contains the server name.
</p>
<p><var>name_length</var>: holds the length of name
</p>
<p>This function is to be used by clients that want to inform (via a
TLS extension mechanism) the server of the name they connected to.
This should be used by clients that connect to servers that do
virtual hosting.
</p>
<p>The value of  <code>name</code> depends on the  <code>type</code> type.  In case of
<code>GNUTLS_NAME_DNS</code> , a UTF-8 null-terminated domain name string,
without the trailing dot, is expected.
</p>
<p>IPv4 or IPv6 addresses are not permitted to be set by this function.
If the function is called with a name of  <code>name_length</code> zero it will clear
all server names set.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p></dd></dl>

<a name="gnutls_005fsession_005fchannel_005fbinding-1"></a>
<h4 class="subheading">gnutls_session_channel_binding</h4>
<a name="gnutls_005fsession_005fchannel_005fbinding"></a><dl>
<dt><a name="index-gnutls_005fsession_005fchannel_005fbinding"></a>Function: <em>int</em> <strong>gnutls_session_channel_binding</strong> <em>(gnutls_session_t <var>session</var>, gnutls_channel_binding_t <var>cbtype</var>, gnutls_datum_t * <var>cb</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>cbtype</var>: an <code>gnutls_channel_binding_t</code>  enumeration type
</p>
<p><var>cb</var>: output buffer array with data
</p>
<p>Extract given channel binding data of the  <code>cbtype</code> (e.g.,
<code>GNUTLS_CB_TLS_UNIQUE</code> ) type.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success,
<code>GNUTLS_E_UNIMPLEMENTED_FEATURE</code>  if the  <code>cbtype</code> is unsupported,
<code>GNUTLS_E_CHANNEL_BINDING_NOT_AVAILABLE</code>  if the data is not
currently available, or an error code.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<a name="gnutls_005fsession_005fenable_005fcompatibility_005fmode-1"></a>
<h4 class="subheading">gnutls_session_enable_compatibility_mode</h4>
<a name="gnutls_005fsession_005fenable_005fcompatibility_005fmode"></a><dl>
<dt><a name="index-gnutls_005fsession_005fenable_005fcompatibility_005fmode"></a>Function: <em>void</em> <strong>gnutls_session_enable_compatibility_mode</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function can be used to disable certain (security) features in
TLS in order to maintain maximum compatibility with buggy
clients. Because several trade-offs with security are enabled,
if required they will be reported through the audit subsystem.
</p>
<p>Normally only servers that require maximum compatibility with
everything out there, need to call this function.
</p>
<p>Note that this function must be called after any call to gnutls_priority
functions.
</p></dd></dl>

<a name="gnutls_005fsession_005fetm_005fstatus-1"></a>
<h4 class="subheading">gnutls_session_etm_status</h4>
<a name="gnutls_005fsession_005fetm_005fstatus"></a><dl>
<dt><a name="index-gnutls_005fsession_005fetm_005fstatus"></a>Function: <em>unsigned</em> <strong>gnutls_session_etm_status</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Get the status of the encrypt-then-mac extension negotiation.
This is in accordance to rfc7366
</p>
<p><strong>Returns:</strong> Non-zero if the negotiation was successful or zero otherwise.
</p></dd></dl>

<a name="gnutls_005fsession_005fext_005fmaster_005fsecret_005fstatus-1"></a>
<h4 class="subheading">gnutls_session_ext_master_secret_status</h4>
<a name="gnutls_005fsession_005fext_005fmaster_005fsecret_005fstatus"></a><dl>
<dt><a name="index-gnutls_005fsession_005fext_005fmaster_005fsecret_005fstatus"></a>Function: <em>unsigned</em> <strong>gnutls_session_ext_master_secret_status</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Get the status of the extended master secret extension negotiation.
This is in accordance to draft-ietf-tls-session-hash-01
</p>
<p><strong>Returns:</strong> Non-zero if the negotiation was successful or zero otherwise.
</p></dd></dl>

<a name="gnutls_005fsession_005fforce_005fvalid-1"></a>
<h4 class="subheading">gnutls_session_force_valid</h4>
<a name="gnutls_005fsession_005fforce_005fvalid"></a><dl>
<dt><a name="index-gnutls_005fsession_005fforce_005fvalid"></a>Function: <em>void</em> <strong>gnutls_session_force_valid</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Clears the invalid flag in a session. That means
that sessions were corrupt or invalid data were received 
can be re-used. Use only when debugging or experimenting
with the TLS protocol. Should not be used in typical
applications.
</p></dd></dl>

<a name="gnutls_005fsession_005fget_005fdata-1"></a>
<h4 class="subheading">gnutls_session_get_data</h4>
<a name="gnutls_005fsession_005fget_005fdata"></a><dl>
<dt><a name="index-gnutls_005fsession_005fget_005fdata"></a>Function: <em>int</em> <strong>gnutls_session_get_data</strong> <em>(gnutls_session_t <var>session</var>, void * <var>session_data</var>, size_t * <var>session_data_size</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>session_data</var>: is a pointer to space to hold the session.
</p>
<p><var>session_data_size</var>: is the session_data&rsquo;s size, or it will be set by the function.
</p>
<p>Returns all session parameters needed to be stored to support resumption.
The client should call this, and store the returned session data. A session
may be resumed later by calling <code>gnutls_session_set_data()</code> .  
</p>
<p>This function will fail if called prior to handshake completion. In
case of false start TLS, the handshake completes only after data have
been successfully received from the peer.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p></dd></dl>

<a name="gnutls_005fsession_005fget_005fdata2-1"></a>
<h4 class="subheading">gnutls_session_get_data2</h4>
<a name="gnutls_005fsession_005fget_005fdata2"></a><dl>
<dt><a name="index-gnutls_005fsession_005fget_005fdata2"></a>Function: <em>int</em> <strong>gnutls_session_get_data2</strong> <em>(gnutls_session_t <var>session</var>, gnutls_datum_t * <var>data</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>data</var>: is a pointer to a datum that will hold the session.
</p>
<p>Returns all session parameters needed to be stored to support resumption.
The client should call this, and store the returned session data. A session
may be resumed later by calling <code>gnutls_session_set_data()</code> .  
</p>
<p>The returned  <code>data</code> are allocated and must be released using <code>gnutls_free()</code> .
</p>
<p>This function will fail if called prior to handshake completion. In
case of false start TLS, the handshake completes only after data have
been successfully received from the peer.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p></dd></dl>

<a name="gnutls_005fsession_005fget_005fdesc-1"></a>
<h4 class="subheading">gnutls_session_get_desc</h4>
<a name="gnutls_005fsession_005fget_005fdesc"></a><dl>
<dt><a name="index-gnutls_005fsession_005fget_005fdesc"></a>Function: <em>char *</em> <strong>gnutls_session_get_desc</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p>This function returns a string describing the current session.
The string is null terminated and allocated using <code>gnutls_malloc()</code> .
</p>
<p>If initial negotiation is not complete when this function is called,
<code>NULL</code>  will be returned.
</p>
<p><strong>Returns:</strong> a description of the protocols and algorithms in the current session.
</p>
<p><strong>Since:</strong> 3.1.10
</p></dd></dl>

<a name="gnutls_005fsession_005fget_005fflags-1"></a>
<h4 class="subheading">gnutls_session_get_flags</h4>
<a name="gnutls_005fsession_005fget_005fflags"></a><dl>
<dt><a name="index-gnutls_005fsession_005fget_005fflags"></a>Function: <em>unsigned</em> <strong>gnutls_session_get_flags</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function will return a series (ORed) of flags, applicable
for the current session.
</p>
<p>This replaces individual informational functions such as
<code>gnutls_safe_renegotiation_status()</code> , <code>gnutls_session_ext_master_secret_status()</code> ,
etc.
</p>
<p><strong>Returns:</strong> An ORed sequence of flags (see <code>gnutls_session_flags_t</code> )
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<a name="gnutls_005fsession_005fget_005fid-1"></a>
<h4 class="subheading">gnutls_session_get_id</h4>
<a name="gnutls_005fsession_005fget_005fid"></a><dl>
<dt><a name="index-gnutls_005fsession_005fget_005fid"></a>Function: <em>int</em> <strong>gnutls_session_get_id</strong> <em>(gnutls_session_t <var>session</var>, void * <var>session_id</var>, size_t * <var>session_id_size</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>session_id</var>: is a pointer to space to hold the session id.
</p>
<p><var>session_id_size</var>: initially should contain the maximum  <code>session_id</code> size and will be updated.
</p>
<p>Returns the current session ID. This can be used if you want to
check if the next session you tried to resume was actually
resumed.  That is because resumed sessions share the same session ID
with the original session.
</p>
<p>The session ID is selected by the server, that identify the
current session.  In all supported TLS protocols, the session id
is less than <code>GNUTLS_MAX_SESSION_ID_SIZE</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p></dd></dl>

<a name="gnutls_005fsession_005fget_005fid2-1"></a>
<h4 class="subheading">gnutls_session_get_id2</h4>
<a name="gnutls_005fsession_005fget_005fid2"></a><dl>
<dt><a name="index-gnutls_005fsession_005fget_005fid2"></a>Function: <em>int</em> <strong>gnutls_session_get_id2</strong> <em>(gnutls_session_t <var>session</var>, gnutls_datum_t * <var>session_id</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>session_id</var>: will point to the session ID.
</p>
<p>Returns the current session ID. The returned data should be
treated as constant.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p>
<p><strong>Since:</strong> 3.1.4
</p></dd></dl>

<a name="gnutls_005fsession_005fget_005fmaster_005fsecret-1"></a>
<h4 class="subheading">gnutls_session_get_master_secret</h4>
<a name="gnutls_005fsession_005fget_005fmaster_005fsecret"></a><dl>
<dt><a name="index-gnutls_005fsession_005fget_005fmaster_005fsecret"></a>Function: <em>void</em> <strong>gnutls_session_get_master_secret</strong> <em>(gnutls_session_t <var>session</var>, gnutls_datum_t * <var>secret</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>secret</var>: the session&rsquo;s master secret
</p>
<p>This function returns pointers to the master secret
used in the TLS session. The pointers are not to be modified or deallocated.
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<a name="gnutls_005fsession_005fget_005fptr-1"></a>
<h4 class="subheading">gnutls_session_get_ptr</h4>
<a name="gnutls_005fsession_005fget_005fptr"></a><dl>
<dt><a name="index-gnutls_005fsession_005fget_005fptr"></a>Function: <em>void *</em> <strong>gnutls_session_get_ptr</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Get user pointer for session.  Useful in callbacks.  This is the
pointer set with <code>gnutls_session_set_ptr()</code> .
</p>
<p><strong>Returns:</strong> the user given pointer from the session structure, or
<code>NULL</code>  if it was never set.
</p></dd></dl>

<a name="gnutls_005fsession_005fget_005frandom-1"></a>
<h4 class="subheading">gnutls_session_get_random</h4>
<a name="gnutls_005fsession_005fget_005frandom"></a><dl>
<dt><a name="index-gnutls_005fsession_005fget_005frandom"></a>Function: <em>void</em> <strong>gnutls_session_get_random</strong> <em>(gnutls_session_t <var>session</var>, gnutls_datum_t * <var>client</var>, gnutls_datum_t * <var>server</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>client</var>: the client part of the random
</p>
<p><var>server</var>: the server part of the random
</p>
<p>This function returns pointers to the client and server
random fields used in the TLS handshake. The pointers are
not to be modified or deallocated.
</p>
<p>If a client random value has not yet been established, the output
will be garbage.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<a name="gnutls_005fsession_005fget_005fverify_005fcert_005fstatus-1"></a>
<h4 class="subheading">gnutls_session_get_verify_cert_status</h4>
<a name="gnutls_005fsession_005fget_005fverify_005fcert_005fstatus"></a><dl>
<dt><a name="index-gnutls_005fsession_005fget_005fverify_005fcert_005fstatus"></a>Function: <em>unsigned int</em> <strong>gnutls_session_get_verify_cert_status</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p>This function returns the status of the verification when initiated
via auto-verification, i.e., by <code>gnutls_session_set_verify_cert2()</code>  or
<code>gnutls_session_set_verify_cert()</code> . If no certificate verification
was occurred then the return value would be set to ((unsigned int)-1).
</p>
<p>The certificate verification status is the same as in <code>gnutls_certificate_verify_peers()</code> .
</p>
<p><strong>Returns:</strong> the certificate verification status.
</p>
<p><strong>Since:</strong> 3.4.6
</p></dd></dl>

<a name="gnutls_005fsession_005fis_005fresumed-1"></a>
<h4 class="subheading">gnutls_session_is_resumed</h4>
<a name="gnutls_005fsession_005fis_005fresumed"></a><dl>
<dt><a name="index-gnutls_005fsession_005fis_005fresumed-1"></a>Function: <em>int</em> <strong>gnutls_session_is_resumed</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Check whether session is resumed or not.
</p>
<p><strong>Returns:</strong> non zero if this session is resumed, or a zero if this is
a new session.
</p></dd></dl>

<a name="gnutls_005fsession_005fresumption_005frequested-1"></a>
<h4 class="subheading">gnutls_session_resumption_requested</h4>
<a name="gnutls_005fsession_005fresumption_005frequested"></a><dl>
<dt><a name="index-gnutls_005fsession_005fresumption_005frequested-1"></a>Function: <em>int</em> <strong>gnutls_session_resumption_requested</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Check whether the client has asked for session resumption.
This function is valid only on server side.
</p>
<p><strong>Returns:</strong> non zero if session resumption was asked, or a zero if not.
</p></dd></dl>

<a name="gnutls_005fsession_005fset_005fdata-1"></a>
<h4 class="subheading">gnutls_session_set_data</h4>
<a name="gnutls_005fsession_005fset_005fdata"></a><dl>
<dt><a name="index-gnutls_005fsession_005fset_005fdata"></a>Function: <em>int</em> <strong>gnutls_session_set_data</strong> <em>(gnutls_session_t <var>session</var>, const void * <var>session_data</var>, size_t <var>session_data_size</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>session_data</var>: is a pointer to space to hold the session.
</p>
<p><var>session_data_size</var>: is the session&rsquo;s size
</p>
<p>Sets all session parameters, in order to resume a previously
established session.  The session data given must be the one
returned by <code>gnutls_session_get_data()</code> .  This function should be
called before <code>gnutls_handshake()</code> .
</p>
<p>Keep in mind that session resuming is advisory. The server may
choose not to resume the session, thus a full handshake will be
performed.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p></dd></dl>

<a name="gnutls_005fsession_005fset_005fid-1"></a>
<h4 class="subheading">gnutls_session_set_id</h4>
<a name="gnutls_005fsession_005fset_005fid"></a><dl>
<dt><a name="index-gnutls_005fsession_005fset_005fid"></a>Function: <em>int</em> <strong>gnutls_session_set_id</strong> <em>(gnutls_session_t <var>session</var>, const gnutls_datum_t * <var>sid</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>sid</var>: the session identifier
</p>
<p>This function sets the session ID to be used in a client hello.
This is a function intended for exceptional uses. Do not use this
function unless you are implementing a custom protocol.
</p>
<p>To set session resumption parameters use <code>gnutls_session_set_data()</code>  instead.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p>
<p><strong>Since:</strong> 3.2.1
</p></dd></dl>

<a name="gnutls_005fsession_005fset_005fpremaster-1"></a>
<h4 class="subheading">gnutls_session_set_premaster</h4>
<a name="gnutls_005fsession_005fset_005fpremaster"></a><dl>
<dt><a name="index-gnutls_005fsession_005fset_005fpremaster"></a>Function: <em>int</em> <strong>gnutls_session_set_premaster</strong> <em>(gnutls_session_t <var>session</var>, unsigned int <var>entity</var>, gnutls_protocol_t <var>version</var>, gnutls_kx_algorithm_t <var>kx</var>, gnutls_cipher_algorithm_t <var>cipher</var>, gnutls_mac_algorithm_t <var>mac</var>, gnutls_compression_method_t <var>comp</var>, const gnutls_datum_t * <var>master</var>, const gnutls_datum_t * <var>session_id</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>entity</var>: GNUTLS_SERVER or GNUTLS_CLIENT
</p>
<p><var>version</var>: the TLS protocol version
</p>
<p><var>kx</var>: the key exchange method
</p>
<p><var>cipher</var>: the cipher
</p>
<p><var>mac</var>: the MAC algorithm
</p>
<p><var>comp</var>: the compression method
</p>
<p><var>master</var>: the master key to use
</p>
<p><var>session_id</var>: the session identifier
</p>
<p>This function sets the premaster secret in a session. This is
a function intended for exceptional uses. Do not use this
function unless you are implementing a legacy protocol.
Use <code>gnutls_session_set_data()</code>  instead.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p></dd></dl>

<a name="gnutls_005fsession_005fset_005fptr-1"></a>
<h4 class="subheading">gnutls_session_set_ptr</h4>
<a name="gnutls_005fsession_005fset_005fptr"></a><dl>
<dt><a name="index-gnutls_005fsession_005fset_005fptr"></a>Function: <em>void</em> <strong>gnutls_session_set_ptr</strong> <em>(gnutls_session_t <var>session</var>, void * <var>ptr</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>ptr</var>: is the user pointer
</p>
<p>This function will set (associate) the user given pointer  <code>ptr</code> to
the session structure.  This pointer can be accessed with
<code>gnutls_session_get_ptr()</code> .
</p></dd></dl>

<a name="gnutls_005fsession_005fset_005fverify_005fcert-1"></a>
<h4 class="subheading">gnutls_session_set_verify_cert</h4>
<a name="gnutls_005fsession_005fset_005fverify_005fcert"></a><dl>
<dt><a name="index-gnutls_005fsession_005fset_005fverify_005fcert-1"></a>Function: <em>void</em> <strong>gnutls_session_set_verify_cert</strong> <em>(gnutls_session_t <var>session</var>, const char * <var>hostname</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p><var>hostname</var>: is the expected name of the peer; may be <code>NULL</code> 
</p>
<p><var>flags</var>: flags for certificate verification &ndash; <code>gnutls_certificate_verify_flags</code> 
</p>
<p>This function instructs GnuTLS to verify the peer&rsquo;s certificate
using the provided hostname. If the verification fails the handshake
will also fail with <code>GNUTLS_E_CERTIFICATE_VERIFICATION_ERROR</code> . In that
case the verification result can be obtained using <code>gnutls_session_get_verify_cert_status()</code> .
</p>
<p>The  <code>hostname</code> pointer provided must remain valid for the lifetime
of the session. More precisely it should be available during any subsequent
handshakes. If no hostname is provided, no hostname verification
will be performed. For a more advanced verification function check
<code>gnutls_session_set_verify_cert2()</code> .
</p>
<p>The <code>gnutls_session_set_verify_cert()</code>  function is intended to be used by TLS
clients to verify the server&rsquo;s certificate.
</p>
<p><strong>Since:</strong> 3.4.6
</p></dd></dl>

<a name="gnutls_005fsession_005fset_005fverify_005fcert2-1"></a>
<h4 class="subheading">gnutls_session_set_verify_cert2</h4>
<a name="gnutls_005fsession_005fset_005fverify_005fcert2"></a><dl>
<dt><a name="index-gnutls_005fsession_005fset_005fverify_005fcert2"></a>Function: <em>void</em> <strong>gnutls_session_set_verify_cert2</strong> <em>(gnutls_session_t <var>session</var>, gnutls_typed_vdata_st * <var>data</var>, unsigned <var>elements</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p><var>data</var>: an array of typed data
</p>
<p><var>elements</var>: the number of data elements
</p>
<p><var>flags</var>: flags for certificate verification &ndash; <code>gnutls_certificate_verify_flags</code> 
</p>
<p>This function instructs GnuTLS to verify the peer&rsquo;s certificate
using the provided typed data information. If the verification fails the handshake
will also fail with <code>GNUTLS_E_CERTIFICATE_VERIFICATION_ERROR</code> . In that
case the verification result can be obtained using <code>gnutls_session_get_verify_cert_status()</code> .
</p>
<p>The acceptable typed data are the same as in <code>gnutls_certificate_verify_peers()</code> ,
and once set must remain valid for the lifetime of the session. More precisely
they should be available during any subsequent handshakes.
</p>
<p><strong>Since:</strong> 3.4.6
</p></dd></dl>

<a name="gnutls_005fsession_005fset_005fverify_005ffunction-1"></a>
<h4 class="subheading">gnutls_session_set_verify_function</h4>
<a name="gnutls_005fsession_005fset_005fverify_005ffunction"></a><dl>
<dt><a name="index-gnutls_005fsession_005fset_005fverify_005ffunction"></a>Function: <em>void</em> <strong>gnutls_session_set_verify_function</strong> <em>(gnutls_session_t <var>session</var>, gnutls_certificate_verify_function * <var>func</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>func</var>: is the callback function
</p>
<p>This function sets a callback to be called when peer&rsquo;s certificate
has been received in order to verify it on receipt rather than
doing after the handshake is completed. This overrides any callback
set using <code>gnutls_certificate_set_verify_function()</code> .
</p>
<p>The callback&rsquo;s function prototype is:
int (*callback)(gnutls_session_t);
</p>
<p>If the callback function is provided then gnutls will call it, in the
handshake, just after the certificate message has been received.
To verify or obtain the certificate the <code>gnutls_certificate_verify_peers2()</code> ,
<code>gnutls_certificate_type_get()</code> , <code>gnutls_certificate_get_peers()</code>  functions
can be used.
</p>
<p>The callback function should return 0 for the handshake to continue
or non-zero to terminate.
</p>
<p><strong>Since:</strong> 3.4.6
</p></dd></dl>

<a name="gnutls_005fsession_005fticket_005fenable_005fclient-1"></a>
<h4 class="subheading">gnutls_session_ticket_enable_client</h4>
<a name="gnutls_005fsession_005fticket_005fenable_005fclient"></a><dl>
<dt><a name="index-gnutls_005fsession_005fticket_005fenable_005fclient"></a>Function: <em>int</em> <strong>gnutls_session_ticket_enable_client</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Request that the client should attempt session resumption using
SessionTicket.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, or an
error code.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>

<a name="gnutls_005fsession_005fticket_005fenable_005fserver-1"></a>
<h4 class="subheading">gnutls_session_ticket_enable_server</h4>
<a name="gnutls_005fsession_005fticket_005fenable_005fserver"></a><dl>
<dt><a name="index-gnutls_005fsession_005fticket_005fenable_005fserver-1"></a>Function: <em>int</em> <strong>gnutls_session_ticket_enable_server</strong> <em>(gnutls_session_t <var>session</var>, const gnutls_datum_t * <var>key</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>key</var>: key to encrypt session parameters.
</p>
<p>Request that the server should attempt session resumption using
SessionTicket.   <code>key</code> must be initialized with
<code>gnutls_session_ticket_key_generate()</code> , and should be overwritten
using <code>gnutls_memset()</code>  before being released.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, or an
error code.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>

<a name="gnutls_005fsession_005fticket_005fkey_005fgenerate-1"></a>
<h4 class="subheading">gnutls_session_ticket_key_generate</h4>
<a name="gnutls_005fsession_005fticket_005fkey_005fgenerate"></a><dl>
<dt><a name="index-gnutls_005fsession_005fticket_005fkey_005fgenerate-1"></a>Function: <em>int</em> <strong>gnutls_session_ticket_key_generate</strong> <em>(gnutls_datum_t * <var>key</var>)</em></dt>
<dd><p><var>key</var>: is a pointer to a <code>gnutls_datum_t</code>  which will contain a newly
created key.
</p>
<p>Generate a random key to encrypt security parameters within
SessionTicket.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, or an
error code.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>

<a name="gnutls_005fset_005fdefault_005fpriority-1"></a>
<h4 class="subheading">gnutls_set_default_priority</h4>
<a name="gnutls_005fset_005fdefault_005fpriority"></a><dl>
<dt><a name="index-gnutls_005fset_005fdefault_005fpriority"></a>Function: <em>int</em> <strong>gnutls_set_default_priority</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Sets the default priority on the ciphers, key exchange methods,
macs and compression methods. For more fine-tuning you could
use <code>gnutls_priority_set_direct()</code>  or <code>gnutls_priority_set()</code>  instead.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, or an error code.
</p></dd></dl>

<a name="gnutls_005fsign_005falgorithm_005fget-1"></a>
<h4 class="subheading">gnutls_sign_algorithm_get</h4>
<a name="gnutls_005fsign_005falgorithm_005fget"></a><dl>
<dt><a name="index-gnutls_005fsign_005falgorithm_005fget"></a>Function: <em>int</em> <strong>gnutls_sign_algorithm_get</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Returns the signature algorithm that is (or will be) used in this 
session by the server to sign data. This function should be
used only with TLS 1.2 or later.
</p>
<p><strong>Returns:</strong> The sign algorithm or <code>GNUTLS_SIGN_UNKNOWN</code> .
</p>
<p><strong>Since:</strong> 3.1.1
</p></dd></dl>

<a name="gnutls_005fsign_005falgorithm_005fget_005fclient-1"></a>
<h4 class="subheading">gnutls_sign_algorithm_get_client</h4>
<a name="gnutls_005fsign_005falgorithm_005fget_005fclient"></a><dl>
<dt><a name="index-gnutls_005fsign_005falgorithm_005fget_005fclient"></a>Function: <em>int</em> <strong>gnutls_sign_algorithm_get_client</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Returns the signature algorithm that is (or will be) used in this 
session by the client to sign data. This function should be
used only with TLS 1.2 or later.
</p>
<p><strong>Returns:</strong> The sign algorithm or <code>GNUTLS_SIGN_UNKNOWN</code> .
</p>
<p><strong>Since:</strong> 3.1.11
</p></dd></dl>

<a name="gnutls_005fsign_005falgorithm_005fget_005frequested-1"></a>
<h4 class="subheading">gnutls_sign_algorithm_get_requested</h4>
<a name="gnutls_005fsign_005falgorithm_005fget_005frequested"></a><dl>
<dt><a name="index-gnutls_005fsign_005falgorithm_005fget_005frequested"></a>Function: <em>int</em> <strong>gnutls_sign_algorithm_get_requested</strong> <em>(gnutls_session_t <var>session</var>, size_t <var>indx</var>, gnutls_sign_algorithm_t * <var>algo</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>indx</var>: is an index of the signature algorithm to return
</p>
<p><var>algo</var>: the returned certificate type will be stored there
</p>
<p>Returns the signature algorithm specified by index that was
requested by the peer. If the specified index has no data available
this function returns <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> .  If
the negotiated TLS version does not support signature algorithms
then <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  will be returned even
for the first index.  The first index is 0.
</p>
<p>This function is useful in the certificate callback functions
to assist in selecting the correct certificate.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>

<a name="gnutls_005fsign_005fget_005fhash_005falgorithm-1"></a>
<h4 class="subheading">gnutls_sign_get_hash_algorithm</h4>
<a name="gnutls_005fsign_005fget_005fhash_005falgorithm"></a><dl>
<dt><a name="index-gnutls_005fsign_005fget_005fhash_005falgorithm"></a>Function: <em>gnutls_digest_algorithm_t</em> <strong>gnutls_sign_get_hash_algorithm</strong> <em>(gnutls_sign_algorithm_t <var>sign</var>)</em></dt>
<dd><p><var>sign</var>: is a signature algorithm
</p>
<p>This function returns the digest algorithm corresponding to
the given signature algorithms.
</p>
<p><strong>Since:</strong> 3.1.1
</p>
<p><strong>Returns:</strong> return a <code>gnutls_digest_algorithm_t</code>  value, or <code>GNUTLS_DIG_UNKNOWN</code>  on error.
</p></dd></dl>

<a name="gnutls_005fsign_005fget_005fid-1"></a>
<h4 class="subheading">gnutls_sign_get_id</h4>
<a name="gnutls_005fsign_005fget_005fid"></a><dl>
<dt><a name="index-gnutls_005fsign_005fget_005fid"></a>Function: <em>gnutls_sign_algorithm_t</em> <strong>gnutls_sign_get_id</strong> <em>(const char * <var>name</var>)</em></dt>
<dd><p><var>name</var>: is a sign algorithm name
</p>
<p>The names are compared in a case insensitive way.
</p>
<p><strong>Returns:</strong> return a <code>gnutls_sign_algorithm_t</code>  value corresponding to
the specified algorithm, or <code>GNUTLS_SIGN_UNKNOWN</code>  on error.
</p></dd></dl>

<a name="gnutls_005fsign_005fget_005fname-1"></a>
<h4 class="subheading">gnutls_sign_get_name</h4>
<a name="gnutls_005fsign_005fget_005fname"></a><dl>
<dt><a name="index-gnutls_005fsign_005fget_005fname"></a>Function: <em>const char *</em> <strong>gnutls_sign_get_name</strong> <em>(gnutls_sign_algorithm_t <var>algorithm</var>)</em></dt>
<dd><p><var>algorithm</var>: is a sign algorithm
</p>
<p>Convert a <code>gnutls_sign_algorithm_t</code>  value to a string.
</p>
<p><strong>Returns:</strong> a string that contains the name of the specified sign
algorithm, or <code>NULL</code> .
</p></dd></dl>

<a name="gnutls_005fsign_005fget_005foid-1"></a>
<h4 class="subheading">gnutls_sign_get_oid</h4>
<a name="gnutls_005fsign_005fget_005foid"></a><dl>
<dt><a name="index-gnutls_005fsign_005fget_005foid"></a>Function: <em>const char *</em> <strong>gnutls_sign_get_oid</strong> <em>(gnutls_sign_algorithm_t <var>sign</var>)</em></dt>
<dd><p><var>sign</var>: is a sign algorithm
</p>
<p>Convert a <code>gnutls_sign_algorithm_t</code>  value to its object identifier.
</p>
<p><strong>Returns:</strong> a string that contains the object identifier of the specified sign
algorithm, or <code>NULL</code> .
</p>
<p><strong>Since:</strong> 3.4.3
</p></dd></dl>

<a name="gnutls_005fsign_005fget_005fpk_005falgorithm-1"></a>
<h4 class="subheading">gnutls_sign_get_pk_algorithm</h4>
<a name="gnutls_005fsign_005fget_005fpk_005falgorithm"></a><dl>
<dt><a name="index-gnutls_005fsign_005fget_005fpk_005falgorithm"></a>Function: <em>gnutls_pk_algorithm_t</em> <strong>gnutls_sign_get_pk_algorithm</strong> <em>(gnutls_sign_algorithm_t <var>sign</var>)</em></dt>
<dd><p><var>sign</var>: is a signature algorithm
</p>
<p>This function returns the public key algorithm corresponding to
the given signature algorithms.
</p>
<p><strong>Since:</strong> 3.1.1
</p>
<p><strong>Returns:</strong> return a <code>gnutls_pk_algorithm_t</code>  value, or <code>GNUTLS_PK_UNKNOWN</code>  on error.
</p></dd></dl>

<a name="gnutls_005fsign_005fis_005fsecure-1"></a>
<h4 class="subheading">gnutls_sign_is_secure</h4>
<a name="gnutls_005fsign_005fis_005fsecure"></a><dl>
<dt><a name="index-gnutls_005fsign_005fis_005fsecure"></a>Function: <em>int</em> <strong>gnutls_sign_is_secure</strong> <em>(gnutls_sign_algorithm_t <var>algorithm</var>)</em></dt>
<dd><p><var>algorithm</var>: is a sign algorithm
</p>

<p><strong>Returns:</strong> Non-zero if the provided signature algorithm is considered to be secure.
</p></dd></dl>

<a name="gnutls_005fsign_005flist-1"></a>
<h4 class="subheading">gnutls_sign_list</h4>
<a name="gnutls_005fsign_005flist"></a><dl>
<dt><a name="index-gnutls_005fsign_005flist"></a>Function: <em>const gnutls_sign_algorithm_t *</em> <strong>gnutls_sign_list</strong> <em>( <var>void</var>)</em></dt>
<dd>
<p>Get a list of supported public key signature algorithms.
</p>
<p><strong>Returns:</strong> a (0)-terminated list of <code>gnutls_sign_algorithm_t</code> 
integers indicating the available ciphers.
</p></dd></dl>

<a name="gnutls_005fsrp_005fallocate_005fclient_005fcredentials-1"></a>
<h4 class="subheading">gnutls_srp_allocate_client_credentials</h4>
<a name="gnutls_005fsrp_005fallocate_005fclient_005fcredentials"></a><dl>
<dt><a name="index-gnutls_005fsrp_005fallocate_005fclient_005fcredentials"></a>Function: <em>int</em> <strong>gnutls_srp_allocate_client_credentials</strong> <em>(gnutls_srp_client_credentials_t *            <var>sc</var>)</em></dt>
<dd><p><var>sc</var>: is a pointer to a <code>gnutls_srp_server_credentials_t</code>  type.
</p>
<p>Allocate a gnutls_srp_client_credentials_t structure.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, or an
error code.
</p></dd></dl>

<a name="gnutls_005fsrp_005fallocate_005fserver_005fcredentials-1"></a>
<h4 class="subheading">gnutls_srp_allocate_server_credentials</h4>
<a name="gnutls_005fsrp_005fallocate_005fserver_005fcredentials"></a><dl>
<dt><a name="index-gnutls_005fsrp_005fallocate_005fserver_005fcredentials"></a>Function: <em>int</em> <strong>gnutls_srp_allocate_server_credentials</strong> <em>(gnutls_srp_server_credentials_t *            <var>sc</var>)</em></dt>
<dd><p><var>sc</var>: is a pointer to a <code>gnutls_srp_server_credentials_t</code>  type.
</p>
<p>Allocate a gnutls_srp_server_credentials_t structure.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, or an
error code.
</p></dd></dl>

<a name="gnutls_005fsrp_005fbase64_005fdecode-1"></a>
<h4 class="subheading">gnutls_srp_base64_decode</h4>
<a name="gnutls_005fsrp_005fbase64_005fdecode"></a><dl>
<dt><a name="index-gnutls_005fsrp_005fbase64_005fdecode"></a>Function: <em>int</em> <strong>gnutls_srp_base64_decode</strong> <em>(const gnutls_datum_t * <var>b64_data</var>, char * <var>result</var>, size_t * <var>result_size</var>)</em></dt>
<dd><p><var>b64_data</var>: contain the encoded data
</p>
<p><var>result</var>: the place where decoded data will be copied
</p>
<p><var>result_size</var>: holds the size of the result
</p>
<p>This function will decode the given encoded data, using the base64
encoding found in libsrp.
</p>
<p>Note that  <code>b64_data</code> should be null terminated.
</p>
<p>Warning!  This base64 encoding is not the &quot;standard&quot; encoding, so
do not use it for non-SRP purposes.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the buffer given is not
long enough, or 0 on success.
</p></dd></dl>

<a name="gnutls_005fsrp_005fbase64_005fdecode2-1"></a>
<h4 class="subheading">gnutls_srp_base64_decode2</h4>
<a name="gnutls_005fsrp_005fbase64_005fdecode2"></a><dl>
<dt><a name="index-gnutls_005fsrp_005fbase64_005fdecode2"></a>Function: <em>int</em> <strong>gnutls_srp_base64_decode2</strong> <em>(const gnutls_datum_t * <var>b64_data</var>, gnutls_datum_t * <var>result</var>)</em></dt>
<dd><p><var>b64_data</var>: contains the encoded data
</p>
<p><var>result</var>: the place where decoded data lie
</p>
<p>This function will decode the given encoded data. The decoded data
will be allocated, and stored into result.  It will decode using
the base64 algorithm as used in libsrp.
</p>
<p>You should use <code>gnutls_free()</code>  to free the returned data.
</p>
<p>Warning!  This base64 encoding is not the &quot;standard&quot; encoding, so
do not use it for non-SRP purposes.
</p>
<p><strong>Returns:</strong> 0 on success, or an error code.
</p></dd></dl>

<a name="gnutls_005fsrp_005fbase64_005fencode-1"></a>
<h4 class="subheading">gnutls_srp_base64_encode</h4>
<a name="gnutls_005fsrp_005fbase64_005fencode"></a><dl>
<dt><a name="index-gnutls_005fsrp_005fbase64_005fencode"></a>Function: <em>int</em> <strong>gnutls_srp_base64_encode</strong> <em>(const gnutls_datum_t * <var>data</var>, char * <var>result</var>, size_t * <var>result_size</var>)</em></dt>
<dd><p><var>data</var>: contain the raw data
</p>
<p><var>result</var>: the place where base64 data will be copied
</p>
<p><var>result_size</var>: holds the size of the result
</p>
<p>This function will convert the given data to printable data, using
the base64 encoding, as used in the libsrp.  This is the encoding
used in SRP password files.  If the provided buffer is not long
enough GNUTLS_E_SHORT_MEMORY_BUFFER is returned.
</p>
<p>Warning!  This base64 encoding is not the &quot;standard&quot; encoding, so
do not use it for non-SRP purposes.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the buffer given is not
long enough, or 0 on success.
</p></dd></dl>

<a name="gnutls_005fsrp_005fbase64_005fencode2-1"></a>
<h4 class="subheading">gnutls_srp_base64_encode2</h4>
<a name="gnutls_005fsrp_005fbase64_005fencode2"></a><dl>
<dt><a name="index-gnutls_005fsrp_005fbase64_005fencode2"></a>Function: <em>int</em> <strong>gnutls_srp_base64_encode2</strong> <em>(const gnutls_datum_t * <var>data</var>, gnutls_datum_t * <var>result</var>)</em></dt>
<dd><p><var>data</var>: contains the raw data
</p>
<p><var>result</var>: will hold the newly allocated encoded data
</p>
<p>This function will convert the given data to printable data, using
the base64 encoding.  This is the encoding used in SRP password
files.  This function will allocate the required memory to hold
the encoded data.
</p>
<p>You should use <code>gnutls_free()</code>  to free the returned data.
</p>
<p>Warning!  This base64 encoding is not the &quot;standard&quot; encoding, so
do not use it for non-SRP purposes.
</p>
<p><strong>Returns:</strong> 0 on success, or an error code.
</p></dd></dl>

<a name="gnutls_005fsrp_005ffree_005fclient_005fcredentials-1"></a>
<h4 class="subheading">gnutls_srp_free_client_credentials</h4>
<a name="gnutls_005fsrp_005ffree_005fclient_005fcredentials"></a><dl>
<dt><a name="index-gnutls_005fsrp_005ffree_005fclient_005fcredentials"></a>Function: <em>void</em> <strong>gnutls_srp_free_client_credentials</strong> <em>(gnutls_srp_client_credentials_t <var>sc</var>)</em></dt>
<dd><p><var>sc</var>: is a <code>gnutls_srp_client_credentials_t</code>  type.
</p>
<p>Free a gnutls_srp_client_credentials_t structure.
</p></dd></dl>

<a name="gnutls_005fsrp_005ffree_005fserver_005fcredentials-1"></a>
<h4 class="subheading">gnutls_srp_free_server_credentials</h4>
<a name="gnutls_005fsrp_005ffree_005fserver_005fcredentials"></a><dl>
<dt><a name="index-gnutls_005fsrp_005ffree_005fserver_005fcredentials"></a>Function: <em>void</em> <strong>gnutls_srp_free_server_credentials</strong> <em>(gnutls_srp_server_credentials_t <var>sc</var>)</em></dt>
<dd><p><var>sc</var>: is a <code>gnutls_srp_server_credentials_t</code>  type.
</p>
<p>Free a gnutls_srp_server_credentials_t structure.
</p></dd></dl>

<a name="gnutls_005fsrp_005fserver_005fget_005fusername-1"></a>
<h4 class="subheading">gnutls_srp_server_get_username</h4>
<a name="gnutls_005fsrp_005fserver_005fget_005fusername"></a><dl>
<dt><a name="index-gnutls_005fsrp_005fserver_005fget_005fusername"></a>Function: <em>const char *</em> <strong>gnutls_srp_server_get_username</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p>This function will return the username of the peer.  This should
only be called in case of SRP authentication and in case of a
server.  Returns NULL in case of an error.
</p>
<p><strong>Returns:</strong> SRP username of the peer, or NULL in case of error.
</p></dd></dl>

<a name="gnutls_005fsrp_005fset_005fclient_005fcredentials-1"></a>
<h4 class="subheading">gnutls_srp_set_client_credentials</h4>
<a name="gnutls_005fsrp_005fset_005fclient_005fcredentials"></a><dl>
<dt><a name="index-gnutls_005fsrp_005fset_005fclient_005fcredentials"></a>Function: <em>int</em> <strong>gnutls_srp_set_client_credentials</strong> <em>(gnutls_srp_client_credentials_t <var>res</var>, const char * <var>username</var>, const char * <var>password</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_srp_client_credentials_t</code>  type.
</p>
<p><var>username</var>: is the user&rsquo;s userid
</p>
<p><var>password</var>: is the user&rsquo;s password
</p>
<p>This function sets the username and password, in a
<code>gnutls_srp_client_credentials_t</code>  type.  Those will be used in
SRP authentication.   <code>username</code> and  <code>password</code> should be ASCII
strings or UTF-8 strings prepared using the &quot;SASLprep&quot; profile of
&quot;stringprep&quot;.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, or an
error code.
</p></dd></dl>

<a name="gnutls_005fsrp_005fset_005fclient_005fcredentials_005ffunction-1"></a>
<h4 class="subheading">gnutls_srp_set_client_credentials_function</h4>
<a name="gnutls_005fsrp_005fset_005fclient_005fcredentials_005ffunction"></a><dl>
<dt><a name="index-gnutls_005fsrp_005fset_005fclient_005fcredentials_005ffunction-1"></a>Function: <em>void</em> <strong>gnutls_srp_set_client_credentials_function</strong> <em>(gnutls_srp_client_credentials_t         <var>cred</var>, gnutls_srp_client_credentials_function         * <var>func</var>)</em></dt>
<dd><p><var>cred</var>: is a <code>gnutls_srp_server_credentials_t</code>  type.
</p>
<p><var>func</var>: is the callback function
</p>
<p>This function can be used to set a callback to retrieve the
username and password for client SRP authentication.  The
callback&rsquo;s function form is:
</p>
<p>int (*callback)(gnutls_session_t, char** username, char**password);
</p>
<p>The  <code>username</code> and  <code>password</code> must be allocated using
<code>gnutls_malloc()</code> .   <code>username</code> and  <code>password</code> should be ASCII strings
or UTF-8 strings prepared using the &quot;SASLprep&quot; profile of
&quot;stringprep&quot;.
</p>
<p>The callback function will be called once per handshake before the
initial hello message is sent.
</p>
<p>The callback should not return a negative error code the second
time called, since the handshake procedure will be aborted.
</p>
<p>The callback function should return 0 on success.
-1 indicates an error.
</p></dd></dl>

<a name="gnutls_005fsrp_005fset_005fprime_005fbits-1"></a>
<h4 class="subheading">gnutls_srp_set_prime_bits</h4>
<a name="gnutls_005fsrp_005fset_005fprime_005fbits"></a><dl>
<dt><a name="index-gnutls_005fsrp_005fset_005fprime_005fbits"></a>Function: <em>void</em> <strong>gnutls_srp_set_prime_bits</strong> <em>(gnutls_session_t <var>session</var>, unsigned int <var>bits</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>bits</var>: is the number of bits
</p>
<p>This function sets the minimum accepted number of bits, for use in
an SRP key exchange.  If zero, the default 2048 bits will be used.
</p>
<p>In the client side it sets the minimum accepted number of bits.  If
a server sends a prime with less bits than that
<code>GNUTLS_E_RECEIVED_ILLEGAL_PARAMETER</code>  will be returned by the
handshake.
</p>
<p>This function has no effect in server side.
</p>
<p><strong>Since:</strong> 2.6.0
</p></dd></dl>

<a name="gnutls_005fsrp_005fset_005fserver_005fcredentials_005ffile-1"></a>
<h4 class="subheading">gnutls_srp_set_server_credentials_file</h4>
<a name="gnutls_005fsrp_005fset_005fserver_005fcredentials_005ffile"></a><dl>
<dt><a name="index-gnutls_005fsrp_005fset_005fserver_005fcredentials_005ffile-1"></a>Function: <em>int</em> <strong>gnutls_srp_set_server_credentials_file</strong> <em>(gnutls_srp_server_credentials_t <var>res</var>, const char * <var>password_file</var>, const char * <var>password_conf_file</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_srp_server_credentials_t</code>  type.
</p>
<p><var>password_file</var>: is the SRP password file (tpasswd)
</p>
<p><var>password_conf_file</var>: is the SRP password conf file (tpasswd.conf)
</p>
<p>This function sets the password files, in a
<code>gnutls_srp_server_credentials_t</code>  type.  Those password files
hold usernames and verifiers and will be used for SRP
authentication.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, or an
error code.
</p></dd></dl>

<a name="gnutls_005fsrp_005fset_005fserver_005fcredentials_005ffunction-1"></a>
<h4 class="subheading">gnutls_srp_set_server_credentials_function</h4>
<a name="gnutls_005fsrp_005fset_005fserver_005fcredentials_005ffunction"></a><dl>
<dt><a name="index-gnutls_005fsrp_005fset_005fserver_005fcredentials_005ffunction-1"></a>Function: <em>void</em> <strong>gnutls_srp_set_server_credentials_function</strong> <em>(gnutls_srp_server_credentials_t         <var>cred</var>, gnutls_srp_server_credentials_function         * <var>func</var>)</em></dt>
<dd><p><var>cred</var>: is a <code>gnutls_srp_server_credentials_t</code>  type.
</p>
<p><var>func</var>: is the callback function
</p>
<p>This function can be used to set a callback to retrieve the user&rsquo;s
SRP credentials.  The callback&rsquo;s function form is:
</p>
<p>int (*callback)(gnutls_session_t, const char* username,
gnutls_datum_t *salt, gnutls_datum_t *verifier, gnutls_datum_t *generator,
gnutls_datum_t *prime);
</p>
<p><code>username</code> contains the actual username.
The  <code>salt</code> ,  <code>verifier</code> ,  <code>generator</code> and  <code>prime</code> must be filled
in using the <code>gnutls_malloc()</code> . For convenience  <code>prime</code> and  <code>generator</code> may also be one of the static parameters defined in gnutls.h.
</p>
<p>Initially, the data field is NULL in every <code>gnutls_datum_t</code> 
structure that the callback has to fill in. When the
callback is done GnuTLS deallocates all of those buffers
which are non-NULL, regardless of the return value.
</p>
<p>In order to prevent attackers from guessing valid usernames,
if a user does not exist, g and n values should be filled in
using a random user&rsquo;s parameters. In that case the callback must
return the special value (1).
See <code>gnutls_srp_set_server_fake_salt_seed</code>  too.
If this is not required for your application, return a negative
number from the callback to abort the handshake.
</p>
<p>The callback function will only be called once per handshake.
The callback function should return 0 on success, while
-1 indicates an error.
</p></dd></dl>

<a name="gnutls_005fsrp_005fset_005fserver_005ffake_005fsalt_005fseed-1"></a>
<h4 class="subheading">gnutls_srp_set_server_fake_salt_seed</h4>
<a name="gnutls_005fsrp_005fset_005fserver_005ffake_005fsalt_005fseed"></a><dl>
<dt><a name="index-gnutls_005fsrp_005fset_005fserver_005ffake_005fsalt_005fseed"></a>Function: <em>void</em> <strong>gnutls_srp_set_server_fake_salt_seed</strong> <em>(gnutls_srp_server_credentials_t <var>cred</var>, const gnutls_datum_t * <var>seed</var>, unsigned int <var>salt_length</var>)</em></dt>
<dd><p><var>cred</var>: is a <code>gnutls_srp_server_credentials_t</code>  type
</p>
<p><var>seed</var>: is the seed data, only needs to be valid until the function
returns; size of the seed must be greater than zero
</p>
<p><var>salt_length</var>: is the length of the generated fake salts
</p>
<p>This function sets the seed that is used to generate salts for
invalid (non-existent) usernames.
</p>
<p>In order to prevent attackers from guessing valid usernames,
when a user does not exist gnutls generates a salt and a verifier
and proceeds with the protocol as usual.
The authentication will ultimately fail, but the client cannot tell
whether the username is valid (exists) or invalid.
</p>
<p>If an attacker learns the seed, given a salt (which is part of the
handshake) which was generated when the seed was in use, it can tell
whether or not the authentication failed because of an unknown username.
This seed cannot be used to reveal application data or passwords.
</p>
<p><code>salt_length</code> should represent the salt length your application uses.
Generating fake salts longer than 20 bytes is not supported.
</p>
<p>By default the seed is a random value, different each time a
<code>gnutls_srp_server_credentials_t</code>  is allocated and fake salts are
16 bytes long.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fsrp_005fverifier-1"></a>
<h4 class="subheading">gnutls_srp_verifier</h4>
<a name="gnutls_005fsrp_005fverifier"></a><dl>
<dt><a name="index-gnutls_005fsrp_005fverifier-1"></a>Function: <em>int</em> <strong>gnutls_srp_verifier</strong> <em>(const char * <var>username</var>, const char * <var>password</var>, const gnutls_datum_t * <var>salt</var>, const gnutls_datum_t * <var>generator</var>, const gnutls_datum_t * <var>prime</var>, gnutls_datum_t * <var>res</var>)</em></dt>
<dd><p><var>username</var>: is the user&rsquo;s name
</p>
<p><var>password</var>: is the user&rsquo;s password
</p>
<p><var>salt</var>: should be some randomly generated bytes
</p>
<p><var>generator</var>: is the generator of the group
</p>
<p><var>prime</var>: is the group&rsquo;s prime
</p>
<p><var>res</var>: where the verifier will be stored.
</p>
<p>This function will create an SRP verifier, as specified in
RFC2945.  The  <code>prime</code> and  <code>generator</code> should be one of the static
parameters defined in gnutls/gnutls.h or may be generated.
</p>
<p>The verifier will be allocated with  <code>gnutls_malloc</code> () and will be stored in
 <code>res</code> using binary format.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, or an
error code.
</p></dd></dl>

<a name="gnutls_005fsrtp_005fget_005fkeys-1"></a>
<h4 class="subheading">gnutls_srtp_get_keys</h4>
<a name="gnutls_005fsrtp_005fget_005fkeys"></a><dl>
<dt><a name="index-gnutls_005fsrtp_005fget_005fkeys-1"></a>Function: <em>int</em> <strong>gnutls_srtp_get_keys</strong> <em>(gnutls_session_t <var>session</var>, void * <var>key_material</var>, unsigned int <var>key_material_size</var>, gnutls_datum_t * <var>client_key</var>, gnutls_datum_t * <var>client_salt</var>, gnutls_datum_t * <var>server_key</var>, gnutls_datum_t * <var>server_salt</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>key_material</var>: Space to hold the generated key material
</p>
<p><var>key_material_size</var>: The maximum size of the key material
</p>
<p><var>client_key</var>: The master client write key, pointing inside the key material
</p>
<p><var>client_salt</var>: The master client write salt, pointing inside the key material
</p>
<p><var>server_key</var>: The master server write key, pointing inside the key material
</p>
<p><var>server_salt</var>: The master server write salt, pointing inside the key material
</p>
<p>This is a helper function to generate the keying material for SRTP.
It requires the space of the key material to be pre-allocated (should be at least
2x the maximum key size and salt size). The  <code>client_key</code> ,  <code>client_salt</code> ,  <code>server_key</code> and  <code>server_salt</code> are convenience datums that point inside the key material. They may
be <code>NULL</code> .
</p>
<p><strong>Returns:</strong> On success the size of the key material is returned,
otherwise, <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the buffer given is not 
sufficient, or a negative error code.
</p>
<p>Since 3.1.4
</p></dd></dl>

<a name="gnutls_005fsrtp_005fget_005fmki-1"></a>
<h4 class="subheading">gnutls_srtp_get_mki</h4>
<a name="gnutls_005fsrtp_005fget_005fmki"></a><dl>
<dt><a name="index-gnutls_005fsrtp_005fget_005fmki"></a>Function: <em>int</em> <strong>gnutls_srtp_get_mki</strong> <em>(gnutls_session_t <var>session</var>, gnutls_datum_t * <var>mki</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>mki</var>: will hold the MKI
</p>
<p>This function exports the negotiated Master Key Identifier,
received by the peer if any. The returned value in  <code>mki</code> should be 
treated as constant and valid only during the session&rsquo;s lifetime.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p>
<p>Since 3.1.4
</p></dd></dl>

<a name="gnutls_005fsrtp_005fget_005fprofile_005fid-1"></a>
<h4 class="subheading">gnutls_srtp_get_profile_id</h4>
<a name="gnutls_005fsrtp_005fget_005fprofile_005fid"></a><dl>
<dt><a name="index-gnutls_005fsrtp_005fget_005fprofile_005fid"></a>Function: <em>int</em> <strong>gnutls_srtp_get_profile_id</strong> <em>(const char * <var>name</var>, gnutls_srtp_profile_t * <var>profile</var>)</em></dt>
<dd><p><var>name</var>: The name of the profile to look up
</p>
<p><var>profile</var>: Will hold the profile id
</p>
<p>This function allows you to look up a profile based on a string.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p>
<p>Since 3.1.4
</p></dd></dl>

<a name="gnutls_005fsrtp_005fget_005fprofile_005fname-1"></a>
<h4 class="subheading">gnutls_srtp_get_profile_name</h4>
<a name="gnutls_005fsrtp_005fget_005fprofile_005fname"></a><dl>
<dt><a name="index-gnutls_005fsrtp_005fget_005fprofile_005fname"></a>Function: <em>const char *</em> <strong>gnutls_srtp_get_profile_name</strong> <em>(gnutls_srtp_profile_t <var>profile</var>)</em></dt>
<dd><p><var>profile</var>: The profile to look up a string for
</p>
<p>This function allows you to get the corresponding name for a
SRTP protection profile.
</p>
<p><strong>Returns:</strong> On success, the name of a SRTP profile as a string,
otherwise NULL.
</p>
<p>Since 3.1.4
</p></dd></dl>

<a name="gnutls_005fsrtp_005fget_005fselected_005fprofile-1"></a>
<h4 class="subheading">gnutls_srtp_get_selected_profile</h4>
<a name="gnutls_005fsrtp_005fget_005fselected_005fprofile"></a><dl>
<dt><a name="index-gnutls_005fsrtp_005fget_005fselected_005fprofile"></a>Function: <em>int</em> <strong>gnutls_srtp_get_selected_profile</strong> <em>(gnutls_session_t <var>session</var>, gnutls_srtp_profile_t * <var>profile</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>profile</var>: will hold the profile
</p>
<p>This function allows you to get the negotiated SRTP profile.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p>
<p>Since 3.1.4
</p></dd></dl>

<a name="gnutls_005fsrtp_005fset_005fmki-1"></a>
<h4 class="subheading">gnutls_srtp_set_mki</h4>
<a name="gnutls_005fsrtp_005fset_005fmki"></a><dl>
<dt><a name="index-gnutls_005fsrtp_005fset_005fmki"></a>Function: <em>int</em> <strong>gnutls_srtp_set_mki</strong> <em>(gnutls_session_t <var>session</var>, const gnutls_datum_t * <var>mki</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>mki</var>: holds the MKI
</p>
<p>This function sets the Master Key Identifier, to be
used by this session (if any).
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p>
<p>Since 3.1.4
</p></dd></dl>

<a name="gnutls_005fsrtp_005fset_005fprofile-1"></a>
<h4 class="subheading">gnutls_srtp_set_profile</h4>
<a name="gnutls_005fsrtp_005fset_005fprofile"></a><dl>
<dt><a name="index-gnutls_005fsrtp_005fset_005fprofile"></a>Function: <em>int</em> <strong>gnutls_srtp_set_profile</strong> <em>(gnutls_session_t <var>session</var>, gnutls_srtp_profile_t <var>profile</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>profile</var>: is the profile id to add.
</p>
<p>This function is to be used by both clients and servers, to declare
what SRTP profiles they support, to negotiate with the peer.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p>
<p>Since 3.1.4
</p></dd></dl>

<a name="gnutls_005fsrtp_005fset_005fprofile_005fdirect-1"></a>
<h4 class="subheading">gnutls_srtp_set_profile_direct</h4>
<a name="gnutls_005fsrtp_005fset_005fprofile_005fdirect"></a><dl>
<dt><a name="index-gnutls_005fsrtp_005fset_005fprofile_005fdirect"></a>Function: <em>int</em> <strong>gnutls_srtp_set_profile_direct</strong> <em>(gnutls_session_t <var>session</var>, const char * <var>profiles</var>, const char ** <var>err_pos</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>profiles</var>: is a string that contains the supported SRTP profiles,
separated by colons.
</p>
<p><var>err_pos</var>: In case of an error this will have the position in the string the error occurred, may be NULL.
</p>
<p>This function is to be used by both clients and servers, to declare
what SRTP profiles they support, to negotiate with the peer.
</p>
<p><strong>Returns:</strong> On syntax error <code>GNUTLS_E_INVALID_REQUEST</code>  is returned,
<code>GNUTLS_E_SUCCESS</code>  on success, or an error code.
</p>
<p>Since 3.1.4
</p></dd></dl>

<a name="gnutls_005fstore_005fcommitment-1"></a>
<h4 class="subheading">gnutls_store_commitment</h4>
<a name="gnutls_005fstore_005fcommitment"></a><dl>
<dt><a name="index-gnutls_005fstore_005fcommitment-1"></a>Function: <em>int</em> <strong>gnutls_store_commitment</strong> <em>(const char * <var>db_name</var>, gnutls_tdb_t <var>tdb</var>, const char * <var>host</var>, const char * <var>service</var>, gnutls_digest_algorithm_t <var>hash_algo</var>, const gnutls_datum_t * <var>hash</var>, time_t <var>expiration</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>db_name</var>: A file specifying the stored keys (use NULL for the default)
</p>
<p><var>tdb</var>: A storage structure or NULL to use the default
</p>
<p><var>host</var>: The peer&rsquo;s name
</p>
<p><var>service</var>: non-NULL if this key is specific to a service (e.g. http)
</p>
<p><var>hash_algo</var>: The hash algorithm type
</p>
<p><var>hash</var>: The raw hash
</p>
<p><var>expiration</var>: The expiration time (use 0 to disable expiration)
</p>
<p><var>flags</var>: should be 0.
</p>
<p>This function will store the provided hash commitment to 
the list of stored public keys. The key with the given
hash will be considered valid until the provided expiration time.
</p>
<p>The  <code>store</code> variable if non-null specifies a custom backend for
the storage of entries. If it is NULL then the
default file backend will be used.
</p>
<p>Note that this function is not thread safe with the default backend.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<a name="gnutls_005fstore_005fpubkey-1"></a>
<h4 class="subheading">gnutls_store_pubkey</h4>
<a name="gnutls_005fstore_005fpubkey"></a><dl>
<dt><a name="index-gnutls_005fstore_005fpubkey-1"></a>Function: <em>int</em> <strong>gnutls_store_pubkey</strong> <em>(const char * <var>db_name</var>, gnutls_tdb_t <var>tdb</var>, const char * <var>host</var>, const char * <var>service</var>, gnutls_certificate_type_t <var>cert_type</var>, const gnutls_datum_t * <var>cert</var>, time_t <var>expiration</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>db_name</var>: A file specifying the stored keys (use NULL for the default)
</p>
<p><var>tdb</var>: A storage structure or NULL to use the default
</p>
<p><var>host</var>: The peer&rsquo;s name
</p>
<p><var>service</var>: non-NULL if this key is specific to a service (e.g. http)
</p>
<p><var>cert_type</var>: The type of the certificate
</p>
<p><var>cert</var>: The data of the certificate
</p>
<p><var>expiration</var>: The expiration time (use 0 to disable expiration)
</p>
<p><var>flags</var>: should be 0.
</p>
<p>This function will store the provided (raw or DER-encoded) certificate to 
the list of stored public keys. The key will be considered valid until 
the provided expiration time.
</p>
<p>The  <code>store</code> variable if non-null specifies a custom backend for
the storage of entries. If it is NULL then the
default file backend will be used.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.0.13
</p></dd></dl>

<a name="gnutls_005fstrerror-1"></a>
<h4 class="subheading">gnutls_strerror</h4>
<a name="gnutls_005fstrerror"></a><dl>
<dt><a name="index-gnutls_005fstrerror"></a>Function: <em>const char *</em> <strong>gnutls_strerror</strong> <em>(int <var>error</var>)</em></dt>
<dd><p><var>error</var>: is a GnuTLS error code, a negative error code
</p>
<p>This function is similar to strerror.  The difference is that it
accepts an error number returned by a gnutls function; In case of
an unknown error a descriptive string is sent instead of <code>NULL</code> .
</p>
<p>Error codes are always a negative error code.
</p>
<p><strong>Returns:</strong> A string explaining the GnuTLS error message.
</p></dd></dl>

<a name="gnutls_005fstrerror_005fname-1"></a>
<h4 class="subheading">gnutls_strerror_name</h4>
<a name="gnutls_005fstrerror_005fname"></a><dl>
<dt><a name="index-gnutls_005fstrerror_005fname"></a>Function: <em>const char *</em> <strong>gnutls_strerror_name</strong> <em>(int <var>error</var>)</em></dt>
<dd><p><var>error</var>: is an error returned by a gnutls function.
</p>
<p>Return the GnuTLS error code define as a string.  For example,
gnutls_strerror_name (GNUTLS_E_DH_PRIME_UNACCEPTABLE) will return
the string &quot;GNUTLS_E_DH_PRIME_UNACCEPTABLE&quot;.
</p>
<p><strong>Returns:</strong> A string corresponding to the symbol name of the error
code.
</p>
<p><strong>Since:</strong> 2.6.0
</p></dd></dl>

<a name="gnutls_005fsupplemental_005fget_005fname-1"></a>
<h4 class="subheading">gnutls_supplemental_get_name</h4>
<a name="gnutls_005fsupplemental_005fget_005fname"></a><dl>
<dt><a name="index-gnutls_005fsupplemental_005fget_005fname"></a>Function: <em>const char     *</em> <strong>gnutls_supplemental_get_name</strong> <em>(gnutls_supplemental_data_format_type_t       <var>type</var>)</em></dt>
<dd><p><var>type</var>: is a supplemental data format type
</p>
<p>Convert a <code>gnutls_supplemental_data_format_type_t</code>  value to a
string.
</p>
<p><strong>Returns:</strong> a string that contains the name of the specified
supplemental data format type, or <code>NULL</code>  for unknown types.
</p></dd></dl>

<a name="gnutls_005fsupplemental_005frecv-1"></a>
<h4 class="subheading">gnutls_supplemental_recv</h4>
<a name="gnutls_005fsupplemental_005frecv"></a><dl>
<dt><a name="index-gnutls_005fsupplemental_005frecv"></a>Function: <em>void</em> <strong>gnutls_supplemental_recv</strong> <em>(gnutls_session_t <var>session</var>, unsigned <var>do_recv_supplemental</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>do_recv_supplemental</var>: non-zero in order to expect supplemental data
</p>
<p>This function is to be called by an extension handler to
instruct gnutls to attempt to receive supplemental data
during the handshake process.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<a name="gnutls_005fsupplemental_005fregister-1"></a>
<h4 class="subheading">gnutls_supplemental_register</h4>
<a name="gnutls_005fsupplemental_005fregister"></a><dl>
<dt><a name="index-gnutls_005fsupplemental_005fregister"></a>Function: <em>int</em> <strong>gnutls_supplemental_register</strong> <em>(const char * <var>name</var>, gnutls_supplemental_data_format_type_t <var>type</var>, gnutls_supp_recv_func <var>recv_func</var>, gnutls_supp_send_func <var>send_func</var>)</em></dt>
<dd><p><var>name</var>: the name of the supplemental data to register
</p>
<p><var>type</var>: the type of the supplemental data format
</p>
<p><var>recv_func</var>: the function to receive the data
</p>
<p><var>send_func</var>: the function to send the data
</p>
<p>This function will register a new supplemental data type (rfc4680).
The registered data will remain until <code>gnutls_global_deinit()</code> 
is called. The provided  <code>type</code> must be an unassigned type in
<code>gnutls_supplemental_data_format_type_t</code> . If the type is already
registered or handled by GnuTLS internally <code>GNUTLS_E_ALREADY_REGISTERED</code> 
will be returned.
</p>
<p>This function is not thread safe.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<a name="gnutls_005fsupplemental_005fsend-1"></a>
<h4 class="subheading">gnutls_supplemental_send</h4>
<a name="gnutls_005fsupplemental_005fsend"></a><dl>
<dt><a name="index-gnutls_005fsupplemental_005fsend"></a>Function: <em>void</em> <strong>gnutls_supplemental_send</strong> <em>(gnutls_session_t <var>session</var>, unsigned <var>do_send_supplemental</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>do_send_supplemental</var>: &ndash; undescribed &ndash;
</p>
<p>This function is to be called by an extension handler to
instruct gnutls to send supplemental data during the handshake process.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<a name="gnutls_005fsystem_005frecv_005ftimeout-1"></a>
<h4 class="subheading">gnutls_system_recv_timeout</h4>
<a name="gnutls_005fsystem_005frecv_005ftimeout"></a><dl>
<dt><a name="index-gnutls_005fsystem_005frecv_005ftimeout"></a>Function: <em>int</em> <strong>gnutls_system_recv_timeout</strong> <em>(gnutls_transport_ptr_t <var>ptr</var>, unsigned int <var>ms</var>)</em></dt>
<dd><p><var>ptr</var>: A gnutls_transport_ptr_t pointer
</p>
<p><var>ms</var>: The number of milliseconds to wait.
</p>
<p>Wait for data to be received from the provided socket ( <code>ptr</code> ) within a
timeout period in milliseconds, using <code>select()</code>  on the provided  <code>ptr</code> .
</p>
<p>This function is provided as a helper for constructing custom
callbacks for <code>gnutls_transport_set_pull_timeout_function()</code> ,
which can be used if you rely on socket file descriptors.
</p>
<p>Returns -1 on error, 0 on timeout, positive value if data are available for reading.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<a name="gnutls_005ftdb_005fdeinit-1"></a>
<h4 class="subheading">gnutls_tdb_deinit</h4>
<a name="gnutls_005ftdb_005fdeinit"></a><dl>
<dt><a name="index-gnutls_005ftdb_005fdeinit"></a>Function: <em>void</em> <strong>gnutls_tdb_deinit</strong> <em>(gnutls_tdb_t <var>tdb</var>)</em></dt>
<dd><p><var>tdb</var>: The structure to be deinitialized
</p>
<p>This function will deinitialize a public key trust storage structure.
</p></dd></dl>

<a name="gnutls_005ftdb_005finit-1"></a>
<h4 class="subheading">gnutls_tdb_init</h4>
<a name="gnutls_005ftdb_005finit"></a><dl>
<dt><a name="index-gnutls_005ftdb_005finit"></a>Function: <em>int</em> <strong>gnutls_tdb_init</strong> <em>(gnutls_tdb_t * <var>tdb</var>)</em></dt>
<dd><p><var>tdb</var>: A pointer to the type to be initialized
</p>
<p>This function will initialize a public key trust storage structure.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005ftdb_005fset_005fstore_005fcommitment_005ffunc-1"></a>
<h4 class="subheading">gnutls_tdb_set_store_commitment_func</h4>
<a name="gnutls_005ftdb_005fset_005fstore_005fcommitment_005ffunc"></a><dl>
<dt><a name="index-gnutls_005ftdb_005fset_005fstore_005fcommitment_005ffunc"></a>Function: <em>void</em> <strong>gnutls_tdb_set_store_commitment_func</strong> <em>(gnutls_tdb_t <var>tdb</var>, gnutls_tdb_store_commitment_func        <var>cstore</var>)</em></dt>
<dd><p><var>tdb</var>: The trust storage
</p>
<p><var>cstore</var>: The commitment storage function
</p>
<p>This function will associate a commitment (hash) storage function with the
trust storage structure. The function is of the following form.
</p>
<p>int gnutls_tdb_store_commitment_func(const char* db_name, const char* host,
const char* service, time_t expiration,
gnutls_digest_algorithm_t, const gnutls_datum_t* hash);
</p>
<p>The  <code>db_name</code> should be used to pass any private data to this function.
</p></dd></dl>

<a name="gnutls_005ftdb_005fset_005fstore_005ffunc-1"></a>
<h4 class="subheading">gnutls_tdb_set_store_func</h4>
<a name="gnutls_005ftdb_005fset_005fstore_005ffunc"></a><dl>
<dt><a name="index-gnutls_005ftdb_005fset_005fstore_005ffunc"></a>Function: <em>void</em> <strong>gnutls_tdb_set_store_func</strong> <em>(gnutls_tdb_t <var>tdb</var>, gnutls_tdb_store_func <var>store</var>)</em></dt>
<dd><p><var>tdb</var>: The trust storage
</p>
<p><var>store</var>: The storage function
</p>
<p>This function will associate a storage function with the
trust storage structure. The function is of the following form.
</p>
<p>int gnutls_tdb_store_func(const char* db_name, const char* host,
const char* service, time_t expiration,
const gnutls_datum_t* pubkey);
</p>
<p>The  <code>db_name</code> should be used to pass any private data to this function.
</p></dd></dl>

<a name="gnutls_005ftdb_005fset_005fverify_005ffunc-1"></a>
<h4 class="subheading">gnutls_tdb_set_verify_func</h4>
<a name="gnutls_005ftdb_005fset_005fverify_005ffunc"></a><dl>
<dt><a name="index-gnutls_005ftdb_005fset_005fverify_005ffunc"></a>Function: <em>void</em> <strong>gnutls_tdb_set_verify_func</strong> <em>(gnutls_tdb_t <var>tdb</var>, gnutls_tdb_verify_func <var>verify</var>)</em></dt>
<dd><p><var>tdb</var>: The trust storage
</p>
<p><var>verify</var>: The verification function
</p>
<p>This function will associate a retrieval function with the
trust storage structure. The function is of the following form.
</p>
<p>int gnutls_tdb_verify_func(const char* db_name, const char* host,
const char* service, const gnutls_datum_t* pubkey);
</p>
<p>The verify function should return zero on a match, <code>GNUTLS_E_CERTIFICATE_KEY_MISMATCH</code> 
if there is a mismatch and any other negative error code otherwise.
</p>
<p>The  <code>db_name</code> should be used to pass any private data to this function.
</p></dd></dl>

<a name="gnutls_005ftransport_005fget_005fint-1"></a>
<h4 class="subheading">gnutls_transport_get_int</h4>
<a name="gnutls_005ftransport_005fget_005fint"></a><dl>
<dt><a name="index-gnutls_005ftransport_005fget_005fint"></a>Function: <em>int</em> <strong>gnutls_transport_get_int</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Used to get the first argument of the transport function (like
PUSH and PULL).  This must have been set using
<code>gnutls_transport_set_int()</code> .
</p>
<p><strong>Returns:</strong> The first argument of the transport function.
</p>
<p><strong>Since:</strong> 3.1.9
</p></dd></dl>

<a name="gnutls_005ftransport_005fget_005fint2-1"></a>
<h4 class="subheading">gnutls_transport_get_int2</h4>
<a name="gnutls_005ftransport_005fget_005fint2"></a><dl>
<dt><a name="index-gnutls_005ftransport_005fget_005fint2"></a>Function: <em>void</em> <strong>gnutls_transport_get_int2</strong> <em>(gnutls_session_t <var>session</var>, int * <var>recv_int</var>, int * <var>send_int</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>recv_int</var>: will hold the value for the pull function
</p>
<p><var>send_int</var>: will hold the value for the push function
</p>
<p>Used to get the arguments of the transport functions (like PUSH
and PULL).  These should have been set using
<code>gnutls_transport_set_int2()</code> .
</p>
<p><strong>Since:</strong> 3.1.9
</p></dd></dl>

<a name="gnutls_005ftransport_005fget_005fptr-1"></a>
<h4 class="subheading">gnutls_transport_get_ptr</h4>
<a name="gnutls_005ftransport_005fget_005fptr"></a><dl>
<dt><a name="index-gnutls_005ftransport_005fget_005fptr"></a>Function: <em>gnutls_transport_ptr_t</em> <strong>gnutls_transport_get_ptr</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Used to get the first argument of the transport function (like
PUSH and PULL).  This must have been set using
<code>gnutls_transport_set_ptr()</code> .
</p>
<p><strong>Returns:</strong> The first argument of the transport function.
</p></dd></dl>

<a name="gnutls_005ftransport_005fget_005fptr2-1"></a>
<h4 class="subheading">gnutls_transport_get_ptr2</h4>
<a name="gnutls_005ftransport_005fget_005fptr2"></a><dl>
<dt><a name="index-gnutls_005ftransport_005fget_005fptr2"></a>Function: <em>void</em> <strong>gnutls_transport_get_ptr2</strong> <em>(gnutls_session_t <var>session</var>, gnutls_transport_ptr_t * <var>recv_ptr</var>, gnutls_transport_ptr_t * <var>send_ptr</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>recv_ptr</var>: will hold the value for the pull function
</p>
<p><var>send_ptr</var>: will hold the value for the push function
</p>
<p>Used to get the arguments of the transport functions (like PUSH
and PULL).  These should have been set using
<code>gnutls_transport_set_ptr2()</code> .
</p></dd></dl>

<a name="gnutls_005ftransport_005fset_005ferrno-1"></a>
<h4 class="subheading">gnutls_transport_set_errno</h4>
<a name="gnutls_005ftransport_005fset_005ferrno"></a><dl>
<dt><a name="index-gnutls_005ftransport_005fset_005ferrno-1"></a>Function: <em>void</em> <strong>gnutls_transport_set_errno</strong> <em>(gnutls_session_t <var>session</var>, int <var>err</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>err</var>: error value to store in session-specific errno variable.
</p>
<p>Store  <code>err</code> in the session-specific errno variable.  Useful values
for  <code>err</code> are EINTR, EAGAIN and EMSGSIZE, other values are treated will be
treated as real errors in the push/pull function.
</p>
<p>This function is useful in replacement push and pull functions set by
<code>gnutls_transport_set_push_function()</code>  and
<code>gnutls_transport_set_pull_function()</code>  under Windows, where the
replacements may not have access to the same  <code>errno</code> variable that is used by GnuTLS (e.g., the application is linked to
msvcr71.dll and gnutls is linked to msvcrt.dll).
</p></dd></dl>

<a name="gnutls_005ftransport_005fset_005ferrno_005ffunction-1"></a>
<h4 class="subheading">gnutls_transport_set_errno_function</h4>
<a name="gnutls_005ftransport_005fset_005ferrno_005ffunction"></a><dl>
<dt><a name="index-gnutls_005ftransport_005fset_005ferrno_005ffunction"></a>Function: <em>void</em> <strong>gnutls_transport_set_errno_function</strong> <em>(gnutls_session_t <var>session</var>, gnutls_errno_func <var>errno_func</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>errno_func</var>: a callback function similar to <code>write()</code> 
</p>
<p>This is the function where you set a function to retrieve errno
after a failed push or pull operation.
</p>
<p><code>errno_func</code> is of the form,
int (*gnutls_errno_func)(gnutls_transport_ptr_t);
and should return the errno.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<a name="gnutls_005ftransport_005fset_005fint-1"></a>
<h4 class="subheading">gnutls_transport_set_int</h4>
<a name="gnutls_005ftransport_005fset_005fint"></a><dl>
<dt><a name="index-gnutls_005ftransport_005fset_005fint"></a>Function: <em>void</em> <strong>gnutls_transport_set_int</strong> <em>(gnutls_session_t <var>session</var>, int <var>fd</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>fd</var>: is the socket descriptor for the connection.
</p>
<p>This function sets the first argument of the transport function, such
as <code>send()</code>  and <code>recv()</code>  for the default callbacks using the
system&rsquo;s socket API.
</p>
<p>This function is equivalent to calling <code>gnutls_transport_set_ptr()</code> 
with the descriptor, but requires no casts.
</p>
<p><strong>Since:</strong> 3.1.9
</p></dd></dl>

<a name="gnutls_005ftransport_005fset_005fint2-1"></a>
<h4 class="subheading">gnutls_transport_set_int2</h4>
<a name="gnutls_005ftransport_005fset_005fint2"></a><dl>
<dt><a name="index-gnutls_005ftransport_005fset_005fint2"></a>Function: <em>void</em> <strong>gnutls_transport_set_int2</strong> <em>(gnutls_session_t <var>session</var>, int <var>recv_fd</var>, int <var>send_fd</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>recv_fd</var>: is socket descriptor for the pull function
</p>
<p><var>send_fd</var>: is socket descriptor for the push function
</p>
<p>This function sets the first argument of the transport functions,
such as <code>send()</code>  and <code>recv()</code>  for the default callbacks using the
system&rsquo;s socket API. With this function you can set two different
descriptors for receiving and sending.
</p>
<p>This function is equivalent to calling <code>gnutls_transport_set_ptr2()</code> 
with the descriptors, but requires no casts.
</p>
<p><strong>Since:</strong> 3.1.9
</p></dd></dl>

<a name="gnutls_005ftransport_005fset_005fptr-1"></a>
<h4 class="subheading">gnutls_transport_set_ptr</h4>
<a name="gnutls_005ftransport_005fset_005fptr"></a><dl>
<dt><a name="index-gnutls_005ftransport_005fset_005fptr"></a>Function: <em>void</em> <strong>gnutls_transport_set_ptr</strong> <em>(gnutls_session_t <var>session</var>, gnutls_transport_ptr_t <var>ptr</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>ptr</var>: is the value.
</p>
<p>Used to set the first argument of the transport function (for push
and pull callbacks). In berkeley style sockets this function will set the
connection descriptor.
</p></dd></dl>

<a name="gnutls_005ftransport_005fset_005fptr2-1"></a>
<h4 class="subheading">gnutls_transport_set_ptr2</h4>
<a name="gnutls_005ftransport_005fset_005fptr2"></a><dl>
<dt><a name="index-gnutls_005ftransport_005fset_005fptr2"></a>Function: <em>void</em> <strong>gnutls_transport_set_ptr2</strong> <em>(gnutls_session_t <var>session</var>, gnutls_transport_ptr_t <var>recv_ptr</var>, gnutls_transport_ptr_t <var>send_ptr</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>recv_ptr</var>: is the value for the pull function
</p>
<p><var>send_ptr</var>: is the value for the push function
</p>
<p>Used to set the first argument of the transport function (for push
and pull callbacks). In berkeley style sockets this function will set the
connection descriptor.  With this function you can use two different
pointers for receiving and sending.
</p></dd></dl>

<a name="gnutls_005ftransport_005fset_005fpull_005ffunction-1"></a>
<h4 class="subheading">gnutls_transport_set_pull_function</h4>
<a name="gnutls_005ftransport_005fset_005fpull_005ffunction"></a><dl>
<dt><a name="index-gnutls_005ftransport_005fset_005fpull_005ffunction-1"></a>Function: <em>void</em> <strong>gnutls_transport_set_pull_function</strong> <em>(gnutls_session_t <var>session</var>, gnutls_pull_func <var>pull_func</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>pull_func</var>: a callback function similar to <code>read()</code> 
</p>
<p>This is the function where you set a function for gnutls to receive
data.  Normally, if you use berkeley style sockets, do not need to
use this function since the default recv(2) will probably be ok.
The callback should return 0 on connection termination, a positive
number indicating the number of bytes received, and -1 on error.
</p>
<p><code>gnutls_pull_func</code> is of the form,
ssize_t (*gnutls_pull_func)(gnutls_transport_ptr_t, void*, size_t);
</p></dd></dl>

<a name="gnutls_005ftransport_005fset_005fpull_005ftimeout_005ffunction-1"></a>
<h4 class="subheading">gnutls_transport_set_pull_timeout_function</h4>
<a name="gnutls_005ftransport_005fset_005fpull_005ftimeout_005ffunction"></a><dl>
<dt><a name="index-gnutls_005ftransport_005fset_005fpull_005ftimeout_005ffunction-2"></a>Function: <em>void</em> <strong>gnutls_transport_set_pull_timeout_function</strong> <em>(gnutls_session_t <var>session</var>, gnutls_pull_timeout_func <var>func</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>func</var>: a callback function
</p>
<p>This is the function where you set a function for gnutls to know
whether data are ready to be received. It should wait for data a
given time frame in milliseconds. The callback should return 0 on 
timeout, a positive number if data can be received, and -1 on error.
You&rsquo;ll need to override this function if <code>select()</code>  is not suitable
for the provided transport calls.
</p>
<p>As with <code>select()</code> , if the timeout value is zero the callback should return
zero if no data are immediately available. The special value
<code>GNUTLS_INDEFINITE_TIMEOUT</code>  indicates that the callback should wait indefinitely
for data.
</p>
<p><code>gnutls_pull_timeout_func</code> is of the form,
int (*gnutls_pull_timeout_func)(gnutls_transport_ptr_t, unsigned int ms);
</p>
<p>This callback is necessary when <code>gnutls_handshake_set_timeout()</code>  or 
<code>gnutls_record_set_timeout()</code>  are set. It will not be used when 
non-blocking sockets are in use. That is, this function will
not operate when <code>GNUTLS_NONBLOCK</code>  is specified in <code>gnutls_init()</code> , 
or a custom pull function is registered without updating the 
pull timeout function.
</p>
<p>The helper function <code>gnutls_system_recv_timeout()</code>  is provided to
simplify writing callbacks. 
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<a name="gnutls_005ftransport_005fset_005fpush_005ffunction-1"></a>
<h4 class="subheading">gnutls_transport_set_push_function</h4>
<a name="gnutls_005ftransport_005fset_005fpush_005ffunction"></a><dl>
<dt><a name="index-gnutls_005ftransport_005fset_005fpush_005ffunction-1"></a>Function: <em>void</em> <strong>gnutls_transport_set_push_function</strong> <em>(gnutls_session_t <var>session</var>, gnutls_push_func <var>push_func</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>push_func</var>: a callback function similar to <code>write()</code> 
</p>
<p>This is the function where you set a push function for gnutls to
use in order to send data.  If you are going to use berkeley style
sockets, you do not need to use this function since the default
send(2) will probably be ok.  Otherwise you should specify this
function for gnutls to be able to send data.
The callback should return a positive number indicating the
bytes sent, and -1 on error.
</p>
<p><code>push_func</code> is of the form,
ssize_t (*gnutls_push_func)(gnutls_transport_ptr_t, const void*, size_t);
</p></dd></dl>

<a name="gnutls_005ftransport_005fset_005fvec_005fpush_005ffunction-1"></a>
<h4 class="subheading">gnutls_transport_set_vec_push_function</h4>
<a name="gnutls_005ftransport_005fset_005fvec_005fpush_005ffunction"></a><dl>
<dt><a name="index-gnutls_005ftransport_005fset_005fvec_005fpush_005ffunction-1"></a>Function: <em>void</em> <strong>gnutls_transport_set_vec_push_function</strong> <em>(gnutls_session_t <var>session</var>, gnutls_vec_push_func <var>vec_func</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>vec_func</var>: a callback function similar to <code>writev()</code> 
</p>
<p>Using this function you can override the default writev(2)
function for gnutls to send data. Setting this callback 
instead of <code>gnutls_transport_set_push_function()</code>  is recommended
since it introduces less overhead in the TLS handshake process.
</p>
<p><code>vec_func</code> is of the form,
ssize_t (*gnutls_vec_push_func) (gnutls_transport_ptr_t, const giovec_t * iov, int iovcnt);
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<a name="gnutls_005furl_005fis_005fsupported-1"></a>
<h4 class="subheading">gnutls_url_is_supported</h4>
<a name="gnutls_005furl_005fis_005fsupported"></a><dl>
<dt><a name="index-gnutls_005furl_005fis_005fsupported-1"></a>Function: <em>unsigned</em> <strong>gnutls_url_is_supported</strong> <em>(const char * <var>url</var>)</em></dt>
<dd><p><var>url</var>: A URI to be tested
</p>
<p>Check whether the provided  <code>url</code> is supported.  Depending on the system libraries
GnuTLS may support pkcs11, tpmkey or other URLs.
</p>
<p><strong>Returns:</strong> return non-zero if the given URL is supported, and zero if
it is not known.
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>

<a name="gnutls_005fverify_005fstored_005fpubkey-1"></a>
<h4 class="subheading">gnutls_verify_stored_pubkey</h4>
<a name="gnutls_005fverify_005fstored_005fpubkey"></a><dl>
<dt><a name="index-gnutls_005fverify_005fstored_005fpubkey-1"></a>Function: <em>int</em> <strong>gnutls_verify_stored_pubkey</strong> <em>(const char * <var>db_name</var>, gnutls_tdb_t <var>tdb</var>, const char * <var>host</var>, const char * <var>service</var>, gnutls_certificate_type_t <var>cert_type</var>, const gnutls_datum_t * <var>cert</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>db_name</var>: A file specifying the stored keys (use NULL for the default)
</p>
<p><var>tdb</var>: A storage structure or NULL to use the default
</p>
<p><var>host</var>: The peer&rsquo;s name
</p>
<p><var>service</var>: non-NULL if this key is specific to a service (e.g. http)
</p>
<p><var>cert_type</var>: The type of the certificate
</p>
<p><var>cert</var>: The raw (der) data of the certificate
</p>
<p><var>flags</var>: should be 0.
</p>
<p>This function will try to verify the provided (raw or DER-encoded) certificate 
using a list of stored public keys.  The  <code>service</code> field if non-NULL should
be a port number.
</p>
<p>The  <code>retrieve</code> variable if non-null specifies a custom backend for
the retrieval of entries. If it is NULL then the
default file backend will be used. In POSIX-like systems the
file backend uses the $HOME/.gnutls/known_hosts file.
</p>
<p>Note that if the custom storage backend is provided the
retrieval function should return <code>GNUTLS_E_CERTIFICATE_KEY_MISMATCH</code> 
if the host/service pair is found but key doesn&rsquo;t match,
<code>GNUTLS_E_NO_CERTIFICATE_FOUND</code>  if no such host/service with
the given key is found, and 0 if it was found. The storage
function should return 0 on success.
</p>
<p><strong>Returns:</strong> If no associated public key is found
then <code>GNUTLS_E_NO_CERTIFICATE_FOUND</code>  will be returned. If a key
is found but does not match <code>GNUTLS_E_CERTIFICATE_KEY_MISMATCH</code> 
is returned. On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, 
or a negative error value on other errors.
</p>
<p><strong>Since:</strong> 3.0.13
</p></dd></dl>


<hr>
<div class="header">
<p>
Next: <a href="Datagram-TLS-API.html#Datagram-TLS-API" accesskey="n" rel="next">Datagram TLS API</a>, Up: <a href="API-reference.html#API-reference" accesskey="u" rel="up">API reference</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Function-and-Data-Index.html#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
