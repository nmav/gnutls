<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This manual is last updated 4 March 2015 for version
3.5.4 of GnuTLS.

Copyright (C) 2001-2015 Free Software Foundation, Inc.\\
Copyright (C) 2001-2015 Nikos Mavrogiannopoulos

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled "GNU Free
Documentation License". -->
<!-- Created by GNU Texinfo 6.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>GnuTLS 3.5.4: X509 certificate API</title>

<meta name="description" content="GnuTLS 3.5.4: X509 certificate API">
<meta name="keywords" content="GnuTLS 3.5.4: X509 certificate API">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="Function-and-Data-Index.html#Function-and-Data-Index" rel="index" title="Function and Data Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="API-reference.html#API-reference" rel="up" title="API reference">
<link href="PKCS-7-API.html#PKCS-7-API" rel="next" title="PKCS 7 API">
<link href="Datagram-TLS-API.html#Datagram-TLS-API" rel="prev" title="Datagram TLS API">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
body { 
	margin: 2%;
	padding: 0 5%;
	background: #ffffff;
}
h1,h2,h3,h4,h5 {
    font-weight: bold;
    padding: 5px 5px 5px 5px;
    background-color: #c2e0ff;
    color: #336699;
}
h1 {
    padding: 2em 2em 2em 5%;
    color: white;
    background: #336699;
    text-align: center;
    letter-spacing: 3px;
}
h2 { text-decoration: underline; }
pre {
  margin: 0 5%;
  padding: 0.5em;
}
pre.example,pre.verbatim {
  padding-bottom: 1em;

  border: solid #c2e0ff;
  background: #f0faff;
  border-width: 1px 1px 1px 5px;
  margin: 1em auto;
  width: 90%;
}

div.node {
  margin: 0 -5% 0 -2%;
  padding: 0.5em 0.5em;
  margin-top: 0.5em;
  margin-bottom: 0.5em;
  font-weight: bold;
}
dd, li {
  padding-top: 0.1em;
  padding-bottom: 0.1em;
}
div.float {

  margin-bottom: 0.5em;
  text-align: center;
}

table {
  text-align: left;
  margin-left:auto;
  margin-right:auto;
  border-spacing: 7px;
  width: 50%;
}

th {
  padding: 0;
  color: #336699;
  background-color: #c2e0ff;
  border: solid #000000;
  border-width: 0px;
  margin: 1em auto;
  text-align: center;
  margin-left:auto;
  margin-right:auto;
}

td {
  padding: 0;
  border: solid #000000;
  background-color: #f0faff;
  border-width: 0px;
  margin: 1em auto;
  text-align: left;
  margin-left:auto;
  margin-right:auto;
  padding-left: 1em;
}

dl {
  text-align: left;
  margin-left:auto;
  margin-right:auto;
  width: 50%;

  padding-left: 1em;
  border: solid #c2e0ff;
  background: #f0faff;
  border-width: 5px 1px 1px 1px;
  margin: 1em auto;
}

-->
</style>


</head>

<body lang="en">
<a name="X509-certificate-API"></a>
<div class="header">
<p>
Next: <a href="PKCS-7-API.html#PKCS-7-API" accesskey="n" rel="next">PKCS 7 API</a>, Previous: <a href="Datagram-TLS-API.html#Datagram-TLS-API" accesskey="p" rel="prev">Datagram TLS API</a>, Up: <a href="API-reference.html#API-reference" accesskey="u" rel="up">API reference</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Function-and-Data-Index.html#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="X_002e509-certificate-API"></a>
<h3 class="section">E.3 <acronym>X.509</acronym> certificate API</h3>
<a name="index-X_002e509-Functions"></a>

<p>The following functions are to be used for <acronym>X.509</acronym> certificate handling.
Their prototypes lie in <samp>gnutls/x509.h</samp>.
</p>

<a name="gnutls_005fcertificate_005fget_005ftrust_005flist-1"></a>
<h4 class="subheading">gnutls_certificate_get_trust_list</h4>
<a name="gnutls_005fcertificate_005fget_005ftrust_005flist"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fget_005ftrust_005flist"></a>Function: <em>void</em> <strong>gnutls_certificate_get_trust_list</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, gnutls_x509_trust_list_t * <var>tlist</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>tlist</var>: Location where to store the trust list.
</p>
<p>Obtains the list of trusted certificates stored in  <code>res</code> and writes a
pointer to it to the location  <code>tlist</code> . The pointer will point to memory
internal to  <code>res</code> , and must not be deinitialized. It will be automatically
deallocated when the  <code>res</code> structure is deinitialized.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<a name="gnutls_005fcertificate_005fset_005ftrust_005flist-1"></a>
<h4 class="subheading">gnutls_certificate_set_trust_list</h4>
<a name="gnutls_005fcertificate_005fset_005ftrust_005flist"></a><dl>
<dt><a name="index-gnutls_005fcertificate_005fset_005ftrust_005flist"></a>Function: <em>void</em> <strong>gnutls_certificate_set_trust_list</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, gnutls_x509_trust_list_t <var>tlist</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>tlist</var>: is a <code>gnutls_x509_trust_list_t</code>  type
</p>
<p><var>flags</var>: must be zero
</p>
<p>This function sets a trust list in the gnutls_certificate_credentials_t type. 
</p>
<p>Note that the  <code>tlist</code> will become part of the credentials 
structure and must not be deallocated. It will be automatically deallocated 
when the  <code>res</code> structure is deinitialized.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  (0) on success, or a negative error code.
</p>
<p><strong>Since:</strong> 3.2.2
</p></dd></dl>

<a name="gnutls_005fpkcs8_005finfo-1"></a>
<h4 class="subheading">gnutls_pkcs8_info</h4>
<a name="gnutls_005fpkcs8_005finfo"></a><dl>
<dt><a name="index-gnutls_005fpkcs8_005finfo"></a>Function: <em>int</em> <strong>gnutls_pkcs8_info</strong> <em>(const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>, unsigned int * <var>schema</var>, unsigned int * <var>cipher</var>, void * <var>salt</var>, unsigned int * <var>salt_size</var>, unsigned int * <var>iter_count</var>, char ** <var>oid</var>)</em></dt>
<dd><p><var>data</var>: Holds the PKCS <code>8</code>  data
</p>
<p><var>format</var>: the format of the PKCS <code>8</code>  data
</p>
<p><var>schema</var>: indicate the schema as one of <code>gnutls_pkcs_encrypt_flags_t</code> 
</p>
<p><var>cipher</var>: the cipher used as <code>gnutls_cipher_algorithm_t</code> 
</p>
<p><var>salt</var>: PBKDF2 salt (if non-NULL then  <code>salt_size</code> initially holds its size)
</p>
<p><var>salt_size</var>: PBKDF2 salt size
</p>
<p><var>iter_count</var>: PBKDF2 iteration count
</p>
<p><var>oid</var>: if non-NULL it will contain an allocated null-terminated variable with the OID
</p>
<p>This function will provide information on the algorithms used
in a particular PKCS <code>8</code>  structure. If the structure algorithms
are unknown the code <code>GNUTLS_E_UNKNOWN_CIPHER_TYPE</code>  will be returned,
and only  <code>oid</code> , will be set. That is,  <code>oid</code> will be set on encrypted PKCS <code>8</code> 
structures whether supported or not. It must be deinitialized using <code>gnutls_free()</code> .
The other variables are only set on supported structures.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_INVALID_REQUEST</code>  if the provided structure isn&rsquo;t encrypted,
<code>GNUTLS_E_UNKNOWN_CIPHER_TYPE</code>  if the structure&rsquo;s encryption isn&rsquo;t supported, or
another negative error code in case of a failure. Zero on success.
</p></dd></dl>

<a name="gnutls_005fpkcs_005fschema_005fget_005fname-1"></a>
<h4 class="subheading">gnutls_pkcs_schema_get_name</h4>
<a name="gnutls_005fpkcs_005fschema_005fget_005fname"></a><dl>
<dt><a name="index-gnutls_005fpkcs_005fschema_005fget_005fname"></a>Function: <em>const char *</em> <strong>gnutls_pkcs_schema_get_name</strong> <em>(unsigned int <var>schema</var>)</em></dt>
<dd><p><var>schema</var>: Holds the PKCS <code>12</code>  or PBES2 schema (<code>gnutls_pkcs_encrypt_flags_t</code> )
</p>
<p>This function will return a human readable description of the
PKCS12 or PBES2 schema.
</p>
<p><strong>Returns:</strong> a constrant string or <code>NULL</code>  on error.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<a name="gnutls_005fpkcs_005fschema_005fget_005foid-1"></a>
<h4 class="subheading">gnutls_pkcs_schema_get_oid</h4>
<a name="gnutls_005fpkcs_005fschema_005fget_005foid"></a><dl>
<dt><a name="index-gnutls_005fpkcs_005fschema_005fget_005foid"></a>Function: <em>const char *</em> <strong>gnutls_pkcs_schema_get_oid</strong> <em>(unsigned int <var>schema</var>)</em></dt>
<dd><p><var>schema</var>: Holds the PKCS <code>12</code>  or PBES2 schema (<code>gnutls_pkcs_encrypt_flags_t</code> )
</p>
<p>This function will return the object identifier of the
PKCS12 or PBES2 schema.
</p>
<p><strong>Returns:</strong> a constrant string or <code>NULL</code>  on error.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<a name="gnutls_005fsubject_005falt_005fnames_005fdeinit-1"></a>
<h4 class="subheading">gnutls_subject_alt_names_deinit</h4>
<a name="gnutls_005fsubject_005falt_005fnames_005fdeinit"></a><dl>
<dt><a name="index-gnutls_005fsubject_005falt_005fnames_005fdeinit"></a>Function: <em>void</em> <strong>gnutls_subject_alt_names_deinit</strong> <em>(gnutls_subject_alt_names_t <var>sans</var>)</em></dt>
<dd><p><var>sans</var>: The alternative names
</p>
<p>This function will deinitialize an alternative names structure.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fsubject_005falt_005fnames_005fget-1"></a>
<h4 class="subheading">gnutls_subject_alt_names_get</h4>
<a name="gnutls_005fsubject_005falt_005fnames_005fget"></a><dl>
<dt><a name="index-gnutls_005fsubject_005falt_005fnames_005fget"></a>Function: <em>int</em> <strong>gnutls_subject_alt_names_get</strong> <em>(gnutls_subject_alt_names_t <var>sans</var>, unsigned int <var>seq</var>, unsigned int * <var>san_type</var>, gnutls_datum_t * <var>san</var>, gnutls_datum_t * <var>othername_oid</var>)</em></dt>
<dd><p><var>sans</var>: The alternative names
</p>
<p><var>seq</var>: The index of the name to get
</p>
<p><var>san_type</var>: Will hold the type of the name (of <code>gnutls_subject_alt_names_t</code> )
</p>
<p><var>san</var>: The alternative name data (should be treated as constant)
</p>
<p><var>othername_oid</var>: The object identifier if  <code>san_type</code> is <code>GNUTLS_SAN_OTHERNAME</code>  (should be treated as constant)
</p>
<p>This function will return a specific alternative name as stored in
the  <code>sans</code> type. The returned values should be treated as constant
and valid for the lifetime of  <code>sans</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
if the index is out of bounds, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fsubject_005falt_005fnames_005finit-1"></a>
<h4 class="subheading">gnutls_subject_alt_names_init</h4>
<a name="gnutls_005fsubject_005falt_005fnames_005finit"></a><dl>
<dt><a name="index-gnutls_005fsubject_005falt_005fnames_005finit"></a>Function: <em>int</em> <strong>gnutls_subject_alt_names_init</strong> <em>(gnutls_subject_alt_names_t * <var>sans</var>)</em></dt>
<dd><p><var>sans</var>: The alternative names
</p>
<p>This function will initialize an alternative names structure.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fsubject_005falt_005fnames_005fset-1"></a>
<h4 class="subheading">gnutls_subject_alt_names_set</h4>
<a name="gnutls_005fsubject_005falt_005fnames_005fset"></a><dl>
<dt><a name="index-gnutls_005fsubject_005falt_005fnames_005fset"></a>Function: <em>int</em> <strong>gnutls_subject_alt_names_set</strong> <em>(gnutls_subject_alt_names_t <var>sans</var>, unsigned int <var>san_type</var>, const gnutls_datum_t * <var>san</var>, const char * <var>othername_oid</var>)</em></dt>
<dd><p><var>sans</var>: The alternative names
</p>
<p><var>san_type</var>: The type of the name (of <code>gnutls_subject_alt_names_t</code> )
</p>
<p><var>san</var>: The alternative name data
</p>
<p><var>othername_oid</var>: The object identifier if  <code>san_type</code> is <code>GNUTLS_SAN_OTHERNAME</code> 
</p>
<p>This function will store the specified alternative name in
the  <code>sans</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0), otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005faia_005fdeinit-1"></a>
<h4 class="subheading">gnutls_x509_aia_deinit</h4>
<a name="gnutls_005fx509_005faia_005fdeinit"></a><dl>
<dt><a name="index-gnutls_005fx509_005faia_005fdeinit"></a>Function: <em>void</em> <strong>gnutls_x509_aia_deinit</strong> <em>(gnutls_x509_aia_t <var>aia</var>)</em></dt>
<dd><p><var>aia</var>: The authority info access
</p>
<p>This function will deinitialize an authority info access type.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005faia_005fget-1"></a>
<h4 class="subheading">gnutls_x509_aia_get</h4>
<a name="gnutls_005fx509_005faia_005fget"></a><dl>
<dt><a name="index-gnutls_005fx509_005faia_005fget"></a>Function: <em>int</em> <strong>gnutls_x509_aia_get</strong> <em>(gnutls_x509_aia_t <var>aia</var>, unsigned int <var>seq</var>, gnutls_datum_t * <var>oid</var>, unsigned * <var>san_type</var>, gnutls_datum_t * <var>san</var>)</em></dt>
<dd><p><var>aia</var>: The authority info access
</p>
<p><var>seq</var>: specifies the sequence number of the access descriptor (0 for the first one, 1 for the second etc.)
</p>
<p><var>oid</var>: the type of available data; to be treated as constant.
</p>
<p><var>san_type</var>: Will hold the type of the name of <code>gnutls_subject_alt_names_t</code>  (may be null).
</p>
<p><var>san</var>: the access location name; to be treated as constant (may be null).
</p>
<p>This function reads from the Authority Information Access type.
</p>
<p>The  <code>seq</code> input parameter is used to indicate which member of the
sequence the caller is interested in.  The first member is 0, the
second member 1 and so on.  When the  <code>seq</code> value is out of bounds,
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  is returned.
</p>
<p>Typically  <code>oid</code> is <code>GNUTLS_OID_AD_CAISSUERS</code>  or <code>GNUTLS_OID_AD_OCSP</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005faia_005finit-1"></a>
<h4 class="subheading">gnutls_x509_aia_init</h4>
<a name="gnutls_005fx509_005faia_005finit"></a><dl>
<dt><a name="index-gnutls_005fx509_005faia_005finit"></a>Function: <em>int</em> <strong>gnutls_x509_aia_init</strong> <em>(gnutls_x509_aia_t * <var>aia</var>)</em></dt>
<dd><p><var>aia</var>: The authority info access
</p>
<p>This function will initialize an authority info access type.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005faia_005fset-1"></a>
<h4 class="subheading">gnutls_x509_aia_set</h4>
<a name="gnutls_005fx509_005faia_005fset"></a><dl>
<dt><a name="index-gnutls_005fx509_005faia_005fset"></a>Function: <em>int</em> <strong>gnutls_x509_aia_set</strong> <em>(gnutls_x509_aia_t <var>aia</var>, const char * <var>oid</var>, unsigned <var>san_type</var>, const gnutls_datum_t * <var>san</var>)</em></dt>
<dd><p><var>aia</var>: The authority info access
</p>
<p><var>oid</var>: the type of data.
</p>
<p><var>san_type</var>: The type of the name (of <code>gnutls_subject_alt_names_t</code> )
</p>
<p><var>san</var>: The alternative name data
</p>
<p>This function will store the specified alternative name in
the  <code>aia</code> type. 
</p>
<p>Typically the value for  <code>oid</code> should be <code>GNUTLS_OID_AD_OCSP</code> , or
<code>GNUTLS_OID_AD_CAISSUERS</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0), otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005faki_005fdeinit-1"></a>
<h4 class="subheading">gnutls_x509_aki_deinit</h4>
<a name="gnutls_005fx509_005faki_005fdeinit"></a><dl>
<dt><a name="index-gnutls_005fx509_005faki_005fdeinit"></a>Function: <em>void</em> <strong>gnutls_x509_aki_deinit</strong> <em>(gnutls_x509_aki_t <var>aki</var>)</em></dt>
<dd><p><var>aki</var>: The authority key identifier type
</p>
<p>This function will deinitialize an authority key identifier.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005faki_005fget_005fcert_005fissuer-1"></a>
<h4 class="subheading">gnutls_x509_aki_get_cert_issuer</h4>
<a name="gnutls_005fx509_005faki_005fget_005fcert_005fissuer"></a><dl>
<dt><a name="index-gnutls_005fx509_005faki_005fget_005fcert_005fissuer"></a>Function: <em>int</em> <strong>gnutls_x509_aki_get_cert_issuer</strong> <em>(gnutls_x509_aki_t <var>aki</var>, unsigned int <var>seq</var>, unsigned int * <var>san_type</var>, gnutls_datum_t * <var>san</var>, gnutls_datum_t * <var>othername_oid</var>, gnutls_datum_t * <var>serial</var>)</em></dt>
<dd><p><var>aki</var>: The authority key ID
</p>
<p><var>seq</var>: The index of the name to get
</p>
<p><var>san_type</var>: Will hold the type of the name (of <code>gnutls_subject_alt_names_t</code> )
</p>
<p><var>san</var>: The alternative name data
</p>
<p><var>othername_oid</var>: The object identifier if  <code>san_type</code> is <code>GNUTLS_SAN_OTHERNAME</code> 
</p>
<p><var>serial</var>: The authorityCertSerialNumber number
</p>
<p>This function will return a specific authorityCertIssuer name as stored in
the  <code>aki</code> type, as well as the authorityCertSerialNumber. All the returned
values should be treated as constant, and may be set to <code>NULL</code>  when are not required.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
if the index is out of bounds, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005faki_005fget_005fid-1"></a>
<h4 class="subheading">gnutls_x509_aki_get_id</h4>
<a name="gnutls_005fx509_005faki_005fget_005fid"></a><dl>
<dt><a name="index-gnutls_005fx509_005faki_005fget_005fid"></a>Function: <em>int</em> <strong>gnutls_x509_aki_get_id</strong> <em>(gnutls_x509_aki_t <var>aki</var>, gnutls_datum_t * <var>id</var>)</em></dt>
<dd><p><var>aki</var>: The authority key ID
</p>
<p><var>id</var>: Will hold the identifier
</p>
<p>This function will return the key identifier as stored in
the  <code>aki</code> type. The identifier should be treated as constant.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
if the index is out of bounds, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005faki_005finit-1"></a>
<h4 class="subheading">gnutls_x509_aki_init</h4>
<a name="gnutls_005fx509_005faki_005finit"></a><dl>
<dt><a name="index-gnutls_005fx509_005faki_005finit"></a>Function: <em>int</em> <strong>gnutls_x509_aki_init</strong> <em>(gnutls_x509_aki_t * <var>aki</var>)</em></dt>
<dd><p><var>aki</var>: The authority key ID type
</p>
<p>This function will initialize an authority key ID.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005faki_005fset_005fcert_005fissuer-1"></a>
<h4 class="subheading">gnutls_x509_aki_set_cert_issuer</h4>
<a name="gnutls_005fx509_005faki_005fset_005fcert_005fissuer"></a><dl>
<dt><a name="index-gnutls_005fx509_005faki_005fset_005fcert_005fissuer"></a>Function: <em>int</em> <strong>gnutls_x509_aki_set_cert_issuer</strong> <em>(gnutls_x509_aki_t <var>aki</var>, unsigned int <var>san_type</var>, const gnutls_datum_t * <var>san</var>, const char * <var>othername_oid</var>, const gnutls_datum_t * <var>serial</var>)</em></dt>
<dd><p><var>aki</var>: The authority key ID
</p>
<p><var>san_type</var>: the type of the name (of <code>gnutls_subject_alt_names_t</code> ), may be null
</p>
<p><var>san</var>: The alternative name data
</p>
<p><var>othername_oid</var>: The object identifier if  <code>san_type</code> is <code>GNUTLS_SAN_OTHERNAME</code> 
</p>
<p><var>serial</var>: The authorityCertSerialNumber number (may be null)
</p>
<p>This function will set the authorityCertIssuer name and the authorityCertSerialNumber 
to be stored in the  <code>aki</code> type. When storing multiple names, the serial
should be set on the first call, and subsequent calls should use a <code>NULL</code>  serial.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005faki_005fset_005fid-1"></a>
<h4 class="subheading">gnutls_x509_aki_set_id</h4>
<a name="gnutls_005fx509_005faki_005fset_005fid"></a><dl>
<dt><a name="index-gnutls_005fx509_005faki_005fset_005fid"></a>Function: <em>int</em> <strong>gnutls_x509_aki_set_id</strong> <em>(gnutls_x509_aki_t <var>aki</var>, const gnutls_datum_t * <var>id</var>)</em></dt>
<dd><p><var>aki</var>: The authority key ID
</p>
<p><var>id</var>: the key identifier
</p>
<p>This function will set the keyIdentifier to be stored in the  <code>aki</code> type.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcidr_005fto_005frfc5280-1"></a>
<h4 class="subheading">gnutls_x509_cidr_to_rfc5280</h4>
<a name="gnutls_005fx509_005fcidr_005fto_005frfc5280"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcidr_005fto_005frfc5280"></a>Function: <em>int</em> <strong>gnutls_x509_cidr_to_rfc5280</strong> <em>(const char * <var>cidr</var>, gnutls_datum_t * <var>cidr_rfc5280</var>)</em></dt>
<dd><p><var>cidr</var>: CIDR in RFC4632 format (IP/prefix), null-terminated
</p>
<p><var>cidr_rfc5280</var>: CIDR range converted to RFC5280 format
</p>
<p>This function will convert text CIDR range with prefix (such as &rsquo;10.0.0.0/8&rsquo;)
to RFC5280 (IP address in network byte order followed by its network mask).
Works for both IPv4 and IPv6.
</p>
<p>The resulting object is directly usable for IP name constraints usage,
for example in functions <code>gnutls_x509_name_constraints_add_permitted</code> 
or <code>gnutls_x509_name_constraints_add_excluded</code> .
</p>
<p>The data in datum needs to be deallocated using <code>gnutls_free()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.5.4
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fcheck_005fissuer-1"></a>
<h4 class="subheading">gnutls_x509_crl_check_issuer</h4>
<a name="gnutls_005fx509_005fcrl_005fcheck_005fissuer"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fcheck_005fissuer"></a>Function: <em>unsigned</em> <strong>gnutls_x509_crl_check_issuer</strong> <em>(gnutls_x509_crl_t <var>crl</var>, gnutls_x509_crt_t <var>issuer</var>)</em></dt>
<dd><p><var>crl</var>: is the CRL to be checked
</p>
<p><var>issuer</var>: is the certificate of a possible issuer
</p>
<p>This function will check if the given CRL was issued by the given
issuer certificate.  
</p>
<p><strong>Returns:</strong> true (1) if the given CRL was issued by the given issuer, 
and false (0) if not.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fdeinit-1"></a>
<h4 class="subheading">gnutls_x509_crl_deinit</h4>
<a name="gnutls_005fx509_005fcrl_005fdeinit"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fdeinit"></a>Function: <em>void</em> <strong>gnutls_x509_crl_deinit</strong> <em>(gnutls_x509_crl_t <var>crl</var>)</em></dt>
<dd><p><var>crl</var>: The data to be deinitialized
</p>
<p>This function will deinitialize a CRL structure.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fdist_005fpoints_005fdeinit-1"></a>
<h4 class="subheading">gnutls_x509_crl_dist_points_deinit</h4>
<a name="gnutls_005fx509_005fcrl_005fdist_005fpoints_005fdeinit"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fdist_005fpoints_005fdeinit"></a>Function: <em>void</em> <strong>gnutls_x509_crl_dist_points_deinit</strong> <em>(gnutls_x509_crl_dist_points_t <var>cdp</var>)</em></dt>
<dd><p><var>cdp</var>: The CRL distribution points
</p>
<p>This function will deinitialize a CRL distribution points type.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fdist_005fpoints_005fget-1"></a>
<h4 class="subheading">gnutls_x509_crl_dist_points_get</h4>
<a name="gnutls_005fx509_005fcrl_005fdist_005fpoints_005fget"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fdist_005fpoints_005fget"></a>Function: <em>int</em> <strong>gnutls_x509_crl_dist_points_get</strong> <em>(gnutls_x509_crl_dist_points_t <var>cdp</var>, unsigned int <var>seq</var>, unsigned int * <var>type</var>, gnutls_datum_t * <var>san</var>, unsigned int * <var>reasons</var>)</em></dt>
<dd><p><var>cdp</var>: The CRL distribution points
</p>
<p><var>seq</var>: specifies the sequence number of the distribution point (0 for the first one, 1 for the second etc.)
</p>
<p><var>type</var>: The name type of the corresponding name (gnutls_x509_subject_alt_name_t)
</p>
<p><var>san</var>: The distribution point names (to be treated as constant)
</p>
<p><var>reasons</var>: Revocation reasons. An ORed sequence of flags from <code>gnutls_x509_crl_reason_flags_t</code> .
</p>
<p>This function retrieves the individual CRL distribution points (2.5.29.31),
contained in provided type. 
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
if the index is out of bounds, otherwise a negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fdist_005fpoints_005finit-1"></a>
<h4 class="subheading">gnutls_x509_crl_dist_points_init</h4>
<a name="gnutls_005fx509_005fcrl_005fdist_005fpoints_005finit"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fdist_005fpoints_005finit"></a>Function: <em>int</em> <strong>gnutls_x509_crl_dist_points_init</strong> <em>(gnutls_x509_crl_dist_points_t * <var>cdp</var>)</em></dt>
<dd><p><var>cdp</var>: The CRL distribution points
</p>
<p>This function will initialize a CRL distribution points type.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fdist_005fpoints_005fset-1"></a>
<h4 class="subheading">gnutls_x509_crl_dist_points_set</h4>
<a name="gnutls_005fx509_005fcrl_005fdist_005fpoints_005fset"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fdist_005fpoints_005fset"></a>Function: <em>int</em> <strong>gnutls_x509_crl_dist_points_set</strong> <em>(gnutls_x509_crl_dist_points_t <var>cdp</var>, gnutls_x509_subject_alt_name_t <var>type</var>, const gnutls_datum_t * <var>san</var>, unsigned int <var>reasons</var>)</em></dt>
<dd><p><var>cdp</var>: The CRL distribution points
</p>
<p><var>type</var>: The type of the name (of <code>gnutls_subject_alt_names_t</code> )
</p>
<p><var>san</var>: The point name data
</p>
<p><var>reasons</var>: Revocation reasons. An ORed sequence of flags from <code>gnutls_x509_crl_reason_flags_t</code> .
</p>
<p>This function will store the specified CRL distribution point value
the  <code>cdp</code> type.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0), otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fexport-1"></a>
<h4 class="subheading">gnutls_x509_crl_export</h4>
<a name="gnutls_005fx509_005fcrl_005fexport"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fexport"></a>Function: <em>int</em> <strong>gnutls_x509_crl_export</strong> <em>(gnutls_x509_crl_t <var>crl</var>, gnutls_x509_crt_fmt_t <var>format</var>, void * <var>output_data</var>, size_t * <var>output_data_size</var>)</em></dt>
<dd><p><var>crl</var>: Holds the revocation list
</p>
<p><var>format</var>: the format of output params. One of PEM or DER.
</p>
<p><var>output_data</var>: will contain a private key PEM or DER encoded
</p>
<p><var>output_data_size</var>: holds the size of output_data (and will
be replaced by the actual size of parameters)
</p>
<p>This function will export the revocation list to DER or PEM format.
</p>
<p>If the buffer provided is not long enough to hold the output, then
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  will be returned.
</p>
<p>If the structure is PEM encoded, it will have a header
of &quot;BEGIN X509 CRL&quot;.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fexport2-1"></a>
<h4 class="subheading">gnutls_x509_crl_export2</h4>
<a name="gnutls_005fx509_005fcrl_005fexport2"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fexport2"></a>Function: <em>int</em> <strong>gnutls_x509_crl_export2</strong> <em>(gnutls_x509_crl_t <var>crl</var>, gnutls_x509_crt_fmt_t <var>format</var>, gnutls_datum_t * <var>out</var>)</em></dt>
<dd><p><var>crl</var>: Holds the revocation list
</p>
<p><var>format</var>: the format of output params. One of PEM or DER.
</p>
<p><var>out</var>: will contain a private key PEM or DER encoded
</p>
<p>This function will export the revocation list to DER or PEM format.
</p>
<p>The output buffer is allocated using <code>gnutls_malloc()</code> .
</p>
<p>If the structure is PEM encoded, it will have a header
of &quot;BEGIN X509 CRL&quot;.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p>Since 3.1.3
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fget_005fauthority_005fkey_005fgn_005fserial-1"></a>
<h4 class="subheading">gnutls_x509_crl_get_authority_key_gn_serial</h4>
<a name="gnutls_005fx509_005fcrl_005fget_005fauthority_005fkey_005fgn_005fserial"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fget_005fauthority_005fkey_005fgn_005fserial"></a>Function: <em>int</em> <strong>gnutls_x509_crl_get_authority_key_gn_serial</strong> <em>(gnutls_x509_crl_t <var>crl</var>, unsigned int <var>seq</var>, void * <var>alt</var>, size_t * <var>alt_size</var>, unsigned int * <var>alt_type</var>, void * <var>serial</var>, size_t * <var>serial_size</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code>  type
</p>
<p><var>seq</var>: specifies the sequence number of the alt name (0 for the first one, 1 for the second etc.)
</p>
<p><var>alt</var>: is the place where the alternative name will be copied to
</p>
<p><var>alt_size</var>: holds the size of alt.
</p>
<p><var>alt_type</var>: holds the type of the alternative name (one of gnutls_x509_subject_alt_name_t).
</p>
<p><var>serial</var>: buffer to store the serial number (may be null)
</p>
<p><var>serial_size</var>: Holds the size of the serial field (may be null)
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical (may be null)
</p>
<p>This function will return the X.509 authority key
identifier when stored as a general name (authorityCertIssuer) 
and serial number.
</p>
<p>Because more than one general names might be stored
 <code>seq</code> can be used as a counter to request them all until 
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  is returned.
</p>
<p><strong>Returns:</strong> Returns 0 on success, or an error code.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fget_005fauthority_005fkey_005fid-1"></a>
<h4 class="subheading">gnutls_x509_crl_get_authority_key_id</h4>
<a name="gnutls_005fx509_005fcrl_005fget_005fauthority_005fkey_005fid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fget_005fauthority_005fkey_005fid"></a>Function: <em>int</em> <strong>gnutls_x509_crl_get_authority_key_id</strong> <em>(gnutls_x509_crl_t <var>crl</var>, void * <var>id</var>, size_t * <var>id_size</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code>  type
</p>
<p><var>id</var>: The place where the identifier will be copied
</p>
<p><var>id_size</var>: Holds the size of the result field.
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical
(may be null)
</p>
<p>This function will return the CRL authority&rsquo;s key identifier.  This
is obtained by the X.509 Authority Key identifier extension field
(2.5.29.35).  Note that this function 
only returns the keyIdentifier field of the extension and
<code>GNUTLS_E_X509_UNSUPPORTED_EXTENSION</code> , if the extension contains
the name and serial number of the certificate. In that case
<code>gnutls_x509_crl_get_authority_key_gn_serial()</code>  may be used.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code in case of an error.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fget_005fcrt_005fcount-1"></a>
<h4 class="subheading">gnutls_x509_crl_get_crt_count</h4>
<a name="gnutls_005fx509_005fcrl_005fget_005fcrt_005fcount"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fget_005fcrt_005fcount"></a>Function: <em>int</em> <strong>gnutls_x509_crl_get_crt_count</strong> <em>(gnutls_x509_crl_t <var>crl</var>)</em></dt>
<dd><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code>  type
</p>
<p>This function will return the number of revoked certificates in the
given CRL.
</p>
<p><strong>Returns:</strong> number of certificates, a negative error code on failure.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fget_005fcrt_005fserial-1"></a>
<h4 class="subheading">gnutls_x509_crl_get_crt_serial</h4>
<a name="gnutls_005fx509_005fcrl_005fget_005fcrt_005fserial"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fget_005fcrt_005fserial-1"></a>Function: <em>int</em> <strong>gnutls_x509_crl_get_crt_serial</strong> <em>(gnutls_x509_crl_t <var>crl</var>, unsigned <var>indx</var>, unsigned char * <var>serial</var>, size_t * <var>serial_size</var>, time_t * <var>t</var>)</em></dt>
<dd><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code>  type
</p>
<p><var>indx</var>: the index of the certificate to extract (starting from 0)
</p>
<p><var>serial</var>: where the serial number will be copied
</p>
<p><var>serial_size</var>: initially holds the size of serial
</p>
<p><var>t</var>: if non null, will hold the time this certificate was revoked
</p>
<p>This function will retrieve the serial number of the specified, by
the index, revoked certificate.
</p>
<p>Note that this function will have performance issues in large sequences
of revoked certificates. In that case use <code>gnutls_x509_crl_iter_crt_serial()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fget_005fdn_005foid-1"></a>
<h4 class="subheading">gnutls_x509_crl_get_dn_oid</h4>
<a name="gnutls_005fx509_005fcrl_005fget_005fdn_005foid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fget_005fdn_005foid"></a>Function: <em>int</em> <strong>gnutls_x509_crl_get_dn_oid</strong> <em>(gnutls_x509_crl_t <var>crl</var>, unsigned <var>indx</var>, void * <var>oid</var>, size_t * <var>sizeof_oid</var>)</em></dt>
<dd><p><var>crl</var>: should contain a gnutls_x509_crl_t type
</p>
<p><var>indx</var>: Specifies which DN OID to send. Use (0) to get the first one.
</p>
<p><var>oid</var>: a pointer to store the OID (may be null)
</p>
<p><var>sizeof_oid</var>: initially holds the size of &rsquo;oid&rsquo;
</p>
<p>This function will extract the requested OID of the name of the CRL
issuer, specified by the given index.
</p>
<p>If oid is null then only the size will be filled.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the provided buffer is
not long enough, and in that case the sizeof_oid will be updated
with the required size.  On success 0 is returned.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fget_005fextension_005fdata-1"></a>
<h4 class="subheading">gnutls_x509_crl_get_extension_data</h4>
<a name="gnutls_005fx509_005fcrl_005fget_005fextension_005fdata"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fget_005fextension_005fdata"></a>Function: <em>int</em> <strong>gnutls_x509_crl_get_extension_data</strong> <em>(gnutls_x509_crl_t <var>crl</var>, unsigned <var>indx</var>, void * <var>data</var>, size_t * <var>sizeof_data</var>)</em></dt>
<dd><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code>  type
</p>
<p><var>indx</var>: Specifies which extension OID to send. Use (0) to get the first one.
</p>
<p><var>data</var>: a pointer to a structure to hold the data (may be null)
</p>
<p><var>sizeof_data</var>: initially holds the size of  <code>oid</code> 
</p>
<p>This function will return the requested extension data in the CRL.
The extension data will be stored as a string in the provided
buffer.
</p>
<p>Use <code>gnutls_x509_crl_get_extension_info()</code>  to extract the OID and
critical flag.  Use <code>gnutls_x509_crl_get_extension_info()</code>  instead,
if you want to get data indexed by the extension OID rather than
sequence.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code in case of an error.  If your have reached the
last extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
will be returned.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fget_005fextension_005fdata2-1"></a>
<h4 class="subheading">gnutls_x509_crl_get_extension_data2</h4>
<a name="gnutls_005fx509_005fcrl_005fget_005fextension_005fdata2"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fget_005fextension_005fdata2"></a>Function: <em>int</em> <strong>gnutls_x509_crl_get_extension_data2</strong> <em>(gnutls_x509_crl_t <var>crl</var>, unsigned <var>indx</var>, gnutls_datum_t * <var>data</var>)</em></dt>
<dd><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code>  type
</p>
<p><var>indx</var>: Specifies which extension OID to read. Use (0) to get the first one.
</p>
<p><var>data</var>: will contain the extension DER-encoded data
</p>
<p>This function will return the requested by the index extension data in the
certificate revocation list.  The extension data will be allocated using
<code>gnutls_malloc()</code> .
</p>
<p>Use <code>gnutls_x509_crt_get_extension_info()</code>  to extract the OID.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.  If you have reached the
last extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
will be returned.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fget_005fextension_005finfo-1"></a>
<h4 class="subheading">gnutls_x509_crl_get_extension_info</h4>
<a name="gnutls_005fx509_005fcrl_005fget_005fextension_005finfo"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fget_005fextension_005finfo"></a>Function: <em>int</em> <strong>gnutls_x509_crl_get_extension_info</strong> <em>(gnutls_x509_crl_t <var>crl</var>, unsigned <var>indx</var>, void * <var>oid</var>, size_t * <var>sizeof_oid</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code>  type
</p>
<p><var>indx</var>: Specifies which extension OID to send, use (0) to get the first one.
</p>
<p><var>oid</var>: a pointer to store the OID
</p>
<p><var>sizeof_oid</var>: initially holds the maximum size of  <code>oid</code> , on return
holds actual size of  <code>oid</code> .
</p>
<p><var>critical</var>: output variable with critical flag, may be NULL.
</p>
<p>This function will return the requested extension OID in the CRL,
and the critical flag for it.  The extension OID will be stored as
a string in the provided buffer.  Use
<code>gnutls_x509_crl_get_extension_data()</code>  to extract the data.
</p>
<p>If the buffer provided is not long enough to hold the output, then
* <code>sizeof_oid</code> is updated and <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  will be
returned.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code in case of an error.  If your have reached the
last extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
will be returned.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fget_005fextension_005foid-1"></a>
<h4 class="subheading">gnutls_x509_crl_get_extension_oid</h4>
<a name="gnutls_005fx509_005fcrl_005fget_005fextension_005foid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fget_005fextension_005foid"></a>Function: <em>int</em> <strong>gnutls_x509_crl_get_extension_oid</strong> <em>(gnutls_x509_crl_t <var>crl</var>, unsigned <var>indx</var>, void * <var>oid</var>, size_t * <var>sizeof_oid</var>)</em></dt>
<dd><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code>  type
</p>
<p><var>indx</var>: Specifies which extension OID to send, use (0) to get the first one.
</p>
<p><var>oid</var>: a pointer to store the OID (may be null)
</p>
<p><var>sizeof_oid</var>: initially holds the size of  <code>oid</code> 
</p>
<p>This function will return the requested extension OID in the CRL.
The extension OID will be stored as a string in the provided
buffer.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code in case of an error.  If your have reached the
last extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
will be returned.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fget_005fissuer_005fdn-1"></a>
<h4 class="subheading">gnutls_x509_crl_get_issuer_dn</h4>
<a name="gnutls_005fx509_005fcrl_005fget_005fissuer_005fdn"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fget_005fissuer_005fdn"></a>Function: <em>int</em> <strong>gnutls_x509_crl_get_issuer_dn</strong> <em>(const gnutls_x509_crl_t <var>crl</var>, char * <var>buf</var>, size_t * <var>sizeof_buf</var>)</em></dt>
<dd><p><var>crl</var>: should contain a gnutls_x509_crl_t type
</p>
<p><var>buf</var>: a pointer to a structure to hold the peer&rsquo;s name (may be null)
</p>
<p><var>sizeof_buf</var>: initially holds the size of  <code>buf</code> 
</p>
<p>This function will copy the name of the CRL issuer in the provided
buffer. The name will be in the form &quot;C=xxxx,O=yyyy,CN=zzzz&quot; as
described in RFC4514. The output string will be ASCII or UTF-8
encoded, depending on the certificate data.
</p>
<p>If buf is <code>NULL</code>  then only the size will be filled.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the provided buffer is
not long enough, and in that case the sizeof_buf will be updated
with the required size, and 0 on success.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fget_005fissuer_005fdn2-1"></a>
<h4 class="subheading">gnutls_x509_crl_get_issuer_dn2</h4>
<a name="gnutls_005fx509_005fcrl_005fget_005fissuer_005fdn2"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fget_005fissuer_005fdn2"></a>Function: <em>int</em> <strong>gnutls_x509_crl_get_issuer_dn2</strong> <em>(gnutls_x509_crl_t <var>crl</var>, gnutls_datum_t * <var>dn</var>)</em></dt>
<dd><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code>  type
</p>
<p><var>dn</var>: a pointer to a structure to hold the name
</p>
<p>This function will allocate buffer and copy the name of the CRL issuer.
The name will be in the form &quot;C=xxxx,O=yyyy,CN=zzzz&quot; as
described in RFC4514. The output string will be ASCII or UTF-8
encoded, depending on the certificate data.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.10
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fget_005fissuer_005fdn_005fby_005foid-1"></a>
<h4 class="subheading">gnutls_x509_crl_get_issuer_dn_by_oid</h4>
<a name="gnutls_005fx509_005fcrl_005fget_005fissuer_005fdn_005fby_005foid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fget_005fissuer_005fdn_005fby_005foid"></a>Function: <em>int</em> <strong>gnutls_x509_crl_get_issuer_dn_by_oid</strong> <em>(gnutls_x509_crl_t <var>crl</var>, const char * <var>oid</var>, unsigned <var>indx</var>, unsigned int <var>raw_flag</var>, void * <var>buf</var>, size_t * <var>sizeof_buf</var>)</em></dt>
<dd><p><var>crl</var>: should contain a gnutls_x509_crl_t type
</p>
<p><var>oid</var>: holds an Object Identified in null terminated string
</p>
<p><var>indx</var>: In case multiple same OIDs exist in the RDN, this specifies which to send. Use (0) to get the first one.
</p>
<p><var>raw_flag</var>: If non-zero returns the raw DER data of the DN part.
</p>
<p><var>buf</var>: a pointer to a structure to hold the peer&rsquo;s name (may be null)
</p>
<p><var>sizeof_buf</var>: initially holds the size of  <code>buf</code> 
</p>
<p>This function will extract the part of the name of the CRL issuer
specified by the given OID. The output will be encoded as described
in RFC4514. The output string will be ASCII or UTF-8 encoded,
depending on the certificate data.
</p>
<p>Some helper macros with popular OIDs can be found in gnutls/x509.h
If raw flag is (0), this function will only return known OIDs as
text. Other OIDs will be DER encoded, as described in RFC4514 &ndash; in
hex format with a &rsquo;#&rsquo; prefix.  You can check about known OIDs
using <code>gnutls_x509_dn_oid_known()</code> .
</p>
<p>If buf is null then only the size will be filled.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the provided buffer is
not long enough, and in that case the sizeof_buf will be updated
with the required size, and 0 on success.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fget_005fnext_005fupdate-1"></a>
<h4 class="subheading">gnutls_x509_crl_get_next_update</h4>
<a name="gnutls_005fx509_005fcrl_005fget_005fnext_005fupdate"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fget_005fnext_005fupdate"></a>Function: <em>time_t</em> <strong>gnutls_x509_crl_get_next_update</strong> <em>(gnutls_x509_crl_t <var>crl</var>)</em></dt>
<dd><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code>  type
</p>
<p>This function will return the time the next CRL will be issued.
This field is optional in a CRL so it might be normal to get an
error instead.
</p>
<p><strong>Returns:</strong> when the next CRL will be issued, or (time_t)-1 on error.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fget_005fnumber-1"></a>
<h4 class="subheading">gnutls_x509_crl_get_number</h4>
<a name="gnutls_005fx509_005fcrl_005fget_005fnumber"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fget_005fnumber"></a>Function: <em>int</em> <strong>gnutls_x509_crl_get_number</strong> <em>(gnutls_x509_crl_t <var>crl</var>, void * <var>ret</var>, size_t * <var>ret_size</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code>  type
</p>
<p><var>ret</var>: The place where the number will be copied
</p>
<p><var>ret_size</var>: Holds the size of the result field.
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical
(may be null)
</p>
<p>This function will return the CRL number extension.  This is
obtained by the CRL Number extension field (2.5.29.20).
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code in case of an error.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fget_005fraw_005fissuer_005fdn-1"></a>
<h4 class="subheading">gnutls_x509_crl_get_raw_issuer_dn</h4>
<a name="gnutls_005fx509_005fcrl_005fget_005fraw_005fissuer_005fdn"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fget_005fraw_005fissuer_005fdn"></a>Function: <em>int</em> <strong>gnutls_x509_crl_get_raw_issuer_dn</strong> <em>(gnutls_x509_crl_t <var>crl</var>, gnutls_datum_t * <var>dn</var>)</em></dt>
<dd><p><var>crl</var>: should contain a gnutls_x509_crl_t type
</p>
<p><var>dn</var>: will hold the starting point of the DN
</p>
<p>This function will return a pointer to the DER encoded DN structure
and the length.
</p>
<p><strong>Returns:</strong> a negative error code on error, and (0) on success.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fget_005fsignature-1"></a>
<h4 class="subheading">gnutls_x509_crl_get_signature</h4>
<a name="gnutls_005fx509_005fcrl_005fget_005fsignature"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fget_005fsignature"></a>Function: <em>int</em> <strong>gnutls_x509_crl_get_signature</strong> <em>(gnutls_x509_crl_t <var>crl</var>, char * <var>sig</var>, size_t * <var>sizeof_sig</var>)</em></dt>
<dd><p><var>crl</var>: should contain a gnutls_x509_crl_t type
</p>
<p><var>sig</var>: a pointer where the signature part will be copied (may be null).
</p>
<p><var>sizeof_sig</var>: initially holds the size of  <code>sig</code> 
</p>
<p>This function will extract the signature field of a CRL.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value. 
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fget_005fsignature_005falgorithm-1"></a>
<h4 class="subheading">gnutls_x509_crl_get_signature_algorithm</h4>
<a name="gnutls_005fx509_005fcrl_005fget_005fsignature_005falgorithm"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fget_005fsignature_005falgorithm"></a>Function: <em>int</em> <strong>gnutls_x509_crl_get_signature_algorithm</strong> <em>(gnutls_x509_crl_t <var>crl</var>)</em></dt>
<dd><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code>  type
</p>
<p>This function will return a value of the <code>gnutls_sign_algorithm_t</code> 
enumeration that is the signature algorithm.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fget_005fsignature_005foid-1"></a>
<h4 class="subheading">gnutls_x509_crl_get_signature_oid</h4>
<a name="gnutls_005fx509_005fcrl_005fget_005fsignature_005foid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fget_005fsignature_005foid"></a>Function: <em>int</em> <strong>gnutls_x509_crl_get_signature_oid</strong> <em>(gnutls_x509_crl_t <var>crl</var>, char * <var>oid</var>, size_t * <var>oid_size</var>)</em></dt>
<dd><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code>  type
</p>
<p><var>oid</var>: a pointer to a buffer to hold the OID (may be null)
</p>
<p><var>oid_size</var>: initially holds the size of  <code>oid</code> 
</p>
<p>This function will return the OID of the signature algorithm
that has been used to sign this CRL. This is function
is useful in the case <code>gnutls_x509_crl_get_signature_algorithm()</code> 
returned <code>GNUTLS_SIGN_UNKNOWN</code> .
</p>
<p><strong>Returns:</strong> zero or a negative error code on error.
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fget_005fthis_005fupdate-1"></a>
<h4 class="subheading">gnutls_x509_crl_get_this_update</h4>
<a name="gnutls_005fx509_005fcrl_005fget_005fthis_005fupdate"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fget_005fthis_005fupdate"></a>Function: <em>time_t</em> <strong>gnutls_x509_crl_get_this_update</strong> <em>(gnutls_x509_crl_t <var>crl</var>)</em></dt>
<dd><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code>  type
</p>
<p>This function will return the time this CRL was issued.
</p>
<p><strong>Returns:</strong> when the CRL was issued, or (time_t)-1 on error.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fget_005fversion-1"></a>
<h4 class="subheading">gnutls_x509_crl_get_version</h4>
<a name="gnutls_005fx509_005fcrl_005fget_005fversion"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fget_005fversion"></a>Function: <em>int</em> <strong>gnutls_x509_crl_get_version</strong> <em>(gnutls_x509_crl_t <var>crl</var>)</em></dt>
<dd><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code>  type
</p>
<p>This function will return the version of the specified CRL.
</p>
<p><strong>Returns:</strong> The version number, or a negative error code on error.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fimport-1"></a>
<h4 class="subheading">gnutls_x509_crl_import</h4>
<a name="gnutls_005fx509_005fcrl_005fimport"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fimport"></a>Function: <em>int</em> <strong>gnutls_x509_crl_import</strong> <em>(gnutls_x509_crl_t <var>crl</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>)</em></dt>
<dd><p><var>crl</var>: The data to store the parsed CRL.
</p>
<p><var>data</var>: The DER or PEM encoded CRL.
</p>
<p><var>format</var>: One of DER or PEM
</p>
<p>This function will convert the given DER or PEM encoded CRL
to the native <code>gnutls_x509_crl_t</code>  format. The output will be stored in &rsquo;crl&rsquo;.
</p>
<p>If the CRL is PEM encoded it should have a header of &quot;X509 CRL&quot;.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005finit-1"></a>
<h4 class="subheading">gnutls_x509_crl_init</h4>
<a name="gnutls_005fx509_005fcrl_005finit"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005finit"></a>Function: <em>int</em> <strong>gnutls_x509_crl_init</strong> <em>(gnutls_x509_crl_t * <var>crl</var>)</em></dt>
<dd><p><var>crl</var>: A pointer to the type to be initialized
</p>
<p>This function will initialize a CRL structure. CRL stands for
Certificate Revocation List. A revocation list usually contains
lists of certificate serial numbers that have been revoked by an
Authority. The revocation lists are always signed with the
authority&rsquo;s private key.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fiter_005fcrt_005fserial-1"></a>
<h4 class="subheading">gnutls_x509_crl_iter_crt_serial</h4>
<a name="gnutls_005fx509_005fcrl_005fiter_005fcrt_005fserial"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fiter_005fcrt_005fserial"></a>Function: <em>int</em> <strong>gnutls_x509_crl_iter_crt_serial</strong> <em>(gnutls_x509_crl_t <var>crl</var>, gnutls_x509_crl_iter_t * <var>iter</var>, unsigned char * <var>serial</var>, size_t * <var>serial_size</var>, time_t * <var>t</var>)</em></dt>
<dd><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code>  type
</p>
<p><var>iter</var>: A pointer to an iterator (initially the iterator should be <code>NULL</code> )
</p>
<p><var>serial</var>: where the serial number will be copied
</p>
<p><var>serial_size</var>: initially holds the size of serial
</p>
<p><var>t</var>: if non null, will hold the time this certificate was revoked
</p>
<p>This function performs the same as <code>gnutls_x509_crl_get_crt_serial()</code> ,
but reads sequentially and keeps state in the iterator 
between calls. That allows it to provide better performance in sequences 
with many elements (50000+).
</p>
<p>When past the last element is accessed <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
is returned and the iterator is reset.
</p>
<p>After use, the iterator must be deinitialized using <code>gnutls_x509_crl_iter_deinit()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fiter_005fdeinit-1"></a>
<h4 class="subheading">gnutls_x509_crl_iter_deinit</h4>
<a name="gnutls_005fx509_005fcrl_005fiter_005fdeinit"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fiter_005fdeinit"></a>Function: <em>void</em> <strong>gnutls_x509_crl_iter_deinit</strong> <em>(gnutls_x509_crl_iter_t <var>iter</var>)</em></dt>
<dd><p><var>iter</var>: The iterator to be deinitialized
</p>
<p>This function will deinitialize an iterator type.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005flist_005fimport-1"></a>
<h4 class="subheading">gnutls_x509_crl_list_import</h4>
<a name="gnutls_005fx509_005fcrl_005flist_005fimport"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005flist_005fimport"></a>Function: <em>int</em> <strong>gnutls_x509_crl_list_import</strong> <em>(gnutls_x509_crl_t * <var>crls</var>, unsigned int * <var>crl_max</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>crls</var>: Indicates where the parsed CRLs will be copied to. Must not be initialized.
</p>
<p><var>crl_max</var>: Initially must hold the maximum number of crls. It will be updated with the number of crls available.
</p>
<p><var>data</var>: The PEM encoded CRLs
</p>
<p><var>format</var>: One of DER or PEM.
</p>
<p><var>flags</var>: must be (0) or an OR&rsquo;d sequence of gnutls_certificate_import_flags.
</p>
<p>This function will convert the given PEM encoded CRL list
to the native gnutls_x509_crl_t format. The output will be stored
in  <code>crls</code> .  They will be automatically initialized.
</p>
<p>If the Certificate is PEM encoded it should have a header of &quot;X509 CRL&quot;.
</p>
<p><strong>Returns:</strong> the number of certificates read or a negative error value.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005flist_005fimport2-1"></a>
<h4 class="subheading">gnutls_x509_crl_list_import2</h4>
<a name="gnutls_005fx509_005fcrl_005flist_005fimport2"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005flist_005fimport2"></a>Function: <em>int</em> <strong>gnutls_x509_crl_list_import2</strong> <em>(gnutls_x509_crl_t ** <var>crls</var>, unsigned int * <var>size</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>crls</var>: Will contain the parsed crl list.
</p>
<p><var>size</var>: It will contain the size of the list.
</p>
<p><var>data</var>: The PEM encoded CRL.
</p>
<p><var>format</var>: One of DER or PEM.
</p>
<p><var>flags</var>: must be (0) or an OR&rsquo;d sequence of gnutls_certificate_import_flags.
</p>
<p>This function will convert the given PEM encoded CRL list
to the native gnutls_x509_crl_t format. The output will be stored
in  <code>crls</code> .  They will be automatically initialized.
</p>
<p>If the Certificate is PEM encoded it should have a header of &quot;X509
CRL&quot;.
</p>
<p><strong>Returns:</strong> the number of certificates read or a negative error value.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fprint-1"></a>
<h4 class="subheading">gnutls_x509_crl_print</h4>
<a name="gnutls_005fx509_005fcrl_005fprint"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fprint"></a>Function: <em>int</em> <strong>gnutls_x509_crl_print</strong> <em>(gnutls_x509_crl_t <var>crl</var>, gnutls_certificate_print_formats_t <var>format</var>, gnutls_datum_t * <var>out</var>)</em></dt>
<dd><p><var>crl</var>: The data to be printed
</p>
<p><var>format</var>: Indicate the format to use
</p>
<p><var>out</var>: Newly allocated datum with null terminated string.
</p>
<p>This function will pretty print a X.509 certificate revocation
list, suitable for display to a human.
</p>
<p>The output  <code>out</code> needs to be deallocated using <code>gnutls_free()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fset_005fauthority_005fkey_005fid-1"></a>
<h4 class="subheading">gnutls_x509_crl_set_authority_key_id</h4>
<a name="gnutls_005fx509_005fcrl_005fset_005fauthority_005fkey_005fid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fset_005fauthority_005fkey_005fid"></a>Function: <em>int</em> <strong>gnutls_x509_crl_set_authority_key_id</strong> <em>(gnutls_x509_crl_t <var>crl</var>, const void * <var>id</var>, size_t <var>id_size</var>)</em></dt>
<dd><p><var>crl</var>: a CRL of type <code>gnutls_x509_crl_t</code> 
</p>
<p><var>id</var>: The key ID
</p>
<p><var>id_size</var>: Holds the size of the serial field.
</p>
<p>This function will set the CRL&rsquo;s authority key ID extension.  Only
the keyIdentifier field can be set with this function. This may
be used by an authority that holds multiple private keys, to distinguish
the used key.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fset_005fcrt-1"></a>
<h4 class="subheading">gnutls_x509_crl_set_crt</h4>
<a name="gnutls_005fx509_005fcrl_005fset_005fcrt"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fset_005fcrt"></a>Function: <em>int</em> <strong>gnutls_x509_crl_set_crt</strong> <em>(gnutls_x509_crl_t <var>crl</var>, gnutls_x509_crt_t <var>crt</var>, time_t <var>revocation_time</var>)</em></dt>
<dd><p><var>crl</var>: should contain a gnutls_x509_crl_t type
</p>
<p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code>  with the revoked certificate
</p>
<p><var>revocation_time</var>: The time this certificate was revoked
</p>
<p>This function will set a revoked certificate&rsquo;s serial number to the CRL.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fset_005fcrt_005fserial-1"></a>
<h4 class="subheading">gnutls_x509_crl_set_crt_serial</h4>
<a name="gnutls_005fx509_005fcrl_005fset_005fcrt_005fserial"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fset_005fcrt_005fserial"></a>Function: <em>int</em> <strong>gnutls_x509_crl_set_crt_serial</strong> <em>(gnutls_x509_crl_t <var>crl</var>, const void * <var>serial</var>, size_t <var>serial_size</var>, time_t <var>revocation_time</var>)</em></dt>
<dd><p><var>crl</var>: should contain a gnutls_x509_crl_t type
</p>
<p><var>serial</var>: The revoked certificate&rsquo;s serial number
</p>
<p><var>serial_size</var>: Holds the size of the serial field.
</p>
<p><var>revocation_time</var>: The time this certificate was revoked
</p>
<p>This function will set a revoked certificate&rsquo;s serial number to the CRL.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fset_005fnext_005fupdate-1"></a>
<h4 class="subheading">gnutls_x509_crl_set_next_update</h4>
<a name="gnutls_005fx509_005fcrl_005fset_005fnext_005fupdate"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fset_005fnext_005fupdate"></a>Function: <em>int</em> <strong>gnutls_x509_crl_set_next_update</strong> <em>(gnutls_x509_crl_t <var>crl</var>, time_t <var>exp_time</var>)</em></dt>
<dd><p><var>crl</var>: should contain a gnutls_x509_crl_t type
</p>
<p><var>exp_time</var>: The actual time
</p>
<p>This function will set the time this CRL will be updated.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fset_005fnumber-1"></a>
<h4 class="subheading">gnutls_x509_crl_set_number</h4>
<a name="gnutls_005fx509_005fcrl_005fset_005fnumber"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fset_005fnumber"></a>Function: <em>int</em> <strong>gnutls_x509_crl_set_number</strong> <em>(gnutls_x509_crl_t <var>crl</var>, const void * <var>nr</var>, size_t <var>nr_size</var>)</em></dt>
<dd><p><var>crl</var>: a CRL of type <code>gnutls_x509_crl_t</code> 
</p>
<p><var>nr</var>: The CRL number
</p>
<p><var>nr_size</var>: Holds the size of the nr field.
</p>
<p>This function will set the CRL&rsquo;s number extension. This
is to be used as a unique and monotonic number assigned to
the CRL by the authority.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fset_005fthis_005fupdate-1"></a>
<h4 class="subheading">gnutls_x509_crl_set_this_update</h4>
<a name="gnutls_005fx509_005fcrl_005fset_005fthis_005fupdate"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fset_005fthis_005fupdate"></a>Function: <em>int</em> <strong>gnutls_x509_crl_set_this_update</strong> <em>(gnutls_x509_crl_t <var>crl</var>, time_t <var>act_time</var>)</em></dt>
<dd><p><var>crl</var>: should contain a gnutls_x509_crl_t type
</p>
<p><var>act_time</var>: The actual time
</p>
<p>This function will set the time this CRL was issued.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fset_005fversion-1"></a>
<h4 class="subheading">gnutls_x509_crl_set_version</h4>
<a name="gnutls_005fx509_005fcrl_005fset_005fversion"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fset_005fversion"></a>Function: <em>int</em> <strong>gnutls_x509_crl_set_version</strong> <em>(gnutls_x509_crl_t <var>crl</var>, unsigned int <var>version</var>)</em></dt>
<dd><p><var>crl</var>: should contain a gnutls_x509_crl_t type
</p>
<p><var>version</var>: holds the version number. For CRLv1 crls must be 1.
</p>
<p>This function will set the version of the CRL. This
must be one for CRL version 1, and so on. The CRLs generated
by gnutls should have a version number of 2.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fsign2-1"></a>
<h4 class="subheading">gnutls_x509_crl_sign2</h4>
<a name="gnutls_005fx509_005fcrl_005fsign2"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fsign2-1"></a>Function: <em>int</em> <strong>gnutls_x509_crl_sign2</strong> <em>(gnutls_x509_crl_t <var>crl</var>, gnutls_x509_crt_t <var>issuer</var>, gnutls_x509_privkey_t <var>issuer_key</var>, gnutls_digest_algorithm_t <var>dig</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>crl</var>: should contain a gnutls_x509_crl_t type
</p>
<p><var>issuer</var>: is the certificate of the certificate issuer
</p>
<p><var>issuer_key</var>: holds the issuer&rsquo;s private key
</p>
<p><var>dig</var>: The message digest to use. GNUTLS_DIG_SHA1 is the safe choice unless you know what you&rsquo;re doing.
</p>
<p><var>flags</var>: must be 0
</p>
<p>This function will sign the CRL with the issuer&rsquo;s private key, and
will copy the issuer&rsquo;s information into the CRL.
</p>
<p>This must be the last step in a certificate CRL since all
the previously set parameters are now signed.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrl_005fverify-1"></a>
<h4 class="subheading">gnutls_x509_crl_verify</h4>
<a name="gnutls_005fx509_005fcrl_005fverify"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrl_005fverify"></a>Function: <em>int</em> <strong>gnutls_x509_crl_verify</strong> <em>(gnutls_x509_crl_t <var>crl</var>, const gnutls_x509_crt_t * <var>trusted_cas</var>, unsigned <var>tcas_size</var>, unsigned int <var>flags</var>, unsigned int * <var>verify</var>)</em></dt>
<dd><p><var>crl</var>: is the crl to be verified
</p>
<p><var>trusted_cas</var>: is a certificate list that is considered to be trusted one
</p>
<p><var>tcas_size</var>: holds the number of CA certificates in CA_list
</p>
<p><var>flags</var>: Flags that may be used to change the verification algorithm. Use OR of the gnutls_certificate_verify_flags enumerations.
</p>
<p><var>verify</var>: will hold the crl verification output.
</p>
<p>This function will try to verify the given crl and return its verification status.
See <code>gnutls_x509_crt_list_verify()</code>  for a detailed description of
return values. Note that since GnuTLS 3.1.4 this function includes
the time checks.
</p>
<p>Note that value in  <code>verify</code> is set only when the return value of this 
function is success (i.e, failure to trust a CRL a certificate does not imply 
a negative return value).
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fdeinit-1"></a>
<h4 class="subheading">gnutls_x509_crq_deinit</h4>
<a name="gnutls_005fx509_005fcrq_005fdeinit"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fdeinit"></a>Function: <em>void</em> <strong>gnutls_x509_crq_deinit</strong> <em>(gnutls_x509_crq_t <var>crq</var>)</em></dt>
<dd><p><var>crq</var>: the type to be deinitialized
</p>
<p>This function will deinitialize a PKCS<code>10</code>  certificate request
structure.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fexport-1"></a>
<h4 class="subheading">gnutls_x509_crq_export</h4>
<a name="gnutls_005fx509_005fcrq_005fexport"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fexport"></a>Function: <em>int</em> <strong>gnutls_x509_crq_export</strong> <em>(gnutls_x509_crq_t <var>crq</var>, gnutls_x509_crt_fmt_t <var>format</var>, void * <var>output_data</var>, size_t * <var>output_data_size</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>format</var>: the format of output params. One of PEM or DER.
</p>
<p><var>output_data</var>: will contain a certificate request PEM or DER encoded
</p>
<p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)
</p>
<p>This function will export the certificate request to a PEM or DER
encoded PKCS10 structure.
</p>
<p>If the buffer provided is not long enough to hold the output, then
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  will be returned and
* <code>output_data_size</code> will be updated.
</p>
<p>If the structure is PEM encoded, it will have a header of &quot;BEGIN
NEW CERTIFICATE REQUEST&quot;.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fexport2-1"></a>
<h4 class="subheading">gnutls_x509_crq_export2</h4>
<a name="gnutls_005fx509_005fcrq_005fexport2"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fexport2"></a>Function: <em>int</em> <strong>gnutls_x509_crq_export2</strong> <em>(gnutls_x509_crq_t <var>crq</var>, gnutls_x509_crt_fmt_t <var>format</var>, gnutls_datum_t * <var>out</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>format</var>: the format of output params. One of PEM or DER.
</p>
<p><var>out</var>: will contain a certificate request PEM or DER encoded
</p>
<p>This function will export the certificate request to a PEM or DER
encoded PKCS10 structure.
</p>
<p>The output buffer is allocated using <code>gnutls_malloc()</code> .
</p>
<p>If the structure is PEM encoded, it will have a header of &quot;BEGIN
NEW CERTIFICATE REQUEST&quot;.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p>Since 3.1.3
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fget_005fattribute_005fby_005foid-1"></a>
<h4 class="subheading">gnutls_x509_crq_get_attribute_by_oid</h4>
<a name="gnutls_005fx509_005fcrq_005fget_005fattribute_005fby_005foid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fget_005fattribute_005fby_005foid"></a>Function: <em>int</em> <strong>gnutls_x509_crq_get_attribute_by_oid</strong> <em>(gnutls_x509_crq_t <var>crq</var>, const char * <var>oid</var>, unsigned <var>indx</var>, void * <var>buf</var>, size_t * <var>buf_size</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>oid</var>: holds an Object Identifier in null-terminated string
</p>
<p><var>indx</var>: In case multiple same OIDs exist in the attribute list, this
specifies which to get, use (0) to get the first one
</p>
<p><var>buf</var>: a pointer to a structure to hold the attribute data (may be <code>NULL</code> )
</p>
<p><var>buf_size</var>: initially holds the size of  <code>buf</code> 
</p>
<p>This function will return the attribute in the certificate request
specified by the given Object ID.  The attribute will be DER
encoded.
</p>
<p>Attributes in a certificate request is an optional set of data
appended to the request. Their interpretation depends on the CA policy.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fget_005fattribute_005fdata-1"></a>
<h4 class="subheading">gnutls_x509_crq_get_attribute_data</h4>
<a name="gnutls_005fx509_005fcrq_005fget_005fattribute_005fdata"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fget_005fattribute_005fdata"></a>Function: <em>int</em> <strong>gnutls_x509_crq_get_attribute_data</strong> <em>(gnutls_x509_crq_t <var>crq</var>, unsigned <var>indx</var>, void * <var>data</var>, size_t * <var>sizeof_data</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>indx</var>: Specifies which attribute number to get. Use (0) to get the first one.
</p>
<p><var>data</var>: a pointer to a structure to hold the data (may be null)
</p>
<p><var>sizeof_data</var>: initially holds the size of  <code>oid</code> 
</p>
<p>This function will return the requested attribute data in the
certificate request.  The attribute data will be stored as a string in the
provided buffer.
</p>
<p>Use <code>gnutls_x509_crq_get_attribute_info()</code>  to extract the OID.
Use <code>gnutls_x509_crq_get_attribute_by_oid()</code>  instead,
if you want to get data indexed by the attribute OID rather than
sequence.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code in case of an error.  If your have reached the
last extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
will be returned.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fget_005fattribute_005finfo-1"></a>
<h4 class="subheading">gnutls_x509_crq_get_attribute_info</h4>
<a name="gnutls_005fx509_005fcrq_005fget_005fattribute_005finfo"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fget_005fattribute_005finfo"></a>Function: <em>int</em> <strong>gnutls_x509_crq_get_attribute_info</strong> <em>(gnutls_x509_crq_t <var>crq</var>, unsigned <var>indx</var>, void * <var>oid</var>, size_t * <var>sizeof_oid</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>indx</var>: Specifies which attribute number to get. Use (0) to get the first one.
</p>
<p><var>oid</var>: a pointer to a structure to hold the OID
</p>
<p><var>sizeof_oid</var>: initially holds the maximum size of  <code>oid</code> , on return
holds actual size of  <code>oid</code> .
</p>
<p>This function will return the requested attribute OID in the
certificate, and the critical flag for it.  The attribute OID will
be stored as a string in the provided buffer.  Use
<code>gnutls_x509_crq_get_attribute_data()</code>  to extract the data.
</p>
<p>If the buffer provided is not long enough to hold the output, then
* <code>sizeof_oid</code> is updated and <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  will be
returned.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code in case of an error.  If your have reached the
last extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
will be returned.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fget_005fbasic_005fconstraints-1"></a>
<h4 class="subheading">gnutls_x509_crq_get_basic_constraints</h4>
<a name="gnutls_005fx509_005fcrq_005fget_005fbasic_005fconstraints"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fget_005fbasic_005fconstraints"></a>Function: <em>int</em> <strong>gnutls_x509_crq_get_basic_constraints</strong> <em>(gnutls_x509_crq_t <var>crq</var>, unsigned int * <var>critical</var>, unsigned int * <var>ca</var>, int * <var>pathlen</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical
</p>
<p><var>ca</var>: pointer to output integer indicating CA status, may be NULL,
value is 1 if the certificate CA flag is set, 0 otherwise.
</p>
<p><var>pathlen</var>: pointer to output integer indicating path length (may be
NULL), non-negative error codes indicate a present pathLenConstraint
field and the actual value, -1 indicate that the field is absent.
</p>
<p>This function will read the certificate&rsquo;s basic constraints, and
return the certificates CA status.  It reads the basicConstraints
X.509 extension (2.5.29.19).
</p>
<p><strong>Returns:</strong> If the certificate is a CA a positive value will be
returned, or (0) if the certificate does not have CA flag set.
A negative error code may be returned in case of errors.  If the
certificate does not contain the basicConstraints extension
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  will be returned.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fget_005fchallenge_005fpassword-1"></a>
<h4 class="subheading">gnutls_x509_crq_get_challenge_password</h4>
<a name="gnutls_005fx509_005fcrq_005fget_005fchallenge_005fpassword"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fget_005fchallenge_005fpassword"></a>Function: <em>int</em> <strong>gnutls_x509_crq_get_challenge_password</strong> <em>(gnutls_x509_crq_t <var>crq</var>, char * <var>pass</var>, size_t * <var>pass_size</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>pass</var>: will hold a (0)-terminated password string
</p>
<p><var>pass_size</var>: Initially holds the size of  <code>pass</code> .
</p>
<p>This function will return the challenge password in the request.
The challenge password is intended to be used for requesting a
revocation of the certificate.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fget_005fdn-1"></a>
<h4 class="subheading">gnutls_x509_crq_get_dn</h4>
<a name="gnutls_005fx509_005fcrq_005fget_005fdn"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fget_005fdn"></a>Function: <em>int</em> <strong>gnutls_x509_crq_get_dn</strong> <em>(gnutls_x509_crq_t <var>crq</var>, char * <var>buf</var>, size_t * <var>buf_size</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>buf</var>: a pointer to a structure to hold the name (may be <code>NULL</code> )
</p>
<p><var>buf_size</var>: initially holds the size of  <code>buf</code> 
</p>
<p>This function will copy the name of the Certificate request subject
to the provided buffer.  The name will be in the form
&quot;C=xxxx,O=yyyy,CN=zzzz&quot; as described in RFC 2253. The output string
 <code>buf</code> will be ASCII or UTF-8 encoded, depending on the certificate
data.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the provided buffer is not
long enough, and in that case the * <code>buf_size</code> will be updated with
the required size.  On success 0 is returned.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fget_005fdn2-1"></a>
<h4 class="subheading">gnutls_x509_crq_get_dn2</h4>
<a name="gnutls_005fx509_005fcrq_005fget_005fdn2"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fget_005fdn2"></a>Function: <em>int</em> <strong>gnutls_x509_crq_get_dn2</strong> <em>(gnutls_x509_crq_t <var>crq</var>, gnutls_datum_t * <var>dn</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>dn</var>: a pointer to a structure to hold the name
</p>
<p>This function will allocate buffer and copy the name of the Certificate 
request. The name will be in the form &quot;C=xxxx,O=yyyy,CN=zzzz&quot; as
described in RFC4514. The output string will be ASCII or UTF-8
encoded, depending on the certificate data.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value. and a negative error code on error.
</p>
<p><strong>Since:</strong> 3.1.10
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fget_005fdn_005fby_005foid-1"></a>
<h4 class="subheading">gnutls_x509_crq_get_dn_by_oid</h4>
<a name="gnutls_005fx509_005fcrq_005fget_005fdn_005fby_005foid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fget_005fdn_005fby_005foid"></a>Function: <em>int</em> <strong>gnutls_x509_crq_get_dn_by_oid</strong> <em>(gnutls_x509_crq_t <var>crq</var>, const char * <var>oid</var>, unsigned <var>indx</var>, unsigned int <var>raw_flag</var>, void * <var>buf</var>, size_t * <var>buf_size</var>)</em></dt>
<dd><p><var>crq</var>: should contain a gnutls_x509_crq_t type
</p>
<p><var>oid</var>: holds an Object Identifier in a null terminated string
</p>
<p><var>indx</var>: In case multiple same OIDs exist in the RDN, this specifies
which to get. Use (0) to get the first one.
</p>
<p><var>raw_flag</var>: If non-zero returns the raw DER data of the DN part.
</p>
<p><var>buf</var>: a pointer to a structure to hold the name (may be <code>NULL</code> )
</p>
<p><var>buf_size</var>: initially holds the size of  <code>buf</code> 
</p>
<p>This function will extract the part of the name of the Certificate
request subject, specified by the given OID. The output will be
encoded as described in RFC2253. The output string will be ASCII
or UTF-8 encoded, depending on the certificate data.
</p>
<p>Some helper macros with popular OIDs can be found in gnutls/x509.h
If raw flag is (0), this function will only return known OIDs as
text. Other OIDs will be DER encoded, as described in RFC2253 &ndash;
in hex format with a &rsquo;\#&rsquo; prefix.  You can check about known OIDs
using <code>gnutls_x509_dn_oid_known()</code> .
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the provided buffer is
not long enough, and in that case the * <code>buf_size</code> will be
updated with the required size.  On success 0 is returned.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fget_005fdn_005foid-1"></a>
<h4 class="subheading">gnutls_x509_crq_get_dn_oid</h4>
<a name="gnutls_005fx509_005fcrq_005fget_005fdn_005foid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fget_005fdn_005foid"></a>Function: <em>int</em> <strong>gnutls_x509_crq_get_dn_oid</strong> <em>(gnutls_x509_crq_t <var>crq</var>, unsigned <var>indx</var>, void * <var>oid</var>, size_t * <var>sizeof_oid</var>)</em></dt>
<dd><p><var>crq</var>: should contain a gnutls_x509_crq_t type
</p>
<p><var>indx</var>: Specifies which DN OID to get. Use (0) to get the first one.
</p>
<p><var>oid</var>: a pointer to a structure to hold the name (may be <code>NULL</code> )
</p>
<p><var>sizeof_oid</var>: initially holds the size of  <code>oid</code> 
</p>
<p>This function will extract the requested OID of the name of the
certificate request subject, specified by the given index.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the provided buffer is
not long enough, and in that case the * <code>sizeof_oid</code> will be
updated with the required size.  On success 0 is returned.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fget_005fextension_005fby_005foid-1"></a>
<h4 class="subheading">gnutls_x509_crq_get_extension_by_oid</h4>
<a name="gnutls_005fx509_005fcrq_005fget_005fextension_005fby_005foid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fget_005fextension_005fby_005foid"></a>Function: <em>int</em> <strong>gnutls_x509_crq_get_extension_by_oid</strong> <em>(gnutls_x509_crq_t <var>crq</var>, const char * <var>oid</var>, unsigned <var>indx</var>, void * <var>buf</var>, size_t * <var>buf_size</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>oid</var>: holds an Object Identifier in a null terminated string
</p>
<p><var>indx</var>: In case multiple same OIDs exist in the extensions, this
specifies which to get. Use (0) to get the first one.
</p>
<p><var>buf</var>: a pointer to a structure to hold the name (may be null)
</p>
<p><var>buf_size</var>: initially holds the size of  <code>buf</code> 
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical
</p>
<p>This function will return the extension specified by the OID in
the certificate.  The extensions will be returned as binary data
DER encoded, in the provided buffer.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code in case of an error.  If the certificate does not
contain the specified extension
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  will be returned.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fget_005fextension_005fby_005foid2-1"></a>
<h4 class="subheading">gnutls_x509_crq_get_extension_by_oid2</h4>
<a name="gnutls_005fx509_005fcrq_005fget_005fextension_005fby_005foid2"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fget_005fextension_005fby_005foid2"></a>Function: <em>int</em> <strong>gnutls_x509_crq_get_extension_by_oid2</strong> <em>(gnutls_x509_crq_t <var>crq</var>, const char * <var>oid</var>, unsigned <var>indx</var>, gnutls_datum_t * <var>output</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>oid</var>: holds an Object Identifier in a null terminated string
</p>
<p><var>indx</var>: In case multiple same OIDs exist in the extensions, this
specifies which to get. Use (0) to get the first one.
</p>
<p><var>output</var>: will hold the allocated extension data
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical
</p>
<p>This function will return the extension specified by the OID in
the certificate.  The extensions will be returned as binary data
DER encoded, in the provided buffer.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code in case of an error.  If the certificate does not
contain the specified extension
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  will be returned.
</p>
<p><strong>Since:</strong> 3.3.8
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fget_005fextension_005fdata-1"></a>
<h4 class="subheading">gnutls_x509_crq_get_extension_data</h4>
<a name="gnutls_005fx509_005fcrq_005fget_005fextension_005fdata"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fget_005fextension_005fdata"></a>Function: <em>int</em> <strong>gnutls_x509_crq_get_extension_data</strong> <em>(gnutls_x509_crq_t <var>crq</var>, unsigned <var>indx</var>, void * <var>data</var>, size_t * <var>sizeof_data</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>indx</var>: Specifies which extension number to get. Use (0) to get the first one.
</p>
<p><var>data</var>: a pointer to a structure to hold the data (may be null)
</p>
<p><var>sizeof_data</var>: initially holds the size of  <code>oid</code> 
</p>
<p>This function will return the requested extension data in the
certificate.  The extension data will be stored as a string in the
provided buffer.
</p>
<p>Use <code>gnutls_x509_crq_get_extension_info()</code>  to extract the OID and
critical flag.  Use <code>gnutls_x509_crq_get_extension_by_oid()</code>  instead,
if you want to get data indexed by the extension OID rather than
sequence.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code in case of an error.  If your have reached the
last extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
will be returned.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fget_005fextension_005fdata2-1"></a>
<h4 class="subheading">gnutls_x509_crq_get_extension_data2</h4>
<a name="gnutls_005fx509_005fcrq_005fget_005fextension_005fdata2"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fget_005fextension_005fdata2"></a>Function: <em>int</em> <strong>gnutls_x509_crq_get_extension_data2</strong> <em>(gnutls_x509_crq_t <var>crq</var>, unsigned <var>indx</var>, gnutls_datum_t * <var>data</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>indx</var>: Specifies which extension OID to read. Use (0) to get the first one.
</p>
<p><var>data</var>: will contain the extension DER-encoded data
</p>
<p>This function will return the requested extension data in the
certificate request.  The extension data will be allocated using
<code>gnutls_malloc()</code> .
</p>
<p>Use <code>gnutls_x509_crq_get_extension_info()</code>  to extract the OID.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.  If you have reached the
last extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
will be returned.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fget_005fextension_005finfo-1"></a>
<h4 class="subheading">gnutls_x509_crq_get_extension_info</h4>
<a name="gnutls_005fx509_005fcrq_005fget_005fextension_005finfo"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fget_005fextension_005finfo"></a>Function: <em>int</em> <strong>gnutls_x509_crq_get_extension_info</strong> <em>(gnutls_x509_crq_t <var>crq</var>, unsigned <var>indx</var>, void * <var>oid</var>, size_t * <var>sizeof_oid</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>indx</var>: Specifies which extension number to get. Use (0) to get the first one.
</p>
<p><var>oid</var>: a pointer to store the OID
</p>
<p><var>sizeof_oid</var>: initially holds the maximum size of  <code>oid</code> , on return
holds actual size of  <code>oid</code> .
</p>
<p><var>critical</var>: output variable with critical flag, may be NULL.
</p>
<p>This function will return the requested extension OID in the
certificate, and the critical flag for it.  The extension OID will
be stored as a string in the provided buffer.  Use
<code>gnutls_x509_crq_get_extension_data()</code>  to extract the data.
</p>
<p>If the buffer provided is not long enough to hold the output, then
* <code>sizeof_oid</code> is updated and <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  will be
returned.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code in case of an error.  If your have reached the
last extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
will be returned.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fget_005fkey_005fid-1"></a>
<h4 class="subheading">gnutls_x509_crq_get_key_id</h4>
<a name="gnutls_005fx509_005fcrq_005fget_005fkey_005fid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fget_005fkey_005fid"></a>Function: <em>int</em> <strong>gnutls_x509_crq_get_key_id</strong> <em>(gnutls_x509_crq_t <var>crq</var>, unsigned int <var>flags</var>, unsigned char * <var>output_data</var>, size_t * <var>output_data_size</var>)</em></dt>
<dd><p><var>crq</var>: a certificate of type <code>gnutls_x509_crq_t</code> 
</p>
<p><var>flags</var>: should be one of the flags from <code>gnutls_keyid_flags_t</code> 
</p>
<p><var>output_data</var>: will contain the key ID
</p>
<p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)
</p>
<p>This function will return a unique ID that depends on the public key
parameters.  This ID can be used in checking whether a certificate
corresponds to the given private key.
</p>
<p>If the buffer provided is not long enough to hold the output, then
* <code>output_data_size</code> is updated and GNUTLS_E_SHORT_MEMORY_BUFFER will
be returned.  The output will normally be a SHA-1 hash output,
which is 20 bytes.
</p>
<p><strong>Returns:</strong> In case of failure a negative error code will be
returned, and 0 on success.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fget_005fkey_005fpurpose_005foid-1"></a>
<h4 class="subheading">gnutls_x509_crq_get_key_purpose_oid</h4>
<a name="gnutls_005fx509_005fcrq_005fget_005fkey_005fpurpose_005foid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fget_005fkey_005fpurpose_005foid"></a>Function: <em>int</em> <strong>gnutls_x509_crq_get_key_purpose_oid</strong> <em>(gnutls_x509_crq_t <var>crq</var>, unsigned <var>indx</var>, void * <var>oid</var>, size_t * <var>sizeof_oid</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>indx</var>: This specifies which OID to return, use (0) to get the first one
</p>
<p><var>oid</var>: a pointer to store the OID (may be <code>NULL</code> )
</p>
<p><var>sizeof_oid</var>: initially holds the size of  <code>oid</code> 
</p>
<p><var>critical</var>: output variable with critical flag, may be <code>NULL</code> .
</p>
<p>This function will extract the key purpose OIDs of the Certificate
specified by the given index.  These are stored in the Extended Key
Usage extension (2.5.29.37).  See the GNUTLS_KP_* definitions for
human readable names.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the provided buffer is
not long enough, and in that case the * <code>sizeof_oid</code> will be
updated with the required size.  On success 0 is returned.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fget_005fkey_005frsa_005fraw-1"></a>
<h4 class="subheading">gnutls_x509_crq_get_key_rsa_raw</h4>
<a name="gnutls_005fx509_005fcrq_005fget_005fkey_005frsa_005fraw"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fget_005fkey_005frsa_005fraw"></a>Function: <em>int</em> <strong>gnutls_x509_crq_get_key_rsa_raw</strong> <em>(gnutls_x509_crq_t <var>crq</var>, gnutls_datum_t * <var>m</var>, gnutls_datum_t * <var>e</var>)</em></dt>
<dd><p><var>crq</var>: Holds the certificate
</p>
<p><var>m</var>: will hold the modulus
</p>
<p><var>e</var>: will hold the public exponent
</p>
<p>This function will export the RSA public key&rsquo;s parameters found in
the given structure.  The new parameters will be allocated using
<code>gnutls_malloc()</code>  and will be stored in the appropriate datum.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fget_005fkey_005fusage-1"></a>
<h4 class="subheading">gnutls_x509_crq_get_key_usage</h4>
<a name="gnutls_005fx509_005fcrq_005fget_005fkey_005fusage"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fget_005fkey_005fusage"></a>Function: <em>int</em> <strong>gnutls_x509_crq_get_key_usage</strong> <em>(gnutls_x509_crq_t <var>crq</var>, unsigned int * <var>key_usage</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>key_usage</var>: where the key usage bits will be stored
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical
</p>
<p>This function will return certificate&rsquo;s key usage, by reading the
keyUsage X.509 extension (2.5.29.15).  The key usage value will
ORed values of the: <code>GNUTLS_KEY_DIGITAL_SIGNATURE</code> ,
<code>GNUTLS_KEY_NON_REPUDIATION</code> , <code>GNUTLS_KEY_KEY_ENCIPHERMENT</code> ,
<code>GNUTLS_KEY_DATA_ENCIPHERMENT</code> , <code>GNUTLS_KEY_KEY_AGREEMENT</code> ,
<code>GNUTLS_KEY_KEY_CERT_SIGN</code> , <code>GNUTLS_KEY_CRL_SIGN</code> ,
<code>GNUTLS_KEY_ENCIPHER_ONLY</code> , <code>GNUTLS_KEY_DECIPHER_ONLY</code> .
</p>
<p><strong>Returns:</strong> the certificate key usage, or a negative error code in case of
parsing error.  If the certificate does not contain the keyUsage
extension <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  will be
returned.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fget_005fpk_005falgorithm-1"></a>
<h4 class="subheading">gnutls_x509_crq_get_pk_algorithm</h4>
<a name="gnutls_005fx509_005fcrq_005fget_005fpk_005falgorithm"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fget_005fpk_005falgorithm"></a>Function: <em>int</em> <strong>gnutls_x509_crq_get_pk_algorithm</strong> <em>(gnutls_x509_crq_t <var>crq</var>, unsigned int * <var>bits</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>bits</var>: if bits is non-<code>NULL</code>  it will hold the size of the parameters&rsquo; in bits
</p>
<p>This function will return the public key algorithm of a PKCS<code>10</code> 
certificate request.
</p>
<p>If bits is non-<code>NULL</code> , it should have enough size to hold the
parameters size in bits.  For RSA the bits returned is the modulus.
For DSA the bits returned are of the public exponent.
</p>
<p><strong>Returns:</strong> a member of the <code>gnutls_pk_algorithm_t</code>  enumeration on
success, or a negative error code on error.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fget_005fpk_005foid-1"></a>
<h4 class="subheading">gnutls_x509_crq_get_pk_oid</h4>
<a name="gnutls_005fx509_005fcrq_005fget_005fpk_005foid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fget_005fpk_005foid"></a>Function: <em>int</em> <strong>gnutls_x509_crq_get_pk_oid</strong> <em>(gnutls_x509_crq_t <var>crq</var>, char * <var>oid</var>, size_t * <var>oid_size</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>oid</var>: a pointer to a buffer to hold the OID (may be null)
</p>
<p><var>oid_size</var>: initially holds the size of  <code>oid</code> 
</p>
<p>This function will return the OID of the public key algorithm
on that certificate request. This is function
is useful in the case <code>gnutls_x509_crq_get_pk_algorithm()</code> 
returned <code>GNUTLS_PK_UNKNOWN</code> .
</p>
<p><strong>Returns:</strong> zero or a negative error code on error.
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fget_005fprivate_005fkey_005fusage_005fperiod-1"></a>
<h4 class="subheading">gnutls_x509_crq_get_private_key_usage_period</h4>
<a name="gnutls_005fx509_005fcrq_005fget_005fprivate_005fkey_005fusage_005fperiod"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fget_005fprivate_005fkey_005fusage_005fperiod"></a>Function: <em>int</em> <strong>gnutls_x509_crq_get_private_key_usage_period</strong> <em>(gnutls_x509_crq_t <var>crq</var>, time_t * <var>activation</var>, time_t * <var>expiration</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>activation</var>: The activation time
</p>
<p><var>expiration</var>: The expiration time
</p>
<p><var>critical</var>: the extension status
</p>
<p>This function will return the expiration and activation
times of the private key of the certificate.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
if the extension is not present, otherwise a negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fget_005fsignature_005falgorithm-1"></a>
<h4 class="subheading">gnutls_x509_crq_get_signature_algorithm</h4>
<a name="gnutls_005fx509_005fcrq_005fget_005fsignature_005falgorithm"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fget_005fsignature_005falgorithm"></a>Function: <em>int</em> <strong>gnutls_x509_crq_get_signature_algorithm</strong> <em>(gnutls_x509_crq_t <var>crq</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_cr_t</code>  type
</p>
<p>This function will return a value of the <code>gnutls_sign_algorithm_t</code> 
enumeration that is the signature algorithm that has been used to
sign this certificate request.
</p>
<p><strong>Returns:</strong> a <code>gnutls_sign_algorithm_t</code>  value, or a negative error code on
error.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fget_005fsignature_005foid-1"></a>
<h4 class="subheading">gnutls_x509_crq_get_signature_oid</h4>
<a name="gnutls_005fx509_005fcrq_005fget_005fsignature_005foid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fget_005fsignature_005foid"></a>Function: <em>int</em> <strong>gnutls_x509_crq_get_signature_oid</strong> <em>(gnutls_x509_crq_t <var>crq</var>, char * <var>oid</var>, size_t * <var>oid_size</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>oid</var>: a pointer to a buffer to hold the OID (may be null)
</p>
<p><var>oid_size</var>: initially holds the size of  <code>oid</code> 
</p>
<p>This function will return the OID of the signature algorithm
that has been used to sign this certificate request. This is function
is useful in the case <code>gnutls_x509_crq_get_signature_algorithm()</code> 
returned <code>GNUTLS_SIGN_UNKNOWN</code> .
</p>
<p><strong>Returns:</strong> zero or a negative error code on error.
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fget_005fsubject_005falt_005fname-1"></a>
<h4 class="subheading">gnutls_x509_crq_get_subject_alt_name</h4>
<a name="gnutls_005fx509_005fcrq_005fget_005fsubject_005falt_005fname"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fget_005fsubject_005falt_005fname"></a>Function: <em>int</em> <strong>gnutls_x509_crq_get_subject_alt_name</strong> <em>(gnutls_x509_crq_t <var>crq</var>, unsigned int <var>seq</var>, void * <var>ret</var>, size_t * <var>ret_size</var>, unsigned int * <var>ret_type</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>seq</var>: specifies the sequence number of the alt name, 0 for the
first one, 1 for the second etc.
</p>
<p><var>ret</var>: is the place where the alternative name will be copied to
</p>
<p><var>ret_size</var>: holds the size of ret.
</p>
<p><var>ret_type</var>: holds the <code>gnutls_x509_subject_alt_name_t</code>  name type
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical
(may be null)
</p>
<p>This function will return the alternative names, contained in the
given certificate.  It is the same as
<code>gnutls_x509_crq_get_subject_alt_name()</code>  except for the fact that it
will return the type of the alternative name in  <code>ret_type</code> even if
the function fails for some reason (i.e.  the buffer provided is
not enough).
</p>
<p><strong>Returns:</strong> the alternative subject name type on success, one of the
enumerated <code>gnutls_x509_subject_alt_name_t</code> .  It will return
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if  <code>ret_size</code> is not large enough to
hold the value.  In that case  <code>ret_size</code> will be updated with the
required size.  If the certificate request does not have an
Alternative name with the specified sequence number then
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  is returned.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fget_005fsubject_005falt_005fothername_005foid-1"></a>
<h4 class="subheading">gnutls_x509_crq_get_subject_alt_othername_oid</h4>
<a name="gnutls_005fx509_005fcrq_005fget_005fsubject_005falt_005fothername_005foid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fget_005fsubject_005falt_005fothername_005foid"></a>Function: <em>int</em> <strong>gnutls_x509_crq_get_subject_alt_othername_oid</strong> <em>(gnutls_x509_crq_t <var>crq</var>, unsigned int <var>seq</var>, void * <var>ret</var>, size_t * <var>ret_size</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>seq</var>: specifies the sequence number of the alt name (0 for the first one, 1 for the second etc.)
</p>
<p><var>ret</var>: is the place where the otherName OID will be copied to
</p>
<p><var>ret_size</var>: holds the size of ret.
</p>
<p>This function will extract the type OID of an otherName Subject
Alternative Name, contained in the given certificate, and return
the type as an enumerated element.
</p>
<p>This function is only useful if
<code>gnutls_x509_crq_get_subject_alt_name()</code>  returned
<code>GNUTLS_SAN_OTHERNAME</code> .
</p>
<p><strong>Returns:</strong> the alternative subject name type on success, one of the
enumerated gnutls_x509_subject_alt_name_t.  For supported OIDs,
it will return one of the virtual (GNUTLS_SAN_OTHERNAME_*) types,
e.g. <code>GNUTLS_SAN_OTHERNAME_XMPP</code> , and <code>GNUTLS_SAN_OTHERNAME</code>  for
unknown OIDs.  It will return <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if
 <code>ret_size</code> is not large enough to hold the value.  In that case
 <code>ret_size</code> will be updated with the required size.  If the
certificate does not have an Alternative name with the specified
sequence number and with the otherName type then
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  is returned.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fget_005ftlsfeatures-1"></a>
<h4 class="subheading">gnutls_x509_crq_get_tlsfeatures</h4>
<a name="gnutls_005fx509_005fcrq_005fget_005ftlsfeatures"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fget_005ftlsfeatures"></a>Function: <em>int</em> <strong>gnutls_x509_crq_get_tlsfeatures</strong> <em>(gnutls_x509_crq_t <var>crq</var>, gnutls_x509_tlsfeatures_t <var>features</var>, unsigned int <var>flags</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>crq</var>: &ndash; undescribed &ndash;
</p>
<p><var>features</var>: If the function succeeds, the
features will be stored in this variable.
</p>
<p><var>flags</var>: zero or <code>GNUTLS_EXT_FLAG_APPEND</code> 
</p>
<p><var>critical</var>: the extension status
</p>
<p>This function will get the X.509 TLS features
extension structure from the certificate request.
The returned structure needs to be freed using
<code>gnutls_x509_tlsfeatures_deinit()</code> .
</p>
<p>When the  <code>flags</code> is set to <code>GNUTLS_EXT_FLAG_APPEND</code> ,
then if the  <code>features</code> structure is empty this function will behave
identically as if the flag was not set. Otherwise if there are elements 
in the  <code>features</code> structure then they will be merged with.
</p>
<p>Note that  <code>features</code> must be initialized prior to calling this function.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.5.1
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fget_005fversion-1"></a>
<h4 class="subheading">gnutls_x509_crq_get_version</h4>
<a name="gnutls_005fx509_005fcrq_005fget_005fversion"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fget_005fversion"></a>Function: <em>int</em> <strong>gnutls_x509_crq_get_version</strong> <em>(gnutls_x509_crq_t <var>crq</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p>This function will return the version of the specified Certificate
request.
</p>
<p><strong>Returns:</strong> version of certificate request, or a negative error code on
error.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fimport-1"></a>
<h4 class="subheading">gnutls_x509_crq_import</h4>
<a name="gnutls_005fx509_005fcrq_005fimport"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fimport"></a>Function: <em>int</em> <strong>gnutls_x509_crq_import</strong> <em>(gnutls_x509_crq_t <var>crq</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>)</em></dt>
<dd><p><var>crq</var>: The data to store the parsed certificate request.
</p>
<p><var>data</var>: The DER or PEM encoded certificate.
</p>
<p><var>format</var>: One of DER or PEM
</p>
<p>This function will convert the given DER or PEM encoded certificate
request to a <code>gnutls_x509_crq_t</code>  type.  The output will be
stored in  <code>crq</code> .
</p>
<p>If the Certificate is PEM encoded it should have a header of &quot;NEW
CERTIFICATE REQUEST&quot;.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005finit-1"></a>
<h4 class="subheading">gnutls_x509_crq_init</h4>
<a name="gnutls_005fx509_005fcrq_005finit"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005finit"></a>Function: <em>int</em> <strong>gnutls_x509_crq_init</strong> <em>(gnutls_x509_crq_t * <var>crq</var>)</em></dt>
<dd><p><var>crq</var>: A pointer to the type to be initialized
</p>
<p>This function will initialize a PKCS<code>10</code>  certificate request
structure.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fprint-1"></a>
<h4 class="subheading">gnutls_x509_crq_print</h4>
<a name="gnutls_005fx509_005fcrq_005fprint"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fprint"></a>Function: <em>int</em> <strong>gnutls_x509_crq_print</strong> <em>(gnutls_x509_crq_t <var>crq</var>, gnutls_certificate_print_formats_t <var>format</var>, gnutls_datum_t * <var>out</var>)</em></dt>
<dd><p><var>crq</var>: The data to be printed
</p>
<p><var>format</var>: Indicate the format to use
</p>
<p><var>out</var>: Newly allocated datum with null terminated string.
</p>
<p>This function will pretty print a certificate request, suitable for
display to a human.
</p>
<p>The output  <code>out</code> needs to be deallocated using <code>gnutls_free()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fset_005fattribute_005fby_005foid-1"></a>
<h4 class="subheading">gnutls_x509_crq_set_attribute_by_oid</h4>
<a name="gnutls_005fx509_005fcrq_005fset_005fattribute_005fby_005foid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fset_005fattribute_005fby_005foid"></a>Function: <em>int</em> <strong>gnutls_x509_crq_set_attribute_by_oid</strong> <em>(gnutls_x509_crq_t <var>crq</var>, const char * <var>oid</var>, void * <var>buf</var>, size_t <var>buf_size</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>oid</var>: holds an Object Identifier in a null-terminated string
</p>
<p><var>buf</var>: a pointer to a structure that holds the attribute data
</p>
<p><var>buf_size</var>: holds the size of  <code>buf</code> 
</p>
<p>This function will set the attribute in the certificate request
specified by the given Object ID. The provided attribute must be be DER
encoded.
</p>
<p>Attributes in a certificate request is an optional set of data
appended to the request. Their interpretation depends on the CA policy.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fset_005fbasic_005fconstraints-1"></a>
<h4 class="subheading">gnutls_x509_crq_set_basic_constraints</h4>
<a name="gnutls_005fx509_005fcrq_005fset_005fbasic_005fconstraints"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fset_005fbasic_005fconstraints"></a>Function: <em>int</em> <strong>gnutls_x509_crq_set_basic_constraints</strong> <em>(gnutls_x509_crq_t <var>crq</var>, unsigned int <var>ca</var>, int <var>pathLenConstraint</var>)</em></dt>
<dd><p><var>crq</var>: a certificate request of type <code>gnutls_x509_crq_t</code> 
</p>
<p><var>ca</var>: true(1) or false(0) depending on the Certificate authority status.
</p>
<p><var>pathLenConstraint</var>: non-negative error codes indicate maximum length of path,
and negative error codes indicate that the pathLenConstraints field should
not be present.
</p>
<p>This function will set the basicConstraints certificate extension.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fset_005fchallenge_005fpassword-1"></a>
<h4 class="subheading">gnutls_x509_crq_set_challenge_password</h4>
<a name="gnutls_005fx509_005fcrq_005fset_005fchallenge_005fpassword"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fset_005fchallenge_005fpassword"></a>Function: <em>int</em> <strong>gnutls_x509_crq_set_challenge_password</strong> <em>(gnutls_x509_crq_t <var>crq</var>, const char * <var>pass</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>pass</var>: holds a (0)-terminated password
</p>
<p>This function will set a challenge password to be used when
revoking the request.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fset_005fdn-1"></a>
<h4 class="subheading">gnutls_x509_crq_set_dn</h4>
<a name="gnutls_005fx509_005fcrq_005fset_005fdn"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fset_005fdn"></a>Function: <em>int</em> <strong>gnutls_x509_crq_set_dn</strong> <em>(gnutls_x509_crq_t <var>crq</var>, const char * <var>dn</var>, const char ** <var>err</var>)</em></dt>
<dd><p><var>crq</var>: a certificate of type <code>gnutls_x509_crq_t</code> 
</p>
<p><var>dn</var>: a comma separated DN string (RFC4514)
</p>
<p><var>err</var>: indicates the error position (if any)
</p>
<p>This function will set the DN on the provided certificate.
The input string should be plain ASCII or UTF-8 encoded. On
DN parsing error <code>GNUTLS_E_PARSING_ERROR</code>  is returned.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fset_005fdn_005fby_005foid-1"></a>
<h4 class="subheading">gnutls_x509_crq_set_dn_by_oid</h4>
<a name="gnutls_005fx509_005fcrq_005fset_005fdn_005fby_005foid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fset_005fdn_005fby_005foid"></a>Function: <em>int</em> <strong>gnutls_x509_crq_set_dn_by_oid</strong> <em>(gnutls_x509_crq_t <var>crq</var>, const char * <var>oid</var>, unsigned int <var>raw_flag</var>, const void * <var>data</var>, unsigned int <var>sizeof_data</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>oid</var>: holds an Object Identifier in a (0)-terminated string
</p>
<p><var>raw_flag</var>: must be 0, or 1 if the data are DER encoded
</p>
<p><var>data</var>: a pointer to the input data
</p>
<p><var>sizeof_data</var>: holds the size of  <code>data</code> 
</p>
<p>This function will set the part of the name of the Certificate
request subject, specified by the given OID.  The input string
should be ASCII or UTF-8 encoded.
</p>
<p>Some helper macros with popular OIDs can be found in gnutls/x509.h
With this function you can only set the known OIDs.  You can test
for known OIDs using <code>gnutls_x509_dn_oid_known()</code> .  For OIDs that are
not known (by gnutls) you should properly DER encode your data, and
call this function with raw_flag set.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fset_005fextension_005fby_005foid-1"></a>
<h4 class="subheading">gnutls_x509_crq_set_extension_by_oid</h4>
<a name="gnutls_005fx509_005fcrq_005fset_005fextension_005fby_005foid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fset_005fextension_005fby_005foid"></a>Function: <em>int</em> <strong>gnutls_x509_crq_set_extension_by_oid</strong> <em>(gnutls_x509_crq_t <var>crq</var>, const char * <var>oid</var>, const void * <var>buf</var>, size_t <var>sizeof_buf</var>, unsigned int <var>critical</var>)</em></dt>
<dd><p><var>crq</var>: a certificate of type <code>gnutls_x509_crq_t</code> 
</p>
<p><var>oid</var>: holds an Object Identifier in null terminated string
</p>
<p><var>buf</var>: a pointer to a DER encoded data
</p>
<p><var>sizeof_buf</var>: holds the size of  <code>buf</code> 
</p>
<p><var>critical</var>: should be non-zero if the extension is to be marked as critical
</p>
<p>This function will set an the extension, by the specified OID, in
the certificate request.  The extension data should be binary data DER
encoded.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fset_005fkey-1"></a>
<h4 class="subheading">gnutls_x509_crq_set_key</h4>
<a name="gnutls_005fx509_005fcrq_005fset_005fkey"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fset_005fkey-1"></a>Function: <em>int</em> <strong>gnutls_x509_crq_set_key</strong> <em>(gnutls_x509_crq_t <var>crq</var>, gnutls_x509_privkey_t <var>key</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>key</var>: holds a private key
</p>
<p>This function will set the public parameters from the given private
key to the request.  
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fset_005fkey_005fpurpose_005foid-1"></a>
<h4 class="subheading">gnutls_x509_crq_set_key_purpose_oid</h4>
<a name="gnutls_005fx509_005fcrq_005fset_005fkey_005fpurpose_005foid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fset_005fkey_005fpurpose_005foid"></a>Function: <em>int</em> <strong>gnutls_x509_crq_set_key_purpose_oid</strong> <em>(gnutls_x509_crq_t <var>crq</var>, const void * <var>oid</var>, unsigned int <var>critical</var>)</em></dt>
<dd><p><var>crq</var>: a certificate of type <code>gnutls_x509_crq_t</code> 
</p>
<p><var>oid</var>: a pointer to a null-terminated string that holds the OID
</p>
<p><var>critical</var>: Whether this extension will be critical or not
</p>
<p>This function will set the key purpose OIDs of the Certificate.
These are stored in the Extended Key Usage extension (2.5.29.37)
See the GNUTLS_KP_* definitions for human readable names.
</p>
<p>Subsequent calls to this function will append OIDs to the OID list.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fset_005fkey_005frsa_005fraw-1"></a>
<h4 class="subheading">gnutls_x509_crq_set_key_rsa_raw</h4>
<a name="gnutls_005fx509_005fcrq_005fset_005fkey_005frsa_005fraw"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fset_005fkey_005frsa_005fraw"></a>Function: <em>int</em> <strong>gnutls_x509_crq_set_key_rsa_raw</strong> <em>(gnutls_x509_crq_t <var>crq</var>, const gnutls_datum_t * <var>m</var>, const gnutls_datum_t * <var>e</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>m</var>: holds the modulus
</p>
<p><var>e</var>: holds the public exponent
</p>
<p>This function will set the public parameters from the given private
key to the request. Only RSA keys are currently supported.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.6.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fset_005fkey_005fusage-1"></a>
<h4 class="subheading">gnutls_x509_crq_set_key_usage</h4>
<a name="gnutls_005fx509_005fcrq_005fset_005fkey_005fusage"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fset_005fkey_005fusage"></a>Function: <em>int</em> <strong>gnutls_x509_crq_set_key_usage</strong> <em>(gnutls_x509_crq_t <var>crq</var>, unsigned int <var>usage</var>)</em></dt>
<dd><p><var>crq</var>: a certificate request of type <code>gnutls_x509_crq_t</code> 
</p>
<p><var>usage</var>: an ORed sequence of the GNUTLS_KEY_* elements.
</p>
<p>This function will set the keyUsage certificate extension.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fset_005fprivate_005fkey_005fusage_005fperiod-1"></a>
<h4 class="subheading">gnutls_x509_crq_set_private_key_usage_period</h4>
<a name="gnutls_005fx509_005fcrq_005fset_005fprivate_005fkey_005fusage_005fperiod"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fset_005fprivate_005fkey_005fusage_005fperiod"></a>Function: <em>int</em> <strong>gnutls_x509_crq_set_private_key_usage_period</strong> <em>(gnutls_x509_crq_t <var>crq</var>, time_t <var>activation</var>, time_t <var>expiration</var>)</em></dt>
<dd><p><var>crq</var>: a certificate of type <code>gnutls_x509_crq_t</code> 
</p>
<p><var>activation</var>: The activation time
</p>
<p><var>expiration</var>: The expiration time
</p>
<p>This function will set the private key usage period extension (2.5.29.16).
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fset_005fsubject_005falt_005fname-1"></a>
<h4 class="subheading">gnutls_x509_crq_set_subject_alt_name</h4>
<a name="gnutls_005fx509_005fcrq_005fset_005fsubject_005falt_005fname"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fset_005fsubject_005falt_005fname"></a>Function: <em>int</em> <strong>gnutls_x509_crq_set_subject_alt_name</strong> <em>(gnutls_x509_crq_t <var>crq</var>, gnutls_x509_subject_alt_name_t <var>nt</var>, const void * <var>data</var>, unsigned int <var>data_size</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>crq</var>: a certificate request of type <code>gnutls_x509_crq_t</code> 
</p>
<p><var>nt</var>: is one of the <code>gnutls_x509_subject_alt_name_t</code>  enumerations
</p>
<p><var>data</var>: The data to be set
</p>
<p><var>data_size</var>: The size of data to be set
</p>
<p><var>flags</var>: <code>GNUTLS_FSAN_SET</code>  to clear previous data or
<code>GNUTLS_FSAN_APPEND</code>  to append.
</p>
<p>This function will set the subject alternative name certificate
extension.  It can set the following types:
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fset_005fsubject_005falt_005fothername-1"></a>
<h4 class="subheading">gnutls_x509_crq_set_subject_alt_othername</h4>
<a name="gnutls_005fx509_005fcrq_005fset_005fsubject_005falt_005fothername"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fset_005fsubject_005falt_005fothername"></a>Function: <em>int</em> <strong>gnutls_x509_crq_set_subject_alt_othername</strong> <em>(gnutls_x509_crq_t <var>crq</var>, const char * <var>oid</var>, const void * <var>data</var>, unsigned int <var>data_size</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>crq</var>: a certificate request of type <code>gnutls_x509_crq_t</code> 
</p>
<p><var>oid</var>: is the othername OID
</p>
<p><var>data</var>: The data to be set
</p>
<p><var>data_size</var>: The size of data to be set
</p>
<p><var>flags</var>: <code>GNUTLS_FSAN_SET</code>  to clear previous data or
<code>GNUTLS_FSAN_APPEND</code>  to append.
</p>
<p>This function will set the subject alternative name certificate
extension.  It can set the following types:
</p>
<p>The values set must be binary values and must be properly DER encoded.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fset_005ftlsfeatures-1"></a>
<h4 class="subheading">gnutls_x509_crq_set_tlsfeatures</h4>
<a name="gnutls_005fx509_005fcrq_005fset_005ftlsfeatures"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fset_005ftlsfeatures"></a>Function: <em>int</em> <strong>gnutls_x509_crq_set_tlsfeatures</strong> <em>(gnutls_x509_crq_t <var>crq</var>, gnutls_x509_tlsfeatures_t <var>features</var>)</em></dt>
<dd><p><var>crq</var>: &ndash; undescribed &ndash;
</p>
<p><var>features</var>: If the function succeeds, the
features will be added to the certificate
request.
</p>
<p>This function will set the certificate request&rsquo;s
X.509 TLS extension from the given structure.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.5.1
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fset_005fversion-1"></a>
<h4 class="subheading">gnutls_x509_crq_set_version</h4>
<a name="gnutls_005fx509_005fcrq_005fset_005fversion"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fset_005fversion"></a>Function: <em>int</em> <strong>gnutls_x509_crq_set_version</strong> <em>(gnutls_x509_crq_t <var>crq</var>, unsigned int <var>version</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>version</var>: holds the version number, for v1 Requests must be 1
</p>
<p>This function will set the version of the certificate request.  For
version 1 requests this must be one.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fsign2-1"></a>
<h4 class="subheading">gnutls_x509_crq_sign2</h4>
<a name="gnutls_005fx509_005fcrq_005fsign2"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fsign2-1"></a>Function: <em>int</em> <strong>gnutls_x509_crq_sign2</strong> <em>(gnutls_x509_crq_t <var>crq</var>, gnutls_x509_privkey_t <var>key</var>, gnutls_digest_algorithm_t <var>dig</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>key</var>: holds a private key
</p>
<p><var>dig</var>: The message digest to use, i.e., <code>GNUTLS_DIG_SHA1</code> 
</p>
<p><var>flags</var>: must be 0
</p>
<p>This function will sign the certificate request with a private key.
This must be the same key as the one used in
<code>gnutls_x509_crt_set_key()</code>  since a certificate request is self
signed.
</p>
<p>This must be the last step in a certificate request generation
since all the previously set parameters are now signed.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
<code>GNUTLS_E_ASN1_VALUE_NOT_FOUND</code>  is returned if you didn&rsquo;t set all
information in the certificate request (e.g., the version using
<code>gnutls_x509_crq_set_version()</code> ).
</p></dd></dl>

<a name="gnutls_005fx509_005fcrq_005fverify-1"></a>
<h4 class="subheading">gnutls_x509_crq_verify</h4>
<a name="gnutls_005fx509_005fcrq_005fverify"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrq_005fverify"></a>Function: <em>int</em> <strong>gnutls_x509_crq_verify</strong> <em>(gnutls_x509_crq_t <var>crq</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>crq</var>: is the crq to be verified
</p>
<p><var>flags</var>: Flags that may be used to change the verification algorithm. Use OR of the gnutls_certificate_verify_flags enumerations.
</p>
<p>This function will verify self signature in the certificate
request and return its status.
</p>
<p><strong>Returns:</strong> In case of a verification failure <code>GNUTLS_E_PK_SIG_VERIFY_FAILED</code>  
is returned, and zero or positive code on success.
</p>
<p>Since 2.12.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fcheck_005femail-1"></a>
<h4 class="subheading">gnutls_x509_crt_check_email</h4>
<a name="gnutls_005fx509_005fcrt_005fcheck_005femail"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fcheck_005femail"></a>Function: <em>int</em> <strong>gnutls_x509_crt_check_email</strong> <em>(gnutls_x509_crt_t <var>cert</var>, const char * <var>email</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>cert</var>: should contain an gnutls_x509_crt_t type
</p>
<p><var>email</var>: A null terminated string that contains an email address (RFC822)
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function will check if the given certificate&rsquo;s subject matches
the given email address.
</p>
<p><strong>Returns:</strong> non-zero for a successful match, and zero on failure.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fcheck_005fhostname-1"></a>
<h4 class="subheading">gnutls_x509_crt_check_hostname</h4>
<a name="gnutls_005fx509_005fcrt_005fcheck_005fhostname"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fcheck_005fhostname"></a>Function: <em>unsigned</em> <strong>gnutls_x509_crt_check_hostname</strong> <em>(gnutls_x509_crt_t <var>cert</var>, const char * <var>hostname</var>)</em></dt>
<dd><p><var>cert</var>: should contain an gnutls_x509_crt_t type
</p>
<p><var>hostname</var>: A null terminated string that contains a DNS name
</p>
<p>This function will check if the given certificate&rsquo;s subject matches
the given hostname.  This is a basic implementation of the matching
described in RFC6125, and takes into account wildcards,
and the DNSName/IPAddress subject alternative name PKIX extension.
</p>
<p>For details see also <code>gnutls_x509_crt_check_hostname2()</code> .
</p>
<p><strong>Returns:</strong> non-zero for a successful match, and zero on failure.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fcheck_005fhostname2-1"></a>
<h4 class="subheading">gnutls_x509_crt_check_hostname2</h4>
<a name="gnutls_005fx509_005fcrt_005fcheck_005fhostname2"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fcheck_005fhostname2"></a>Function: <em>unsigned</em> <strong>gnutls_x509_crt_check_hostname2</strong> <em>(gnutls_x509_crt_t <var>cert</var>, const char * <var>hostname</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>cert</var>: should contain an gnutls_x509_crt_t type
</p>
<p><var>hostname</var>: A null terminated string that contains a DNS name
</p>
<p><var>flags</var>: gnutls_certificate_verify_flags
</p>
<p>This function will check if the given certificate&rsquo;s subject matches
the given hostname.  This is a basic implementation of the matching
described in RFC6125, and takes into account wildcards,
and the DNSName/IPAddress subject alternative name PKIX extension.
</p>
<p>IPv4 addresses are accepted by this function in the dotted-decimal
format (e.g, ddd.ddd.ddd.ddd), and IPv6 addresses in the hexadecimal
x:x:x:x:x:x:x:x format. For them the IPAddress subject alternative
name extension is consulted, as well as the DNSNames in case of a non-match.
The latter fallback exists due to misconfiguration of many servers
which place an IPAddress inside the DNSName extension.
</p>
<p>When the flag <code>GNUTLS_VERIFY_DO_NOT_ALLOW_WILDCARDS</code>  is specified no
wildcards are considered. Otherwise they are only considered if the
domain name consists of three components or more, and the wildcard
starts at the leftmost position.
</p>
<p><strong>Returns:</strong> non-zero for a successful match, and zero on failure.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fcheck_005fissuer-1"></a>
<h4 class="subheading">gnutls_x509_crt_check_issuer</h4>
<a name="gnutls_005fx509_005fcrt_005fcheck_005fissuer"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fcheck_005fissuer"></a>Function: <em>unsigned</em> <strong>gnutls_x509_crt_check_issuer</strong> <em>(gnutls_x509_crt_t <var>cert</var>, gnutls_x509_crt_t <var>issuer</var>)</em></dt>
<dd><p><var>cert</var>: is the certificate to be checked
</p>
<p><var>issuer</var>: is the certificate of a possible issuer
</p>
<p>This function will check if the given certificate was issued by the
given issuer. It checks the DN fields and the authority
key identifier and subject key identifier fields match.
</p>
<p>If the same certificate is provided at the  <code>cert</code> and  <code>issuer</code> fields,
it will check whether the certificate is self-signed.
</p>
<p><strong>Returns:</strong> It will return true (1) if the given certificate is issued
by the given issuer, and false (0) if not.  
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fcheck_005frevocation-1"></a>
<h4 class="subheading">gnutls_x509_crt_check_revocation</h4>
<a name="gnutls_005fx509_005fcrt_005fcheck_005frevocation"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fcheck_005frevocation"></a>Function: <em>int</em> <strong>gnutls_x509_crt_check_revocation</strong> <em>(gnutls_x509_crt_t <var>cert</var>, const gnutls_x509_crl_t * <var>crl_list</var>, unsigned <var>crl_list_length</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>crl_list</var>: should contain a list of gnutls_x509_crl_t types
</p>
<p><var>crl_list_length</var>: the length of the crl_list
</p>
<p>This function will return check if the given certificate is
revoked.  It is assumed that the CRLs have been verified before.
</p>
<p><strong>Returns:</strong> 0 if the certificate is NOT revoked, and 1 if it is.  A
negative error code is returned on error.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fcpy_005fcrl_005fdist_005fpoints-1"></a>
<h4 class="subheading">gnutls_x509_crt_cpy_crl_dist_points</h4>
<a name="gnutls_005fx509_005fcrt_005fcpy_005fcrl_005fdist_005fpoints"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fcpy_005fcrl_005fdist_005fpoints"></a>Function: <em>int</em> <strong>gnutls_x509_crt_cpy_crl_dist_points</strong> <em>(gnutls_x509_crt_t <var>dst</var>, gnutls_x509_crt_t <var>src</var>)</em></dt>
<dd><p><var>dst</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>src</var>: the certificate where the dist points will be copied from
</p>
<p>This function will copy the CRL distribution points certificate
extension, from the source to the destination certificate.
This may be useful to copy from a CA certificate to issued ones.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fdeinit-1"></a>
<h4 class="subheading">gnutls_x509_crt_deinit</h4>
<a name="gnutls_005fx509_005fcrt_005fdeinit"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fdeinit"></a>Function: <em>void</em> <strong>gnutls_x509_crt_deinit</strong> <em>(gnutls_x509_crt_t <var>cert</var>)</em></dt>
<dd><p><var>cert</var>: The data to be deinitialized
</p>
<p>This function will deinitialize a certificate structure.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fequals-1"></a>
<h4 class="subheading">gnutls_x509_crt_equals</h4>
<a name="gnutls_005fx509_005fcrt_005fequals"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fequals"></a>Function: <em>unsigned</em> <strong>gnutls_x509_crt_equals</strong> <em>(gnutls_x509_crt_t <var>cert1</var>, gnutls_x509_crt_t <var>cert2</var>)</em></dt>
<dd><p><var>cert1</var>: The first certificate
</p>
<p><var>cert2</var>: The second certificate
</p>
<p>This function will compare two X.509 certificate structures.
</p>
<p><strong>Returns:</strong> On equality non-zero is returned, otherwise zero.
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fequals2-1"></a>
<h4 class="subheading">gnutls_x509_crt_equals2</h4>
<a name="gnutls_005fx509_005fcrt_005fequals2"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fequals2"></a>Function: <em>unsigned</em> <strong>gnutls_x509_crt_equals2</strong> <em>(gnutls_x509_crt_t <var>cert1</var>, gnutls_datum_t * <var>der</var>)</em></dt>
<dd><p><var>cert1</var>: The first certificate
</p>
<p><var>der</var>: A DER encoded certificate
</p>
<p>This function will compare an X.509 certificate structures, with DER
encoded certificate data.
</p>
<p><strong>Returns:</strong> On equality non-zero is returned, otherwise zero.
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fexport-1"></a>
<h4 class="subheading">gnutls_x509_crt_export</h4>
<a name="gnutls_005fx509_005fcrt_005fexport"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fexport"></a>Function: <em>int</em> <strong>gnutls_x509_crt_export</strong> <em>(gnutls_x509_crt_t <var>cert</var>, gnutls_x509_crt_fmt_t <var>format</var>, void * <var>output_data</var>, size_t * <var>output_data_size</var>)</em></dt>
<dd><p><var>cert</var>: Holds the certificate
</p>
<p><var>format</var>: the format of output params. One of PEM or DER.
</p>
<p><var>output_data</var>: will contain a certificate PEM or DER encoded
</p>
<p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)
</p>
<p>This function will export the certificate to DER or PEM format.
</p>
<p>If the buffer provided is not long enough to hold the output, then
*output_data_size is updated and GNUTLS_E_SHORT_MEMORY_BUFFER will
be returned.
</p>
<p>If the structure is PEM encoded, it will have a header
of &quot;BEGIN CERTIFICATE&quot;.
</p>
<p><strong>Returns:</strong> In case of failure a negative error code will be
returned, and 0 on success.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fexport2-1"></a>
<h4 class="subheading">gnutls_x509_crt_export2</h4>
<a name="gnutls_005fx509_005fcrt_005fexport2"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fexport2"></a>Function: <em>int</em> <strong>gnutls_x509_crt_export2</strong> <em>(gnutls_x509_crt_t <var>cert</var>, gnutls_x509_crt_fmt_t <var>format</var>, gnutls_datum_t * <var>out</var>)</em></dt>
<dd><p><var>cert</var>: Holds the certificate
</p>
<p><var>format</var>: the format of output params. One of PEM or DER.
</p>
<p><var>out</var>: will contain a certificate PEM or DER encoded
</p>
<p>This function will export the certificate to DER or PEM format.
The output buffer is allocated using <code>gnutls_malloc()</code> .
</p>
<p>If the structure is PEM encoded, it will have a header
of &quot;BEGIN CERTIFICATE&quot;.
</p>
<p><strong>Returns:</strong> In case of failure a negative error code will be
returned, and 0 on success.
</p>
<p><strong>Since:</strong> 3.1.3
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005factivation_005ftime-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_activation_time</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005factivation_005ftime"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005factivation_005ftime"></a>Function: <em>time_t</em> <strong>gnutls_x509_crt_get_activation_time</strong> <em>(gnutls_x509_crt_t <var>cert</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p>This function will return the time this Certificate was or will be
activated.
</p>
<p><strong>Returns:</strong> activation time, or (time_t)-1 on error.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fauthority_005finfo_005faccess-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_authority_info_access</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fauthority_005finfo_005faccess"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fauthority_005finfo_005faccess"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_authority_info_access</strong> <em>(gnutls_x509_crt_t <var>crt</var>, unsigned int <var>seq</var>, int <var>what</var>, gnutls_datum_t * <var>data</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>crt</var>: Holds the certificate
</p>
<p><var>seq</var>: specifies the sequence number of the access descriptor (0 for the first one, 1 for the second etc.)
</p>
<p><var>what</var>: what data to get, a <code>gnutls_info_access_what_t</code>  type.
</p>
<p><var>data</var>: output data to be freed with <code>gnutls_free()</code> .
</p>
<p><var>critical</var>: pointer to output integer that is set to non-zero if the extension is marked as critical (may be <code>NULL</code> )
</p>
<p>Note that a simpler API to access the authority info data is provided
by <code>gnutls_x509_aia_get()</code>  and <code>gnutls_x509_ext_import_aia()</code> .
</p>
<p>This function extracts the Authority Information Access (AIA)
extension, see RFC 5280 section 4.2.2.1 for more information.  The
AIA extension holds a sequence of AccessDescription (AD) data.
</p>
<p>The  <code>seq</code> input parameter is used to indicate which member of the
sequence the caller is interested in.  The first member is 0, the
second member 1 and so on.  When the  <code>seq</code> value is out of bounds,
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  is returned.
</p>
<p>The type of data returned in  <code>data</code> is specified via  <code>what</code> which
should be <code>gnutls_info_access_what_t</code>  values.
</p>
<p>If  <code>what</code> is <code>GNUTLS_IA_ACCESSMETHOD_OID</code>  then  <code>data</code> will hold the
accessMethod OID (e.g., &quot;1.3.6.1.5.5.7.48.1&quot;).
</p>
<p>If  <code>what</code> is <code>GNUTLS_IA_ACCESSLOCATION_GENERALNAME_TYPE</code> ,  <code>data</code> will
hold the accessLocation GeneralName type (e.g.,
&quot;uniformResourceIdentifier&quot;).
</p>
<p>If  <code>what</code> is <code>GNUTLS_IA_URI</code> ,  <code>data</code> will hold the accessLocation URI
data.  Requesting this  <code>what</code> value leads to an error if the
accessLocation is not of the &quot;uniformResourceIdentifier&quot; type. 
</p>
<p>If  <code>what</code> is <code>GNUTLS_IA_OCSP_URI</code> ,  <code>data</code> will hold the OCSP URI.
Requesting this  <code>what</code> value leads to an error if the accessMethod
is not 1.3.6.1.5.5.7.48.1 aka OCSP, or if accessLocation is not of
the &quot;uniformResourceIdentifier&quot; type. In that case <code>GNUTLS_E_UNKNOWN_ALGORITHM</code> 
will be returned, and  <code>seq</code> should be increased and this function
called again.
</p>
<p>If  <code>what</code> is <code>GNUTLS_IA_CAISSUERS_URI</code> ,  <code>data</code> will hold the caIssuers
URI.  Requesting this  <code>what</code> value leads to an error if the
accessMethod is not 1.3.6.1.5.5.7.48.2 aka caIssuers, or if
accessLocation is not of the &quot;uniformResourceIdentifier&quot; type.
In that case handle as in <code>GNUTLS_IA_OCSP_URI</code> .
</p>
<p>More  <code>what</code> values may be allocated in the future as needed.
</p>
<p>If  <code>data</code> is NULL, the function does the same without storing the
output data, that is, it will set  <code>critical</code> and do error checking
as usual.
</p>
<p>The value of the critical flag is returned in * <code>critical</code> .  Supply a
NULL  <code>critical</code> if you want the function to make sure the extension
is non-critical, as required by RFC 5280.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, <code>GNUTLS_E_INVALID_REQUEST</code>  on
invalid  <code>crt</code> , <code>GNUTLS_E_CONSTRAINT_ERROR</code>  if the extension is
incorrectly marked as critical (use a non-NULL  <code>critical</code> to
override), <code>GNUTLS_E_UNKNOWN_ALGORITHM</code>  if the requested OID does
not match (e.g., when using <code>GNUTLS_IA_OCSP_URI</code> ), otherwise a
negative error code.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fauthority_005fkey_005fgn_005fserial-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_authority_key_gn_serial</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fauthority_005fkey_005fgn_005fserial"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fauthority_005fkey_005fgn_005fserial"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_authority_key_gn_serial</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned int <var>seq</var>, void * <var>alt</var>, size_t * <var>alt_size</var>, unsigned int * <var>alt_type</var>, void * <var>serial</var>, size_t * <var>serial_size</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>seq</var>: specifies the sequence number of the alt name (0 for the first one, 1 for the second etc.)
</p>
<p><var>alt</var>: is the place where the alternative name will be copied to
</p>
<p><var>alt_size</var>: holds the size of alt.
</p>
<p><var>alt_type</var>: holds the type of the alternative name (one of gnutls_x509_subject_alt_name_t).
</p>
<p><var>serial</var>: buffer to store the serial number (may be null)
</p>
<p><var>serial_size</var>: Holds the size of the serial field (may be null)
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical (may be null)
</p>
<p>This function will return the X.509 authority key
identifier when stored as a general name (authorityCertIssuer) 
and serial number.
</p>
<p>Because more than one general names might be stored
 <code>seq</code> can be used as a counter to request them all until 
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  is returned.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
if the extension is not present, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fauthority_005fkey_005fid-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_authority_key_id</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fauthority_005fkey_005fid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fauthority_005fkey_005fid"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_authority_key_id</strong> <em>(gnutls_x509_crt_t <var>cert</var>, void * <var>id</var>, size_t * <var>id_size</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>id</var>: The place where the identifier will be copied
</p>
<p><var>id_size</var>: Holds the size of the id field.
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical (may be null)
</p>
<p>This function will return the X.509v3 certificate authority&rsquo;s key
identifier.  This is obtained by the X.509 Authority Key
identifier extension field (2.5.29.35). Note that this function
only returns the keyIdentifier field of the extension and
<code>GNUTLS_E_X509_UNSUPPORTED_EXTENSION</code> , if the extension contains
the name and serial number of the certificate. In that case
<code>gnutls_x509_crt_get_authority_key_gn_serial()</code>  may be used.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
if the extension is not present, otherwise a negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fbasic_005fconstraints-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_basic_constraints</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fbasic_005fconstraints"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fbasic_005fconstraints"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_basic_constraints</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned int * <var>critical</var>, unsigned int * <var>ca</var>, int * <var>pathlen</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical
</p>
<p><var>ca</var>: pointer to output integer indicating CA status, may be NULL,
value is 1 if the certificate CA flag is set, 0 otherwise.
</p>
<p><var>pathlen</var>: pointer to output integer indicating path length (may be
NULL), non-negative error codes indicate a present pathLenConstraint
field and the actual value, -1 indicate that the field is absent.
</p>
<p>This function will read the certificate&rsquo;s basic constraints, and
return the certificates CA status.  It reads the basicConstraints
X.509 extension (2.5.29.19).
</p>
<p><strong>Returns:</strong> If the certificate is a CA a positive value will be
returned, or (0) if the certificate does not have CA flag set.  A
negative error code may be returned in case of errors.  If the
certificate does not contain the basicConstraints extension
GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE will be returned.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fca_005fstatus-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_ca_status</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fca_005fstatus"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fca_005fstatus"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_ca_status</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical
</p>
<p>This function will return certificates CA status, by reading the
basicConstraints X.509 extension (2.5.29.19). If the certificate is
a CA a positive value will be returned, or (0) if the certificate
does not have CA flag set.
</p>
<p>Use <code>gnutls_x509_crt_get_basic_constraints()</code>  if you want to read the
pathLenConstraint field too.
</p>
<p><strong>Returns:</strong> If the certificate is a CA a positive value will be
returned, or (0) if the certificate does not have CA flag set.  A
negative error code may be returned in case of errors.  If the
certificate does not contain the basicConstraints extension
GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE will be returned.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fcrl_005fdist_005fpoints-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_crl_dist_points</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fcrl_005fdist_005fpoints"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fcrl_005fdist_005fpoints"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_crl_dist_points</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned int <var>seq</var>, void * <var>san</var>, size_t * <var>san_size</var>, unsigned int * <var>reason_flags</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>seq</var>: specifies the sequence number of the distribution point (0 for the first one, 1 for the second etc.)
</p>
<p><var>san</var>: is the place where the distribution point will be copied to
</p>
<p><var>san_size</var>: holds the size of ret.
</p>
<p><var>reason_flags</var>: Revocation reasons. An ORed sequence of flags from <code>gnutls_x509_crl_reason_flags_t</code> .
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical (may be null)
</p>
<p>This function retrieves the CRL distribution points (2.5.29.31),
contained in the given certificate in the X509v3 Certificate
Extensions.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  and updates  <code>ret_size</code> if
 <code>ret_size</code> is not enough to hold the distribution point, or the
type of the distribution point if everything was ok. The type is
one of the enumerated <code>gnutls_x509_subject_alt_name_t</code> .  If the
certificate does not have an Alternative name with the specified
sequence number then <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  is
returned.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fdn-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_dn</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fdn"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fdn"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_dn</strong> <em>(gnutls_x509_crt_t <var>cert</var>, char * <var>buf</var>, size_t * <var>buf_size</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>buf</var>: a pointer to a structure to hold the name (may be null)
</p>
<p><var>buf_size</var>: initially holds the size of  <code>buf</code> 
</p>
<p>This function will copy the name of the Certificate in the provided
buffer. The name will be in the form &quot;C=xxxx,O=yyyy,CN=zzzz&quot; as
described in RFC4514. The output string will be ASCII or UTF-8
encoded, depending on the certificate data.
</p>
<p>If  <code>buf</code> is null then only the size will be filled. 
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the provided buffer is not
long enough, and in that case the  <code>buf_size</code> will be updated
with the required size. <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  if
the DN does not exist, or another error value on error. On success 0 is returned.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fdn2-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_dn2</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fdn2"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fdn2-1"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_dn2</strong> <em>(gnutls_x509_crt_t <var>cert</var>, gnutls_datum_t * <var>dn</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>dn</var>: a pointer to a structure to hold the name
</p>
<p>This function will allocate buffer and copy the name of the Certificate.
The name will be in the form &quot;C=xxxx,O=yyyy,CN=zzzz&quot; as
described in RFC4514. The output string will be ASCII or UTF-8
encoded, depending on the certificate data.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.10
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fdn_005fby_005foid-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_dn_by_oid</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fdn_005fby_005foid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fdn_005fby_005foid"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_dn_by_oid</strong> <em>(gnutls_x509_crt_t <var>cert</var>, const char * <var>oid</var>, unsigned <var>indx</var>, unsigned int <var>raw_flag</var>, void * <var>buf</var>, size_t * <var>buf_size</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>oid</var>: holds an Object Identified in null terminated string
</p>
<p><var>indx</var>: In case multiple same OIDs exist in the RDN, this specifies which to send. Use (0) to get the first one.
</p>
<p><var>raw_flag</var>: If non-zero returns the raw DER data of the DN part.
</p>
<p><var>buf</var>: a pointer where the DN part will be copied (may be null).
</p>
<p><var>buf_size</var>: initially holds the size of  <code>buf</code> 
</p>
<p>This function will extract the part of the name of the Certificate
subject specified by the given OID. The output, if the raw flag is
not used, will be encoded as described in RFC4514. Thus a string
that is ASCII or UTF-8 encoded, depending on the certificate data.
</p>
<p>Some helper macros with popular OIDs can be found in gnutls/x509.h
If raw flag is (0), this function will only return known OIDs as
text. Other OIDs will be DER encoded, as described in RFC4514 &ndash;
in hex format with a &rsquo;#&rsquo; prefix.  You can check about known OIDs
using <code>gnutls_x509_dn_oid_known()</code> .
</p>
<p>If  <code>buf</code> is null then only the size will be filled. If the  <code>raw_flag</code> is not specified the output is always null terminated, although the
 <code>buf_size</code> will not include the null character.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the provided buffer is not
long enough, and in that case the  <code>buf_size</code> will be updated with
the required size. <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  if there 
are no data in the current index. On success 0 is returned.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fdn_005foid-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_dn_oid</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fdn_005foid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fdn_005foid"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_dn_oid</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned <var>indx</var>, void * <var>oid</var>, size_t * <var>oid_size</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>indx</var>: This specifies which OID to return. Use (0) to get the first one.
</p>
<p><var>oid</var>: a pointer to a buffer to hold the OID (may be null)
</p>
<p><var>oid_size</var>: initially holds the size of  <code>oid</code> 
</p>
<p>This function will extract the OIDs of the name of the Certificate
subject specified by the given index.
</p>
<p>If  <code>oid</code> is null then only the size will be filled. The  <code>oid</code> returned will be null terminated, although  <code>oid_size</code> will not
account for the trailing null.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the provided buffer is not
long enough, and in that case the  <code>buf_size</code> will be updated with
the required size. <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  if there 
are no data in the current index. On success 0 is returned.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fexpiration_005ftime-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_expiration_time</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fexpiration_005ftime"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fexpiration_005ftime"></a>Function: <em>time_t</em> <strong>gnutls_x509_crt_get_expiration_time</strong> <em>(gnutls_x509_crt_t <var>cert</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p>This function will return the time this Certificate was or will be
expired.
</p>
<p>The no well defined expiration time can be checked against with the
<code>GNUTLS_X509_NO_WELL_DEFINED_EXPIRATION</code>  macro.
</p>
<p><strong>Returns:</strong> expiration time, or (time_t)-1 on error.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fextension_005fby_005foid-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_extension_by_oid</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fextension_005fby_005foid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fextension_005fby_005foid"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_extension_by_oid</strong> <em>(gnutls_x509_crt_t <var>cert</var>, const char * <var>oid</var>, unsigned <var>indx</var>, void * <var>buf</var>, size_t * <var>buf_size</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>oid</var>: holds an Object Identified in null terminated string
</p>
<p><var>indx</var>: In case multiple same OIDs exist in the extensions, this specifies which to send. Use (0) to get the first one.
</p>
<p><var>buf</var>: a pointer to a structure to hold the name (may be null)
</p>
<p><var>buf_size</var>: initially holds the size of  <code>buf</code> 
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical
</p>
<p>This function will return the extension specified by the OID in the
certificate.  The extensions will be returned as binary data DER
encoded, in the provided buffer.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned. If the certificate does not
contain the specified extension
GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE will be returned.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fextension_005fby_005foid2-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_extension_by_oid2</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fextension_005fby_005foid2"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fextension_005fby_005foid2"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_extension_by_oid2</strong> <em>(gnutls_x509_crt_t <var>cert</var>, const char * <var>oid</var>, unsigned <var>indx</var>, gnutls_datum_t * <var>output</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>oid</var>: holds an Object Identified in null terminated string
</p>
<p><var>indx</var>: In case multiple same OIDs exist in the extensions, this specifies which to send. Use (0) to get the first one.
</p>
<p><var>output</var>: will hold the allocated extension data
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical
</p>
<p>This function will return the extension specified by the OID in the
certificate.  The extensions will be returned as binary data DER
encoded, in the provided buffer.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned. If the certificate does not
contain the specified extension
GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE will be returned.
</p>
<p><strong>Since:</strong> 3.3.8
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fextension_005fdata-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_extension_data</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fextension_005fdata"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fextension_005fdata"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_extension_data</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned <var>indx</var>, void * <var>data</var>, size_t * <var>sizeof_data</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>indx</var>: Specifies which extension OID to send. Use (0) to get the first one.
</p>
<p><var>data</var>: a pointer to a structure to hold the data (may be null)
</p>
<p><var>sizeof_data</var>: initially holds the size of  <code>data</code> 
</p>
<p>This function will return the requested extension data in the
certificate.  The extension data will be stored in the
provided buffer.
</p>
<p>Use <code>gnutls_x509_crt_get_extension_info()</code>  to extract the OID and
critical flag.  Use <code>gnutls_x509_crt_get_extension_by_oid()</code>  instead,
if you want to get data indexed by the extension OID rather than
sequence.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.  If you have reached the
last extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
will be returned.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fextension_005fdata2-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_extension_data2</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fextension_005fdata2"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fextension_005fdata2"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_extension_data2</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned <var>indx</var>, gnutls_datum_t * <var>data</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>indx</var>: Specifies which extension OID to read. Use (0) to get the first one.
</p>
<p><var>data</var>: will contain the extension DER-encoded data
</p>
<p>This function will return the requested by the index extension data in the
certificate.  The extension data will be allocated using
<code>gnutls_malloc()</code> .
</p>
<p>Use <code>gnutls_x509_crt_get_extension_info()</code>  to extract the OID.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.  If you have reached the
last extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
will be returned.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fextension_005finfo-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_extension_info</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fextension_005finfo"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fextension_005finfo"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_extension_info</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned <var>indx</var>, void * <var>oid</var>, size_t * <var>oid_size</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>indx</var>: Specifies which extension OID to send. Use (0) to get the first one.
</p>
<p><var>oid</var>: a pointer to a structure to hold the OID
</p>
<p><var>oid_size</var>: initially holds the maximum size of  <code>oid</code> , on return
holds actual size of  <code>oid</code> .
</p>
<p><var>critical</var>: output variable with critical flag, may be NULL.
</p>
<p>This function will return the requested extension OID in the
certificate, and the critical flag for it.  The extension OID will
be stored as a string in the provided buffer.  Use
<code>gnutls_x509_crt_get_extension()</code>  to extract the data.
</p>
<p>If the buffer provided is not long enough to hold the output, then
 <code>oid_size</code> is updated and <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  will be
returned. The  <code>oid</code> returned will be null terminated, although 
 <code>oid_size</code> will not account for the trailing null.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.  If you have reached the
last extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
will be returned.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fextension_005foid-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_extension_oid</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fextension_005foid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fextension_005foid"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_extension_oid</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned <var>indx</var>, void * <var>oid</var>, size_t * <var>oid_size</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>indx</var>: Specifies which extension OID to send. Use (0) to get the first one.
</p>
<p><var>oid</var>: a pointer to a structure to hold the OID (may be null)
</p>
<p><var>oid_size</var>: initially holds the size of  <code>oid</code> 
</p>
<p>This function will return the requested extension OID in the certificate.
The extension OID will be stored as a string in the provided buffer.
</p>
<p>The  <code>oid</code> returned will be null terminated, although  <code>oid_size</code> will not
account for the trailing null.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.  If you have reached the
last extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
will be returned.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005ffingerprint-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_fingerprint</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005ffingerprint"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005ffingerprint"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_fingerprint</strong> <em>(gnutls_x509_crt_t <var>cert</var>, gnutls_digest_algorithm_t <var>algo</var>, void * <var>buf</var>, size_t * <var>buf_size</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>algo</var>: is a digest algorithm
</p>
<p><var>buf</var>: a pointer to a structure to hold the fingerprint (may be null)
</p>
<p><var>buf_size</var>: initially holds the size of  <code>buf</code> 
</p>
<p>This function will calculate and copy the certificate&rsquo;s fingerprint
in the provided buffer. The fingerprint is a hash of the DER-encoded
data of the certificate.
</p>
<p>If the buffer is null then only the size will be filled.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the provided buffer is
not long enough, and in that case the *buf_size will be updated
with the required size.  On success 0 is returned.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fissuer-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_issuer</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fissuer"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fissuer"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_issuer</strong> <em>(gnutls_x509_crt_t <var>cert</var>, gnutls_x509_dn_t * <var>dn</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>dn</var>: output variable with pointer to uint8_t DN
</p>
<p>Return the Certificate&rsquo;s Issuer DN as a <code>gnutls_x509_dn_t</code>  data type,
that can be decoded using <code>gnutls_x509_dn_get_rdn_ava()</code> . 
</p>
<p>Note that  <code>dn</code> should be treated as constant. Because it points 
into the  <code>cert</code> object, you should not use  <code>dn</code> after  <code>cert</code> is
deallocated.
</p>
<p><strong>Returns:</strong> Returns 0 on success, or an error code.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fissuer_005falt_005fname-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_issuer_alt_name</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fissuer_005falt_005fname"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fissuer_005falt_005fname"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_issuer_alt_name</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned int <var>seq</var>, void * <var>ian</var>, size_t * <var>ian_size</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>seq</var>: specifies the sequence number of the alt name (0 for the first one, 1 for the second etc.)
</p>
<p><var>ian</var>: is the place where the alternative name will be copied to
</p>
<p><var>ian_size</var>: holds the size of ian.
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical (may be null)
</p>
<p>This function retrieves the Issuer Alternative Name (2.5.29.18),
contained in the given certificate in the X509v3 Certificate
Extensions.
</p>
<p>When the SAN type is otherName, it will extract the data in the
otherName&rsquo;s value field, and <code>GNUTLS_SAN_OTHERNAME</code>  is returned.
You may use <code>gnutls_x509_crt_get_subject_alt_othername_oid()</code>  to get
the corresponding OID and the &quot;virtual&quot; SAN types (e.g.,
<code>GNUTLS_SAN_OTHERNAME_XMPP</code> ).
</p>
<p>If an otherName OID is known, the data will be decoded.  Otherwise
the returned data will be DER encoded, and you will have to decode
it yourself.  Currently, only the RFC 3920 id-on-xmppAddr Issuer
AltName is recognized.
</p>
<p><strong>Returns:</strong> the alternative issuer name type on success, one of the
enumerated <code>gnutls_x509_subject_alt_name_t</code> .  It will return
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if  <code>ian_size</code> is not large enough
to hold the value.  In that case  <code>ian_size</code> will be updated with
the required size.  If the certificate does not have an
Alternative name with the specified sequence number then
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  is returned.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fissuer_005falt_005fname2-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_issuer_alt_name2</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fissuer_005falt_005fname2"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fissuer_005falt_005fname2"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_issuer_alt_name2</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned int <var>seq</var>, void * <var>ian</var>, size_t * <var>ian_size</var>, unsigned int * <var>ian_type</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>seq</var>: specifies the sequence number of the alt name (0 for the first one, 1 for the second etc.)
</p>
<p><var>ian</var>: is the place where the alternative name will be copied to
</p>
<p><var>ian_size</var>: holds the size of ret.
</p>
<p><var>ian_type</var>: holds the type of the alternative name (one of gnutls_x509_subject_alt_name_t).
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical (may be null)
</p>
<p>This function will return the alternative names, contained in the
given certificate. It is the same as
<code>gnutls_x509_crt_get_issuer_alt_name()</code>  except for the fact that it
will return the type of the alternative name in  <code>ian_type</code> even if
the function fails for some reason (i.e.  the buffer provided is
not enough).
</p>
<p><strong>Returns:</strong> the alternative issuer name type on success, one of the
enumerated <code>gnutls_x509_subject_alt_name_t</code> .  It will return
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if  <code>ian_size</code> is not large enough
to hold the value.  In that case  <code>ian_size</code> will be updated with
the required size.  If the certificate does not have an
Alternative name with the specified sequence number then
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  is returned.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fissuer_005falt_005fothername_005foid-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_issuer_alt_othername_oid</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fissuer_005falt_005fothername_005foid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fissuer_005falt_005fothername_005foid"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_issuer_alt_othername_oid</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned int <var>seq</var>, void * <var>ret</var>, size_t * <var>ret_size</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>seq</var>: specifies the sequence number of the alt name (0 for the first one, 1 for the second etc.)
</p>
<p><var>ret</var>: is the place where the otherName OID will be copied to
</p>
<p><var>ret_size</var>: holds the size of ret.
</p>
<p>This function will extract the type OID of an otherName Subject
Alternative Name, contained in the given certificate, and return
the type as an enumerated element.
</p>
<p>If  <code>oid</code> is null then only the size will be filled. The  <code>oid</code> returned will be null terminated, although  <code>oid_size</code> will not
account for the trailing null.
</p>
<p>This function is only useful if
<code>gnutls_x509_crt_get_issuer_alt_name()</code>  returned
<code>GNUTLS_SAN_OTHERNAME</code> .
</p>
<p><strong>Returns:</strong> the alternative issuer name type on success, one of the
enumerated gnutls_x509_subject_alt_name_t.  For supported OIDs, it
will return one of the virtual (GNUTLS_SAN_OTHERNAME_*) types,
e.g. <code>GNUTLS_SAN_OTHERNAME_XMPP</code> , and <code>GNUTLS_SAN_OTHERNAME</code>  for
unknown OIDs.  It will return <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if
 <code>ret_size</code> is not large enough to hold the value.  In that case
 <code>ret_size</code> will be updated with the required size.  If the
certificate does not have an Alternative name with the specified
sequence number and with the otherName type then
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  is returned.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_issuer_dn</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_issuer_dn</strong> <em>(gnutls_x509_crt_t <var>cert</var>, char * <var>buf</var>, size_t * <var>buf_size</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>buf</var>: a pointer to a structure to hold the name (may be null)
</p>
<p><var>buf_size</var>: initially holds the size of  <code>buf</code> 
</p>
<p>This function will copy the name of the Certificate issuer in the
provided buffer. The name will be in the form
&quot;C=xxxx,O=yyyy,CN=zzzz&quot; as described in RFC4514. The output string
will be ASCII or UTF-8 encoded, depending on the certificate data.
</p>
<p>If  <code>buf</code> is null then only the size will be filled. 
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the provided buffer is not
long enough, and in that case the  <code>buf_size</code> will be updated
with the required size. <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  if
the DN does not exist, or another error value on error. On success 0 is returned.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn2-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_issuer_dn2</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn2"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn2"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_issuer_dn2</strong> <em>(gnutls_x509_crt_t <var>cert</var>, gnutls_datum_t * <var>dn</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>dn</var>: a pointer to a structure to hold the name
</p>
<p>This function will allocate buffer and copy the name of issuer of the Certificate.
The name will be in the form &quot;C=xxxx,O=yyyy,CN=zzzz&quot; as
described in RFC4514. The output string will be ASCII or UTF-8
encoded, depending on the certificate data.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.10
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn_005fby_005foid-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_issuer_dn_by_oid</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn_005fby_005foid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn_005fby_005foid"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_issuer_dn_by_oid</strong> <em>(gnutls_x509_crt_t <var>cert</var>, const char * <var>oid</var>, unsigned <var>indx</var>, unsigned int <var>raw_flag</var>, void * <var>buf</var>, size_t * <var>buf_size</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>oid</var>: holds an Object Identified in null terminated string
</p>
<p><var>indx</var>: In case multiple same OIDs exist in the RDN, this specifies which to send. Use (0) to get the first one.
</p>
<p><var>raw_flag</var>: If non-zero returns the raw DER data of the DN part.
</p>
<p><var>buf</var>: a pointer to a structure to hold the name (may be null)
</p>
<p><var>buf_size</var>: initially holds the size of  <code>buf</code> 
</p>
<p>This function will extract the part of the name of the Certificate
issuer specified by the given OID. The output, if the raw flag is not
used, will be encoded as described in RFC4514. Thus a string that is
ASCII or UTF-8 encoded, depending on the certificate data.
</p>
<p>Some helper macros with popular OIDs can be found in gnutls/x509.h
If raw flag is (0), this function will only return known OIDs as
text. Other OIDs will be DER encoded, as described in RFC4514 &ndash;
in hex format with a &rsquo;#&rsquo; prefix.  You can check about known OIDs
using <code>gnutls_x509_dn_oid_known()</code> .
</p>
<p>If  <code>buf</code> is null then only the size will be filled. If the  <code>raw_flag</code> is not specified the output is always null terminated, although the
 <code>buf_size</code> will not include the null character.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the provided buffer is not
long enough, and in that case the  <code>buf_size</code> will be updated with
the required size. <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  if there 
are no data in the current index. On success 0 is returned.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn_005foid-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_issuer_dn_oid</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn_005foid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn_005foid"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_issuer_dn_oid</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned <var>indx</var>, void * <var>oid</var>, size_t * <var>oid_size</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>indx</var>: This specifies which OID to return. Use (0) to get the first one.
</p>
<p><var>oid</var>: a pointer to a buffer to hold the OID (may be null)
</p>
<p><var>oid_size</var>: initially holds the size of  <code>oid</code> 
</p>
<p>This function will extract the OIDs of the name of the Certificate
issuer specified by the given index.
</p>
<p>If  <code>oid</code> is null then only the size will be filled. The  <code>oid</code> returned will be null terminated, although  <code>oid_size</code> will not
account for the trailing null.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the provided buffer is not
long enough, and in that case the  <code>buf_size</code> will be updated with
the required size. <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  if there 
are no data in the current index. On success 0 is returned.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fissuer_005funique_005fid-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_issuer_unique_id</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fissuer_005funique_005fid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fissuer_005funique_005fid"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_issuer_unique_id</strong> <em>(gnutls_x509_crt_t <var>crt</var>, char * <var>buf</var>, size_t * <var>buf_size</var>)</em></dt>
<dd><p><var>crt</var>: Holds the certificate
</p>
<p><var>buf</var>: user allocated memory buffer, will hold the unique id
</p>
<p><var>buf_size</var>: size of user allocated memory buffer (on input), will hold
actual size of the unique ID on return.
</p>
<p>This function will extract the issuerUniqueID value (if present) for
the given certificate.
</p>
<p>If the user allocated memory buffer is not large enough to hold the
full subjectUniqueID, then a GNUTLS_E_SHORT_MEMORY_BUFFER error will be
returned, and buf_size will be set to the actual length.
</p>
<p>This function had a bug prior to 3.4.8 that prevented the setting
of <code>NULL</code>   <code>buf</code> to discover the  <code>buf_size</code> . To use this function safely
with the older versions the  <code>buf</code> must be a valid buffer that can hold
at least a single byte if  <code>buf_size</code> is zero.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fkey_005fid-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_key_id</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fkey_005fid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fkey_005fid-1"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_key_id</strong> <em>(gnutls_x509_crt_t <var>crt</var>, unsigned int <var>flags</var>, unsigned char * <var>output_data</var>, size_t * <var>output_data_size</var>)</em></dt>
<dd><p><var>crt</var>: Holds the certificate
</p>
<p><var>flags</var>: should be one of the flags from <code>gnutls_keyid_flags_t</code> 
</p>
<p><var>output_data</var>: will contain the key ID
</p>
<p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)
</p>
<p>This function will return a unique ID that depends on the public
key parameters. This ID can be used in checking whether a
certificate corresponds to the given private key.
</p>
<p>If the buffer provided is not long enough to hold the output, then
*output_data_size is updated and GNUTLS_E_SHORT_MEMORY_BUFFER will
be returned.  The output will normally be a SHA-1 hash output,
which is 20 bytes.
</p>
<p><strong>Returns:</strong> In case of failure a negative error code will be
returned, and 0 on success.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fkey_005fpurpose_005foid-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_key_purpose_oid</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fkey_005fpurpose_005foid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fkey_005fpurpose_005foid"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_key_purpose_oid</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned <var>indx</var>, void * <var>oid</var>, size_t * <var>oid_size</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>indx</var>: This specifies which OID to return. Use (0) to get the first one.
</p>
<p><var>oid</var>: a pointer to a buffer to hold the OID (may be null)
</p>
<p><var>oid_size</var>: initially holds the size of  <code>oid</code> 
</p>
<p><var>critical</var>: output flag to indicate criticality of extension
</p>
<p>This function will extract the key purpose OIDs of the Certificate
specified by the given index.  These are stored in the Extended Key
Usage extension (2.5.29.37) See the GNUTLS_KP_* definitions for
human readable names.
</p>
<p>If  <code>oid</code> is null then only the size will be filled. The  <code>oid</code> returned will be null terminated, although  <code>oid_size</code> will not
account for the trailing null.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the provided buffer is
not long enough, and in that case the *oid_size will be updated
with the required size.  On success 0 is returned.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fkey_005fusage-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_key_usage</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fkey_005fusage"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fkey_005fusage"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_key_usage</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned int * <var>key_usage</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>key_usage</var>: where the key usage bits will be stored
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical
</p>
<p>This function will return certificate&rsquo;s key usage, by reading the
keyUsage X.509 extension (2.5.29.15). The key usage value will ORed
values of the: <code>GNUTLS_KEY_DIGITAL_SIGNATURE</code> ,
<code>GNUTLS_KEY_NON_REPUDIATION</code> , <code>GNUTLS_KEY_KEY_ENCIPHERMENT</code> ,
<code>GNUTLS_KEY_DATA_ENCIPHERMENT</code> , <code>GNUTLS_KEY_KEY_AGREEMENT</code> ,
<code>GNUTLS_KEY_KEY_CERT_SIGN</code> , <code>GNUTLS_KEY_CRL_SIGN</code> ,
<code>GNUTLS_KEY_ENCIPHER_ONLY</code> , <code>GNUTLS_KEY_DECIPHER_ONLY</code> .
</p>
<p><strong>Returns:</strong> the certificate key usage, or a negative error code in case of
parsing error.  If the certificate does not contain the keyUsage
extension <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  will be
returned.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fname_005fconstraints-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_name_constraints</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fname_005fconstraints"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fname_005fconstraints"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_name_constraints</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_x509_name_constraints_t <var>nc</var>, unsigned int <var>flags</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>crt</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>nc</var>: The nameconstraints intermediate type
</p>
<p><var>flags</var>: zero or <code>GNUTLS_EXT_FLAG_APPEND</code> 
</p>
<p><var>critical</var>: the extension status
</p>
<p>This function will return an intermediate type containing
the name constraints of the provided CA certificate. That
structure can be used in combination with <code>gnutls_x509_name_constraints_check()</code> 
to verify whether a server&rsquo;s name is in accordance with the constraints.
</p>
<p>When the  <code>flags</code> is set to <code>GNUTLS_EXT_FLAG_APPEND</code> ,
then if the  <code>nc</code> structure is empty this function will behave
identically as if the flag was not set.
Otherwise if there are elements in the  <code>nc</code> structure then the
constraints will be merged with the existing constraints following
RFC5280 p6.1.4 (excluded constraints will be appended, permitted
will be intersected).
</p>
<p>Note that  <code>nc</code> must be initialized prior to calling this function.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
if the extension is not present, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fpk_005falgorithm-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_pk_algorithm</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fpk_005falgorithm"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fpk_005falgorithm"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_pk_algorithm</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned int * <var>bits</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>bits</var>: if bits is non null it will hold the size of the parameters&rsquo; in bits
</p>
<p>This function will return the public key algorithm of an X.509
certificate.
</p>
<p>If bits is non null, it should have enough size to hold the parameters
size in bits. For RSA the bits returned is the modulus.
For DSA the bits returned are of the public
exponent.
</p>
<p>Unknown/unsupported algorithms are mapped to <code>GNUTLS_PK_UNKNOWN</code> .
</p>
<p><strong>Returns:</strong> a member of the <code>gnutls_pk_algorithm_t</code>  enumeration on
success, or a negative error code on error.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fpk_005fdsa_005fraw-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_pk_dsa_raw</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fpk_005fdsa_005fraw"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fpk_005fdsa_005fraw"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_pk_dsa_raw</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_datum_t * <var>p</var>, gnutls_datum_t * <var>q</var>, gnutls_datum_t * <var>g</var>, gnutls_datum_t * <var>y</var>)</em></dt>
<dd><p><var>crt</var>: Holds the certificate
</p>
<p><var>p</var>: will hold the p
</p>
<p><var>q</var>: will hold the q
</p>
<p><var>g</var>: will hold the g
</p>
<p><var>y</var>: will hold the y
</p>
<p>This function will export the DSA public key&rsquo;s parameters found in
the given certificate.  The new parameters will be allocated using
<code>gnutls_malloc()</code>  and will be stored in the appropriate datum.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fpk_005fecc_005fraw-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_pk_ecc_raw</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fpk_005fecc_005fraw"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fpk_005fecc_005fraw"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_pk_ecc_raw</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_ecc_curve_t * <var>curve</var>, gnutls_datum_t * <var>x</var>, gnutls_datum_t * <var>y</var>)</em></dt>
<dd><p><var>crt</var>: Holds the certificate
</p>
<p><var>curve</var>: will hold the curve
</p>
<p><var>x</var>: will hold x
</p>
<p><var>y</var>: will hold y
</p>
<p>This function will export the ECC public key&rsquo;s parameters found in
the given certificate.  The new parameters will be allocated using
<code>gnutls_malloc()</code>  and will be stored in the appropriate datum.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.4.1
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fpk_005foid-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_pk_oid</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fpk_005foid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fpk_005foid"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_pk_oid</strong> <em>(gnutls_x509_crt_t <var>cert</var>, char * <var>oid</var>, size_t * <var>oid_size</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>oid</var>: a pointer to a buffer to hold the OID (may be null)
</p>
<p><var>oid_size</var>: initially holds the size of  <code>oid</code> 
</p>
<p>This function will return the OID of the public key algorithm
on that certificate. This is function
is useful in the case <code>gnutls_x509_crt_get_pk_algorithm()</code> 
returned <code>GNUTLS_PK_UNKNOWN</code> .
</p>
<p><strong>Returns:</strong> zero or a negative error code on error.
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fpk_005frsa_005fraw-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_pk_rsa_raw</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fpk_005frsa_005fraw"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fpk_005frsa_005fraw"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_pk_rsa_raw</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_datum_t * <var>m</var>, gnutls_datum_t * <var>e</var>)</em></dt>
<dd><p><var>crt</var>: Holds the certificate
</p>
<p><var>m</var>: will hold the modulus
</p>
<p><var>e</var>: will hold the public exponent
</p>
<p>This function will export the RSA public key&rsquo;s parameters found in
the given structure.  The new parameters will be allocated using
<code>gnutls_malloc()</code>  and will be stored in the appropriate datum.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fpolicy-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_policy</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fpolicy"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fpolicy"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_policy</strong> <em>(gnutls_x509_crt_t <var>crt</var>, unsigned <var>indx</var>, struct gnutls_x509_policy_st * <var>policy</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>crt</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>indx</var>: This specifies which policy to return. Use (0) to get the first one.
</p>
<p><var>policy</var>: A pointer to a policy structure.
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical
</p>
<p>This function will extract the certificate policy (extension 2.5.29.32) 
specified by the given index. 
</p>
<p>The policy returned by this function must be deinitialized by using
<code>gnutls_x509_policy_release()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
if the extension is not present, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.1.5
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fprivate_005fkey_005fusage_005fperiod-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_private_key_usage_period</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fprivate_005fkey_005fusage_005fperiod"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fprivate_005fkey_005fusage_005fperiod"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_private_key_usage_period</strong> <em>(gnutls_x509_crt_t <var>cert</var>, time_t * <var>activation</var>, time_t * <var>expiration</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>activation</var>: The activation time
</p>
<p><var>expiration</var>: The expiration time
</p>
<p><var>critical</var>: the extension status
</p>
<p>This function will return the expiration and activation
times of the private key of the certificate. It relies on
the PKIX extension 2.5.29.16 being present.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
if the extension is not present, otherwise a negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fproxy-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_proxy</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fproxy"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fproxy"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_proxy</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned int * <var>critical</var>, int * <var>pathlen</var>, char ** <var>policyLanguage</var>, char ** <var>policy</var>, size_t * <var>sizeof_policy</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical
</p>
<p><var>pathlen</var>: pointer to output integer indicating path length (may be
NULL), non-negative error codes indicate a present pCPathLenConstraint
field and the actual value, -1 indicate that the field is absent.
</p>
<p><var>policyLanguage</var>: output variable with OID of policy language
</p>
<p><var>policy</var>: output variable with policy data
</p>
<p><var>sizeof_policy</var>: output variable size of policy data
</p>
<p>This function will get information from a proxy certificate.  It
reads the ProxyCertInfo X.509 extension (1.3.6.1.5.5.7.1.14).
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fraw_005fdn-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_raw_dn</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fraw_005fdn"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fraw_005fdn"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_raw_dn</strong> <em>(gnutls_x509_crt_t <var>cert</var>, gnutls_datum_t * <var>dn</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>dn</var>: will hold the starting point of the DN
</p>
<p>This function will return a pointer to the DER encoded DN structure and
the length. This points to allocated data that must be free&rsquo;d using <code>gnutls_free()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value. or a negative error code on error.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fraw_005fissuer_005fdn-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_raw_issuer_dn</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fraw_005fissuer_005fdn"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fraw_005fissuer_005fdn"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_raw_issuer_dn</strong> <em>(gnutls_x509_crt_t <var>cert</var>, gnutls_datum_t * <var>dn</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>dn</var>: will hold the starting point of the DN
</p>
<p>This function will return a pointer to the DER encoded DN structure
and the length. This points to allocated data that must be free&rsquo;d using <code>gnutls_free()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.or a negative error code on error.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fserial-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_serial</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fserial"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fserial"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_serial</strong> <em>(gnutls_x509_crt_t <var>cert</var>, void * <var>result</var>, size_t * <var>result_size</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>result</var>: The place where the serial number will be copied
</p>
<p><var>result_size</var>: Holds the size of the result field.
</p>
<p>This function will return the X.509 certificate&rsquo;s serial number.
This is obtained by the X509 Certificate serialNumber field. Serial
is not always a 32 or 64bit number. Some CAs use large serial
numbers, thus it may be wise to handle it as something uint8_t.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fsignature-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_signature</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fsignature"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fsignature"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_signature</strong> <em>(gnutls_x509_crt_t <var>cert</var>, char * <var>sig</var>, size_t * <var>sig_size</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>sig</var>: a pointer where the signature part will be copied (may be null).
</p>
<p><var>sig_size</var>: initially holds the size of  <code>sig</code> 
</p>
<p>This function will extract the signature field of a certificate.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fsignature_005falgorithm-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_signature_algorithm</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fsignature_005falgorithm"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fsignature_005falgorithm"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_signature_algorithm</strong> <em>(gnutls_x509_crt_t <var>cert</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p>This function will return a value of the <code>gnutls_sign_algorithm_t</code> 
enumeration that is the signature algorithm that has been used to
sign this certificate.
</p>
<p>Unknown/unsupported signature algorithms are mapped to <code>GNUTLS_SIGN_UNKNOWN</code> .
</p>
<p><strong>Returns:</strong> a <code>gnutls_sign_algorithm_t</code>  value, or a negative error code on
error.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fsignature_005foid-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_signature_oid</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fsignature_005foid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fsignature_005foid"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_signature_oid</strong> <em>(gnutls_x509_crt_t <var>cert</var>, char * <var>oid</var>, size_t * <var>oid_size</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>oid</var>: a pointer to a buffer to hold the OID (may be null)
</p>
<p><var>oid_size</var>: initially holds the size of  <code>oid</code> 
</p>
<p>This function will return the OID of the signature algorithm
that has been used to sign this certificate. This is function
is useful in the case <code>gnutls_x509_crt_get_signature_algorithm()</code> 
returned <code>GNUTLS_SIGN_UNKNOWN</code> .
</p>
<p><strong>Returns:</strong> zero or a negative error code on error.
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fsubject-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_subject</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fsubject"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fsubject"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_subject</strong> <em>(gnutls_x509_crt_t <var>cert</var>, gnutls_x509_dn_t * <var>dn</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>dn</var>: output variable with pointer to uint8_t DN.
</p>
<p>Return the Certificate&rsquo;s Subject DN as a <code>gnutls_x509_dn_t</code>  data type,
that can be decoded using <code>gnutls_x509_dn_get_rdn_ava()</code> . 
</p>
<p>Note that  <code>dn</code> should be treated as constant. Because it points 
into the  <code>cert</code> object, you should not use  <code>dn</code> after  <code>cert</code> is
deallocated.
</p>
<p><strong>Returns:</strong> Returns 0 on success, or an error code.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fsubject_005falt_005fname-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_subject_alt_name</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fsubject_005falt_005fname"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fsubject_005falt_005fname"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_subject_alt_name</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned int <var>seq</var>, void * <var>san</var>, size_t * <var>san_size</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>seq</var>: specifies the sequence number of the alt name (0 for the first one, 1 for the second etc.)
</p>
<p><var>san</var>: is the place where the alternative name will be copied to
</p>
<p><var>san_size</var>: holds the size of san.
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical (may be null)
</p>
<p>This function retrieves the Alternative Name (2.5.29.17), contained
in the given certificate in the X509v3 Certificate Extensions.
</p>
<p>When the SAN type is otherName, it will extract the data in the
otherName&rsquo;s value field, and <code>GNUTLS_SAN_OTHERNAME</code>  is returned.
You may use <code>gnutls_x509_crt_get_subject_alt_othername_oid()</code>  to get
the corresponding OID and the &quot;virtual&quot; SAN types (e.g.,
<code>GNUTLS_SAN_OTHERNAME_XMPP</code> ).
</p>
<p>If an otherName OID is known, the data will be decoded.  Otherwise
the returned data will be DER encoded, and you will have to decode
it yourself.  Currently, only the RFC 3920 id-on-xmppAddr SAN is
recognized.
</p>
<p><strong>Returns:</strong> the alternative subject name type on success, one of the
enumerated <code>gnutls_x509_subject_alt_name_t</code> .  It will return
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if  <code>san_size</code> is not large enough to
hold the value.  In that case  <code>san_size</code> will be updated with the
required size.  If the certificate does not have an Alternative
name with the specified sequence number then
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  is returned.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fsubject_005falt_005fname2-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_subject_alt_name2</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fsubject_005falt_005fname2"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fsubject_005falt_005fname2"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_subject_alt_name2</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned int <var>seq</var>, void * <var>san</var>, size_t * <var>san_size</var>, unsigned int * <var>san_type</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>seq</var>: specifies the sequence number of the alt name (0 for the first one, 1 for the second etc.)
</p>
<p><var>san</var>: is the place where the alternative name will be copied to
</p>
<p><var>san_size</var>: holds the size of ret.
</p>
<p><var>san_type</var>: holds the type of the alternative name (one of gnutls_x509_subject_alt_name_t).
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical (may be null)
</p>
<p>This function will return the alternative names, contained in the
given certificate. It is the same as
<code>gnutls_x509_crt_get_subject_alt_name()</code>  except for the fact that it
will return the type of the alternative name in  <code>san_type</code> even if
the function fails for some reason (i.e.  the buffer provided is
not enough).
</p>
<p><strong>Returns:</strong> the alternative subject name type on success, one of the
enumerated <code>gnutls_x509_subject_alt_name_t</code> .  It will return
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if  <code>san_size</code> is not large enough
to hold the value.  In that case  <code>san_size</code> will be updated with
the required size.  If the certificate does not have an
Alternative name with the specified sequence number then
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  is returned.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fsubject_005falt_005fothername_005foid-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_subject_alt_othername_oid</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fsubject_005falt_005fothername_005foid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fsubject_005falt_005fothername_005foid"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_subject_alt_othername_oid</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned int <var>seq</var>, void * <var>oid</var>, size_t * <var>oid_size</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>seq</var>: specifies the sequence number of the alt name (0 for the first one, 1 for the second etc.)
</p>
<p><var>oid</var>: is the place where the otherName OID will be copied to
</p>
<p><var>oid_size</var>: holds the size of ret.
</p>
<p>This function will extract the type OID of an otherName Subject
Alternative Name, contained in the given certificate, and return
the type as an enumerated element.
</p>
<p>This function is only useful if
<code>gnutls_x509_crt_get_subject_alt_name()</code>  returned
<code>GNUTLS_SAN_OTHERNAME</code> .
</p>
<p>If  <code>oid</code> is null then only the size will be filled. The  <code>oid</code> returned will be null terminated, although  <code>oid_size</code> will not
account for the trailing null.
</p>
<p><strong>Returns:</strong> the alternative subject name type on success, one of the
enumerated gnutls_x509_subject_alt_name_t.  For supported OIDs, it
will return one of the virtual (GNUTLS_SAN_OTHERNAME_*) types,
e.g. <code>GNUTLS_SAN_OTHERNAME_XMPP</code> , and <code>GNUTLS_SAN_OTHERNAME</code>  for
unknown OIDs.  It will return <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if
 <code>ian_size</code> is not large enough to hold the value.  In that case
 <code>ian_size</code> will be updated with the required size.  If the
certificate does not have an Alternative name with the specified
sequence number and with the otherName type then
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  is returned.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fsubject_005fkey_005fid-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_subject_key_id</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fsubject_005fkey_005fid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fsubject_005fkey_005fid"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_subject_key_id</strong> <em>(gnutls_x509_crt_t <var>cert</var>, void * <var>ret</var>, size_t * <var>ret_size</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>ret</var>: The place where the identifier will be copied
</p>
<p><var>ret_size</var>: Holds the size of the result field.
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical (may be null)
</p>
<p>This function will return the X.509v3 certificate&rsquo;s subject key
identifier.  This is obtained by the X.509 Subject Key identifier
extension field (2.5.29.14).
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
if the extension is not present, otherwise a negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fsubject_005funique_005fid-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_subject_unique_id</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fsubject_005funique_005fid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fsubject_005funique_005fid"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_subject_unique_id</strong> <em>(gnutls_x509_crt_t <var>crt</var>, char * <var>buf</var>, size_t * <var>buf_size</var>)</em></dt>
<dd><p><var>crt</var>: Holds the certificate
</p>
<p><var>buf</var>: user allocated memory buffer, will hold the unique id
</p>
<p><var>buf_size</var>: size of user allocated memory buffer (on input), will hold
actual size of the unique ID on return.
</p>
<p>This function will extract the subjectUniqueID value (if present) for
the given certificate.
</p>
<p>If the user allocated memory buffer is not large enough to hold the
full subjectUniqueID, then a GNUTLS_E_SHORT_MEMORY_BUFFER error will be
returned, and buf_size will be set to the actual length.
</p>
<p>This function had a bug prior to 3.4.8 that prevented the setting
of <code>NULL</code>   <code>buf</code> to discover the  <code>buf_size</code> . To use this function safely
with the older versions the  <code>buf</code> must be a valid buffer that can hold
at least a single byte if  <code>buf_size</code> is zero.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005ftlsfeatures-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_tlsfeatures</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005ftlsfeatures"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005ftlsfeatures"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_tlsfeatures</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_x509_tlsfeatures_t <var>features</var>, unsigned int <var>flags</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>crt</var>: A X.509 certificate
</p>
<p><var>features</var>: If the function succeeds, the
features will be stored in this variable.
</p>
<p><var>flags</var>: zero or <code>GNUTLS_EXT_FLAG_APPEND</code> 
</p>
<p><var>critical</var>: the extension status
</p>
<p>This function will get the X.509 TLS features
extension structure from the certificate. The
returned structure needs to be freed using
<code>gnutls_x509_tlsfeatures_deinit()</code> .
</p>
<p>When the  <code>flags</code> is set to <code>GNUTLS_EXT_FLAG_APPEND</code> ,
then if the  <code>features</code> structure is empty this function will behave
identically as if the flag was not set. Otherwise if there are elements 
in the  <code>features</code> structure then they will be merged with.
</p>
<p>Note that  <code>features</code> must be initialized prior to calling this function.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.5.1
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fget_005fversion-1"></a>
<h4 class="subheading">gnutls_x509_crt_get_version</h4>
<a name="gnutls_005fx509_005fcrt_005fget_005fversion"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fget_005fversion"></a>Function: <em>int</em> <strong>gnutls_x509_crt_get_version</strong> <em>(gnutls_x509_crt_t <var>cert</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p>This function will return the version of the specified Certificate.
</p>
<p><strong>Returns:</strong> version of certificate, or a negative error code on error.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fimport-1"></a>
<h4 class="subheading">gnutls_x509_crt_import</h4>
<a name="gnutls_005fx509_005fcrt_005fimport"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fimport"></a>Function: <em>int</em> <strong>gnutls_x509_crt_import</strong> <em>(gnutls_x509_crt_t <var>cert</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>)</em></dt>
<dd><p><var>cert</var>: The data to store the parsed certificate.
</p>
<p><var>data</var>: The DER or PEM encoded certificate.
</p>
<p><var>format</var>: One of DER or PEM
</p>
<p>This function will convert the given DER or PEM encoded Certificate
to the native gnutls_x509_crt_t format. The output will be stored
in  <code>cert</code> .
</p>
<p>If the Certificate is PEM encoded it should have a header of &quot;X509
CERTIFICATE&quot;, or &quot;CERTIFICATE&quot;.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fimport_005furl-1"></a>
<h4 class="subheading">gnutls_x509_crt_import_url</h4>
<a name="gnutls_005fx509_005fcrt_005fimport_005furl"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fimport_005furl"></a>Function: <em>int</em> <strong>gnutls_x509_crt_import_url</strong> <em>(gnutls_x509_crt_t <var>crt</var>, const char * <var>url</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>crt</var>: A certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>url</var>: A PKCS 11 url
</p>
<p><var>flags</var>: One of GNUTLS_PKCS11_OBJ_* flags for PKCS<code>11</code>  URLs or zero otherwise
</p>
<p>This function will import a certificate present in a PKCS<code>11</code>  token
or any type of back-end that supports URLs.
</p>
<p>In previous versions of gnutls this function was named
gnutls_x509_crt_import_pkcs11_url, and the old name is
an alias to this one.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005finit-1"></a>
<h4 class="subheading">gnutls_x509_crt_init</h4>
<a name="gnutls_005fx509_005fcrt_005finit"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005finit"></a>Function: <em>int</em> <strong>gnutls_x509_crt_init</strong> <em>(gnutls_x509_crt_t * <var>cert</var>)</em></dt>
<dd><p><var>cert</var>: A pointer to the type to be initialized
</p>
<p>This function will initialize an X.509 certificate structure.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005flist_005fimport-1"></a>
<h4 class="subheading">gnutls_x509_crt_list_import</h4>
<a name="gnutls_005fx509_005fcrt_005flist_005fimport"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005flist_005fimport"></a>Function: <em>int</em> <strong>gnutls_x509_crt_list_import</strong> <em>(gnutls_x509_crt_t * <var>certs</var>, unsigned int * <var>cert_max</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>certs</var>: Indicates where the parsed list will be copied to. Must not be initialized.
</p>
<p><var>cert_max</var>: Initially must hold the maximum number of certs. It will be updated with the number of certs available.
</p>
<p><var>data</var>: The PEM encoded certificate.
</p>
<p><var>format</var>: One of DER or PEM.
</p>
<p><var>flags</var>: must be (0) or an OR&rsquo;d sequence of gnutls_certificate_import_flags.
</p>
<p>This function will convert the given PEM encoded certificate list
to the native gnutls_x509_crt_t format. The output will be stored
in  <code>certs</code> .  They will be automatically initialized.
</p>
<p>The flag <code>GNUTLS_X509_CRT_LIST_IMPORT_FAIL_IF_EXCEED</code>  will cause
import to fail if the certificates in the provided buffer are more
than the available structures. The <code>GNUTLS_X509_CRT_LIST_FAIL_IF_UNSORTED</code> 
flag will cause the function to fail if the provided list is not
sorted from subject to issuer.
</p>
<p>If the Certificate is PEM encoded it should have a header of &quot;X509
CERTIFICATE&quot;, or &quot;CERTIFICATE&quot;.
</p>
<p><strong>Returns:</strong> the number of certificates read or a negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005flist_005fimport2-1"></a>
<h4 class="subheading">gnutls_x509_crt_list_import2</h4>
<a name="gnutls_005fx509_005fcrt_005flist_005fimport2"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005flist_005fimport2"></a>Function: <em>int</em> <strong>gnutls_x509_crt_list_import2</strong> <em>(gnutls_x509_crt_t ** <var>certs</var>, unsigned int * <var>size</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>certs</var>: Will hold the parsed certificate list.
</p>
<p><var>size</var>: It will contain the size of the list.
</p>
<p><var>data</var>: The PEM encoded certificate.
</p>
<p><var>format</var>: One of DER or PEM.
</p>
<p><var>flags</var>: must be (0) or an OR&rsquo;d sequence of gnutls_certificate_import_flags.
</p>
<p>This function will convert the given PEM encoded certificate list
to the native gnutls_x509_crt_t format. The output will be stored
in  <code>certs</code> which will allocated and initialized.
</p>
<p>If the Certificate is PEM encoded it should have a header of &quot;X509
CERTIFICATE&quot;, or &quot;CERTIFICATE&quot;.
</p>
<p>To deinitialize  <code>certs</code> , you need to deinitialize each crt structure
independently, and use <code>gnutls_free()</code>  at
</p>
<p><strong>Returns:</strong> the number of certificates read or a negative error value.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005flist_005fverify-1"></a>
<h4 class="subheading">gnutls_x509_crt_list_verify</h4>
<a name="gnutls_005fx509_005fcrt_005flist_005fverify"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005flist_005fverify"></a>Function: <em>int</em> <strong>gnutls_x509_crt_list_verify</strong> <em>(const gnutls_x509_crt_t * <var>cert_list</var>, unsigned <var>cert_list_length</var>, const gnutls_x509_crt_t * <var>CA_list</var>, unsigned <var>CA_list_length</var>, const gnutls_x509_crl_t * <var>CRL_list</var>, unsigned <var>CRL_list_length</var>, unsigned int <var>flags</var>, unsigned int * <var>verify</var>)</em></dt>
<dd><p><var>cert_list</var>: is the certificate list to be verified
</p>
<p><var>cert_list_length</var>: holds the number of certificate in cert_list
</p>
<p><var>CA_list</var>: is the CA list which will be used in verification
</p>
<p><var>CA_list_length</var>: holds the number of CA certificate in CA_list
</p>
<p><var>CRL_list</var>: holds a list of CRLs.
</p>
<p><var>CRL_list_length</var>: the length of CRL list.
</p>
<p><var>flags</var>: Flags that may be used to change the verification algorithm. Use OR of the gnutls_certificate_verify_flags enumerations.
</p>
<p><var>verify</var>: will hold the certificate verification output.
</p>

<p>This function will try to verify the given certificate list and
return its status. The details of the verification are the same
as in <code>gnutls_x509_trust_list_verify_crt2()</code> .
</p>
<p>You must check the peer&rsquo;s name in order to check if the verified
certificate belongs to the actual peer.
</p>
<p>The certificate verification output will be put in  <code>verify</code> and will
be one or more of the gnutls_certificate_status_t enumerated
elements bitwise or&rsquo;d.  For a more detailed verification status use
<code>gnutls_x509_crt_verify()</code>  per list element.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fprint-1"></a>
<h4 class="subheading">gnutls_x509_crt_print</h4>
<a name="gnutls_005fx509_005fcrt_005fprint"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fprint"></a>Function: <em>int</em> <strong>gnutls_x509_crt_print</strong> <em>(gnutls_x509_crt_t <var>cert</var>, gnutls_certificate_print_formats_t <var>format</var>, gnutls_datum_t * <var>out</var>)</em></dt>
<dd><p><var>cert</var>: The data to be printed
</p>
<p><var>format</var>: Indicate the format to use
</p>
<p><var>out</var>: Newly allocated datum with null terminated string.
</p>
<p>This function will pretty print a X.509 certificate, suitable for
display to a human.
</p>
<p>If the format is <code>GNUTLS_CRT_PRINT_FULL</code>  then all fields of the
certificate will be output, on multiple lines.  The
<code>GNUTLS_CRT_PRINT_ONELINE</code>  format will generate one line with some
selected fields, which is useful for logging purposes.
</p>
<p>The output  <code>out</code> needs to be deallocated using <code>gnutls_free()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fset_005factivation_005ftime-1"></a>
<h4 class="subheading">gnutls_x509_crt_set_activation_time</h4>
<a name="gnutls_005fx509_005fcrt_005fset_005factivation_005ftime"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fset_005factivation_005ftime"></a>Function: <em>int</em> <strong>gnutls_x509_crt_set_activation_time</strong> <em>(gnutls_x509_crt_t <var>cert</var>, time_t <var>act_time</var>)</em></dt>
<dd><p><var>cert</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>act_time</var>: The actual time
</p>
<p>This function will set the time this Certificate was or will be
activated.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fset_005fauthority_005finfo_005faccess-1"></a>
<h4 class="subheading">gnutls_x509_crt_set_authority_info_access</h4>
<a name="gnutls_005fx509_005fcrt_005fset_005fauthority_005finfo_005faccess"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fset_005fauthority_005finfo_005faccess"></a>Function: <em>int</em> <strong>gnutls_x509_crt_set_authority_info_access</strong> <em>(gnutls_x509_crt_t <var>crt</var>, int <var>what</var>, gnutls_datum_t * <var>data</var>)</em></dt>
<dd><p><var>crt</var>: Holds the certificate
</p>
<p><var>what</var>: what data to get, a <code>gnutls_info_access_what_t</code>  type.
</p>
<p><var>data</var>: output data to be freed with <code>gnutls_free()</code> .
</p>
<p>This function sets the Authority Information Access (AIA)
extension, see RFC 5280 section 4.2.2.1 for more information.  
</p>
<p>The type of data stored in  <code>data</code> is specified via  <code>what</code> which
should be <code>gnutls_info_access_what_t</code>  values.
</p>
<p>If  <code>what</code> is <code>GNUTLS_IA_OCSP_URI</code> ,  <code>data</code> will hold the OCSP URI.
If  <code>what</code> is <code>GNUTLS_IA_CAISSUERS_URI</code> ,  <code>data</code> will hold the caIssuers
URI.  
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fset_005fauthority_005fkey_005fid-1"></a>
<h4 class="subheading">gnutls_x509_crt_set_authority_key_id</h4>
<a name="gnutls_005fx509_005fcrt_005fset_005fauthority_005fkey_005fid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fset_005fauthority_005fkey_005fid"></a>Function: <em>int</em> <strong>gnutls_x509_crt_set_authority_key_id</strong> <em>(gnutls_x509_crt_t <var>cert</var>, const void * <var>id</var>, size_t <var>id_size</var>)</em></dt>
<dd><p><var>cert</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>id</var>: The key ID
</p>
<p><var>id_size</var>: Holds the size of the key ID field.
</p>
<p>This function will set the X.509 certificate&rsquo;s authority key ID extension.
Only the keyIdentifier field can be set with this function.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fset_005fbasic_005fconstraints-1"></a>
<h4 class="subheading">gnutls_x509_crt_set_basic_constraints</h4>
<a name="gnutls_005fx509_005fcrt_005fset_005fbasic_005fconstraints"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fset_005fbasic_005fconstraints"></a>Function: <em>int</em> <strong>gnutls_x509_crt_set_basic_constraints</strong> <em>(gnutls_x509_crt_t <var>crt</var>, unsigned int <var>ca</var>, int <var>pathLenConstraint</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>ca</var>: true(1) or false(0). Depending on the Certificate authority status.
</p>
<p><var>pathLenConstraint</var>: non-negative error codes indicate maximum length of path,
and negative error codes indicate that the pathLenConstraints field should
not be present.
</p>
<p>This function will set the basicConstraints certificate extension.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fset_005fca_005fstatus-1"></a>
<h4 class="subheading">gnutls_x509_crt_set_ca_status</h4>
<a name="gnutls_005fx509_005fcrt_005fset_005fca_005fstatus"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fset_005fca_005fstatus"></a>Function: <em>int</em> <strong>gnutls_x509_crt_set_ca_status</strong> <em>(gnutls_x509_crt_t <var>crt</var>, unsigned int <var>ca</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>ca</var>: true(1) or false(0). Depending on the Certificate authority status.
</p>
<p>This function will set the basicConstraints certificate extension.
Use <code>gnutls_x509_crt_set_basic_constraints()</code>  if you want to control
the pathLenConstraint field too.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fset_005fcrl_005fdist_005fpoints-1"></a>
<h4 class="subheading">gnutls_x509_crt_set_crl_dist_points</h4>
<a name="gnutls_005fx509_005fcrt_005fset_005fcrl_005fdist_005fpoints"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fset_005fcrl_005fdist_005fpoints"></a>Function: <em>int</em> <strong>gnutls_x509_crt_set_crl_dist_points</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_x509_subject_alt_name_t <var>type</var>, const void * <var>data_string</var>, unsigned int <var>reason_flags</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>type</var>: is one of the gnutls_x509_subject_alt_name_t enumerations
</p>
<p><var>data_string</var>: The data to be set
</p>
<p><var>reason_flags</var>: revocation reasons
</p>
<p>This function will set the CRL distribution points certificate extension.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fset_005fcrl_005fdist_005fpoints2-1"></a>
<h4 class="subheading">gnutls_x509_crt_set_crl_dist_points2</h4>
<a name="gnutls_005fx509_005fcrt_005fset_005fcrl_005fdist_005fpoints2"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fset_005fcrl_005fdist_005fpoints2"></a>Function: <em>int</em> <strong>gnutls_x509_crt_set_crl_dist_points2</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_x509_subject_alt_name_t <var>type</var>, const void * <var>data</var>, unsigned int <var>data_size</var>, unsigned int <var>reason_flags</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>type</var>: is one of the gnutls_x509_subject_alt_name_t enumerations
</p>
<p><var>data</var>: The data to be set
</p>
<p><var>data_size</var>: The data size
</p>
<p><var>reason_flags</var>: revocation reasons
</p>
<p>This function will set the CRL distribution points certificate extension.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.6.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fset_005fcrq-1"></a>
<h4 class="subheading">gnutls_x509_crt_set_crq</h4>
<a name="gnutls_005fx509_005fcrt_005fset_005fcrq"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fset_005fcrq"></a>Function: <em>int</em> <strong>gnutls_x509_crt_set_crq</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_x509_crq_t <var>crq</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>crq</var>: holds a certificate request
</p>
<p>This function will set the name and public parameters as well as
the extensions from the given certificate request to the certificate. 
Only RSA keys are currently supported.
</p>
<p>Note that this function will only set the  <code>crq</code> if it is self
signed and the signature is correct. See <code>gnutls_x509_crq_sign2()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fset_005fcrq_005fextension_005fby_005foid-1"></a>
<h4 class="subheading">gnutls_x509_crt_set_crq_extension_by_oid</h4>
<a name="gnutls_005fx509_005fcrt_005fset_005fcrq_005fextension_005fby_005foid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fset_005fcrq_005fextension_005fby_005foid"></a>Function: <em>int</em> <strong>gnutls_x509_crt_set_crq_extension_by_oid</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_x509_crq_t <var>crq</var>, const char * <var>oid</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>crq</var>: holds a certificate request
</p>
<p><var>oid</var>: the object identifier of the OID to copy
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function will set the extension specify by  <code>oid</code> from the given request to the
certificate.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.5.1
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fset_005fcrq_005fextensions-1"></a>
<h4 class="subheading">gnutls_x509_crt_set_crq_extensions</h4>
<a name="gnutls_005fx509_005fcrt_005fset_005fcrq_005fextensions"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fset_005fcrq_005fextensions"></a>Function: <em>int</em> <strong>gnutls_x509_crt_set_crq_extensions</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_x509_crq_t <var>crq</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>crq</var>: holds a certificate request
</p>
<p>This function will set the extensions from the given request to the
certificate.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fset_005fdn-1"></a>
<h4 class="subheading">gnutls_x509_crt_set_dn</h4>
<a name="gnutls_005fx509_005fcrt_005fset_005fdn"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fset_005fdn"></a>Function: <em>int</em> <strong>gnutls_x509_crt_set_dn</strong> <em>(gnutls_x509_crt_t <var>crt</var>, const char * <var>dn</var>, const char ** <var>err</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>dn</var>: a comma separated DN string (RFC4514)
</p>
<p><var>err</var>: indicates the error position (if any)
</p>
<p>This function will set the DN on the provided certificate.
The input string should be plain ASCII or UTF-8 encoded. On
DN parsing error <code>GNUTLS_E_PARSING_ERROR</code>  is returned.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fset_005fdn_005fby_005foid-1"></a>
<h4 class="subheading">gnutls_x509_crt_set_dn_by_oid</h4>
<a name="gnutls_005fx509_005fcrt_005fset_005fdn_005fby_005foid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fset_005fdn_005fby_005foid"></a>Function: <em>int</em> <strong>gnutls_x509_crt_set_dn_by_oid</strong> <em>(gnutls_x509_crt_t <var>crt</var>, const char * <var>oid</var>, unsigned int <var>raw_flag</var>, const void * <var>name</var>, unsigned int <var>sizeof_name</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>oid</var>: holds an Object Identifier in a null terminated string
</p>
<p><var>raw_flag</var>: must be 0, or 1 if the data are DER encoded
</p>
<p><var>name</var>: a pointer to the name
</p>
<p><var>sizeof_name</var>: holds the size of  <code>name</code> 
</p>
<p>This function will set the part of the name of the Certificate
subject, specified by the given OID. The input string should be
ASCII or UTF-8 encoded.
</p>
<p>Some helper macros with popular OIDs can be found in gnutls/x509.h
With this function you can only set the known OIDs. You can test
for known OIDs using <code>gnutls_x509_dn_oid_known()</code> . For OIDs that are
not known (by gnutls) you should properly DER encode your data,
and call this function with  <code>raw_flag</code> set.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fset_005fexpiration_005ftime-1"></a>
<h4 class="subheading">gnutls_x509_crt_set_expiration_time</h4>
<a name="gnutls_005fx509_005fcrt_005fset_005fexpiration_005ftime"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fset_005fexpiration_005ftime"></a>Function: <em>int</em> <strong>gnutls_x509_crt_set_expiration_time</strong> <em>(gnutls_x509_crt_t <var>cert</var>, time_t <var>exp_time</var>)</em></dt>
<dd><p><var>cert</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>exp_time</var>: The actual time
</p>
<p>This function will set the time this Certificate will expire.
Setting an expiration time to (time_t)-1 or to <code>GNUTLS_X509_NO_WELL_DEFINED_EXPIRATION</code> 
will set to the no well-defined expiration date value. 
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fset_005fextension_005fby_005foid-1"></a>
<h4 class="subheading">gnutls_x509_crt_set_extension_by_oid</h4>
<a name="gnutls_005fx509_005fcrt_005fset_005fextension_005fby_005foid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fset_005fextension_005fby_005foid"></a>Function: <em>int</em> <strong>gnutls_x509_crt_set_extension_by_oid</strong> <em>(gnutls_x509_crt_t <var>crt</var>, const char * <var>oid</var>, const void * <var>buf</var>, size_t <var>sizeof_buf</var>, unsigned int <var>critical</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>oid</var>: holds an Object Identifier in null terminated string
</p>
<p><var>buf</var>: a pointer to a DER encoded data
</p>
<p><var>sizeof_buf</var>: holds the size of  <code>buf</code> 
</p>
<p><var>critical</var>: should be non-zero if the extension is to be marked as critical
</p>
<p>This function will set an the extension, by the specified OID, in
the certificate.  The extension data should be binary data DER
encoded.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fset_005fissuer_005falt_005fname-1"></a>
<h4 class="subheading">gnutls_x509_crt_set_issuer_alt_name</h4>
<a name="gnutls_005fx509_005fcrt_005fset_005fissuer_005falt_005fname"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fset_005fissuer_005falt_005fname"></a>Function: <em>int</em> <strong>gnutls_x509_crt_set_issuer_alt_name</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_x509_subject_alt_name_t <var>type</var>, const void * <var>data</var>, unsigned int <var>data_size</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>type</var>: is one of the gnutls_x509_subject_alt_name_t enumerations
</p>
<p><var>data</var>: The data to be set
</p>
<p><var>data_size</var>: The size of data to be set
</p>
<p><var>flags</var>: GNUTLS_FSAN_SET to clear previous data or GNUTLS_FSAN_APPEND to append. 
</p>
<p>This function will set the issuer alternative name certificate
extension. It can set the same types as <code>gnutls_x509_crt_set_subject_alt_name()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fset_005fissuer_005falt_005fothername-1"></a>
<h4 class="subheading">gnutls_x509_crt_set_issuer_alt_othername</h4>
<a name="gnutls_005fx509_005fcrt_005fset_005fissuer_005falt_005fothername"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fset_005fissuer_005falt_005fothername"></a>Function: <em>int</em> <strong>gnutls_x509_crt_set_issuer_alt_othername</strong> <em>(gnutls_x509_crt_t <var>crt</var>, const char * <var>oid</var>, const void * <var>data</var>, unsigned int <var>data_size</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>oid</var>: The other name OID
</p>
<p><var>data</var>: The data to be set
</p>
<p><var>data_size</var>: The size of data to be set
</p>
<p><var>flags</var>: GNUTLS_FSAN_SET to clear previous data or GNUTLS_FSAN_APPEND to append. 
</p>
<p>This function will set an &quot;othername&quot; to the issuer alternative name certificate
extension.
</p>
<p>The values set are set as binary values and are expected to have the proper DER encoding.
For convenience the flags <code>GNUTLS_FSAN_ENCODE_OCTET_STRING</code>  and <code>GNUTLS_FSAN_ENCODE_UTF8_STRING</code> 
can be used to encode the provided data.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fset_005fissuer_005fdn-1"></a>
<h4 class="subheading">gnutls_x509_crt_set_issuer_dn</h4>
<a name="gnutls_005fx509_005fcrt_005fset_005fissuer_005fdn"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fset_005fissuer_005fdn"></a>Function: <em>int</em> <strong>gnutls_x509_crt_set_issuer_dn</strong> <em>(gnutls_x509_crt_t <var>crt</var>, const char * <var>dn</var>, const char ** <var>err</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>dn</var>: a comma separated DN string (RFC4514)
</p>
<p><var>err</var>: indicates the error position (if any)
</p>
<p>This function will set the DN on the provided certificate.
The input string should be plain ASCII or UTF-8 encoded. On
DN parsing error <code>GNUTLS_E_PARSING_ERROR</code>  is returned.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fset_005fissuer_005fdn_005fby_005foid-1"></a>
<h4 class="subheading">gnutls_x509_crt_set_issuer_dn_by_oid</h4>
<a name="gnutls_005fx509_005fcrt_005fset_005fissuer_005fdn_005fby_005foid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fset_005fissuer_005fdn_005fby_005foid"></a>Function: <em>int</em> <strong>gnutls_x509_crt_set_issuer_dn_by_oid</strong> <em>(gnutls_x509_crt_t <var>crt</var>, const char * <var>oid</var>, unsigned int <var>raw_flag</var>, const void * <var>name</var>, unsigned int <var>sizeof_name</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>oid</var>: holds an Object Identifier in a null terminated string
</p>
<p><var>raw_flag</var>: must be 0, or 1 if the data are DER encoded
</p>
<p><var>name</var>: a pointer to the name
</p>
<p><var>sizeof_name</var>: holds the size of  <code>name</code> 
</p>
<p>This function will set the part of the name of the Certificate
issuer, specified by the given OID.  The input string should be
ASCII or UTF-8 encoded.
</p>
<p>Some helper macros with popular OIDs can be found in gnutls/x509.h
With this function you can only set the known OIDs. You can test
for known OIDs using <code>gnutls_x509_dn_oid_known()</code> . For OIDs that are
not known (by gnutls) you should properly DER encode your data,
and call this function with  <code>raw_flag</code> set.
</p>
<p>Normally you do not need to call this function, since the signing
operation will copy the signer&rsquo;s name as the issuer of the
certificate.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fset_005fissuer_005funique_005fid-1"></a>
<h4 class="subheading">gnutls_x509_crt_set_issuer_unique_id</h4>
<a name="gnutls_005fx509_005fcrt_005fset_005fissuer_005funique_005fid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fset_005fissuer_005funique_005fid"></a>Function: <em>int</em> <strong>gnutls_x509_crt_set_issuer_unique_id</strong> <em>(gnutls_x509_crt_t <var>cert</var>, const void * <var>id</var>, size_t <var>id_size</var>)</em></dt>
<dd><p><var>cert</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>id</var>: The unique ID
</p>
<p><var>id_size</var>: Holds the size of the unique ID.
</p>
<p>This function will set the X.509 certificate&rsquo;s issuer unique ID field.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.7
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fset_005fkey-1"></a>
<h4 class="subheading">gnutls_x509_crt_set_key</h4>
<a name="gnutls_005fx509_005fcrt_005fset_005fkey"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fset_005fkey"></a>Function: <em>int</em> <strong>gnutls_x509_crt_set_key</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_x509_privkey_t <var>key</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>key</var>: holds a private key
</p>
<p>This function will set the public parameters from the given
private key to the certificate.
</p>
<p>To export the public key (i.e., the SubjectPublicKeyInfo part), check
<code>gnutls_pubkey_import_x509()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fset_005fkey_005fpurpose_005foid-1"></a>
<h4 class="subheading">gnutls_x509_crt_set_key_purpose_oid</h4>
<a name="gnutls_005fx509_005fcrt_005fset_005fkey_005fpurpose_005foid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fset_005fkey_005fpurpose_005foid"></a>Function: <em>int</em> <strong>gnutls_x509_crt_set_key_purpose_oid</strong> <em>(gnutls_x509_crt_t <var>cert</var>, const void * <var>oid</var>, unsigned int <var>critical</var>)</em></dt>
<dd><p><var>cert</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>oid</var>: a pointer to a null terminated string that holds the OID
</p>
<p><var>critical</var>: Whether this extension will be critical or not
</p>
<p>This function will set the key purpose OIDs of the Certificate.
These are stored in the Extended Key Usage extension (2.5.29.37)
See the GNUTLS_KP_* definitions for human readable names.
</p>
<p>Subsequent calls to this function will append OIDs to the OID list.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fset_005fkey_005fusage-1"></a>
<h4 class="subheading">gnutls_x509_crt_set_key_usage</h4>
<a name="gnutls_005fx509_005fcrt_005fset_005fkey_005fusage"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fset_005fkey_005fusage"></a>Function: <em>int</em> <strong>gnutls_x509_crt_set_key_usage</strong> <em>(gnutls_x509_crt_t <var>crt</var>, unsigned int <var>usage</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>usage</var>: an ORed sequence of the GNUTLS_KEY_* elements.
</p>
<p>This function will set the keyUsage certificate extension.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fset_005fname_005fconstraints-1"></a>
<h4 class="subheading">gnutls_x509_crt_set_name_constraints</h4>
<a name="gnutls_005fx509_005fcrt_005fset_005fname_005fconstraints"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fset_005fname_005fconstraints"></a>Function: <em>int</em> <strong>gnutls_x509_crt_set_name_constraints</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_x509_name_constraints_t <var>nc</var>, unsigned int <var>critical</var>)</em></dt>
<dd><p><var>crt</var>: The certificate
</p>
<p><var>nc</var>: The nameconstraints structure
</p>
<p><var>critical</var>: whether this extension will be critical
</p>
<p>This function will set the provided name constraints to
the certificate extension list. This extension is always
marked as critical.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fset_005fpin_005ffunction-1"></a>
<h4 class="subheading">gnutls_x509_crt_set_pin_function</h4>
<a name="gnutls_005fx509_005fcrt_005fset_005fpin_005ffunction"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fset_005fpin_005ffunction"></a>Function: <em>void</em> <strong>gnutls_x509_crt_set_pin_function</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_pin_callback_t <var>fn</var>, void * <var>userdata</var>)</em></dt>
<dd><p><var>crt</var>: The certificate structure
</p>
<p><var>fn</var>: the callback
</p>
<p><var>userdata</var>: data associated with the callback
</p>
<p>This function will set a callback function to be used when
it is required to access a protected object. This function overrides 
the global function set using <code>gnutls_pkcs11_set_pin_function()</code> .
</p>
<p>Note that this callback is currently used only during the import
of a PKCS <code>11</code>  certificate with <code>gnutls_x509_crt_import_url()</code> .
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fset_005fpolicy-1"></a>
<h4 class="subheading">gnutls_x509_crt_set_policy</h4>
<a name="gnutls_005fx509_005fcrt_005fset_005fpolicy"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fset_005fpolicy"></a>Function: <em>int</em> <strong>gnutls_x509_crt_set_policy</strong> <em>(gnutls_x509_crt_t <var>crt</var>, const struct gnutls_x509_policy_st * <var>policy</var>, unsigned int <var>critical</var>)</em></dt>
<dd><p><var>crt</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>policy</var>: A pointer to a policy
</p>
<p><var>critical</var>: use non-zero if the extension is marked as critical
</p>
<p>This function will set the certificate policy extension (2.5.29.32).
Multiple calls to this function append a new policy.
</p>
<p>Note the maximum text size for the qualifier <code>GNUTLS_X509_QUALIFIER_NOTICE</code> 
is 200 characters. This function will fail with <code>GNUTLS_E_INVALID_REQUEST</code> 
if this is exceeded.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.5
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fset_005fprivate_005fkey_005fusage_005fperiod-1"></a>
<h4 class="subheading">gnutls_x509_crt_set_private_key_usage_period</h4>
<a name="gnutls_005fx509_005fcrt_005fset_005fprivate_005fkey_005fusage_005fperiod"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fset_005fprivate_005fkey_005fusage_005fperiod"></a>Function: <em>int</em> <strong>gnutls_x509_crt_set_private_key_usage_period</strong> <em>(gnutls_x509_crt_t <var>crt</var>, time_t <var>activation</var>, time_t <var>expiration</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>activation</var>: The activation time
</p>
<p><var>expiration</var>: The expiration time
</p>
<p>This function will set the private key usage period extension (2.5.29.16).
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fset_005fproxy-1"></a>
<h4 class="subheading">gnutls_x509_crt_set_proxy</h4>
<a name="gnutls_005fx509_005fcrt_005fset_005fproxy"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fset_005fproxy"></a>Function: <em>int</em> <strong>gnutls_x509_crt_set_proxy</strong> <em>(gnutls_x509_crt_t <var>crt</var>, int <var>pathLenConstraint</var>, const char * <var>policyLanguage</var>, const char * <var>policy</var>, size_t <var>sizeof_policy</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>pathLenConstraint</var>: non-negative error codes indicate maximum length of path,
and negative error codes indicate that the pathLenConstraints field should
not be present.
</p>
<p><var>policyLanguage</var>: OID describing the language of  <code>policy</code> .
</p>
<p><var>policy</var>: uint8_t byte array with policy language, can be <code>NULL</code> 
</p>
<p><var>sizeof_policy</var>: size of  <code>policy</code> .
</p>
<p>This function will set the proxyCertInfo extension.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fset_005fproxy_005fdn-1"></a>
<h4 class="subheading">gnutls_x509_crt_set_proxy_dn</h4>
<a name="gnutls_005fx509_005fcrt_005fset_005fproxy_005fdn"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fset_005fproxy_005fdn"></a>Function: <em>int</em> <strong>gnutls_x509_crt_set_proxy_dn</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_x509_crt_t <var>eecrt</var>, unsigned int <var>raw_flag</var>, const void * <var>name</var>, unsigned int <var>sizeof_name</var>)</em></dt>
<dd><p><var>crt</var>: a gnutls_x509_crt_t type with the new proxy cert
</p>
<p><var>eecrt</var>: the end entity certificate that will be issuing the proxy
</p>
<p><var>raw_flag</var>: must be 0, or 1 if the CN is DER encoded
</p>
<p><var>name</var>: a pointer to the CN name, may be NULL (but MUST then be added later)
</p>
<p><var>sizeof_name</var>: holds the size of  <code>name</code> 
</p>
<p>This function will set the subject in  <code>crt</code> to the end entity&rsquo;s
 <code>eecrt</code> subject name, and add a single Common Name component  <code>name</code> of size  <code>sizeof_name</code> .  This corresponds to the required proxy
certificate naming style.  Note that if  <code>name</code> is <code>NULL</code> , you MUST
set it later by using <code>gnutls_x509_crt_set_dn_by_oid()</code>  or similar.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fset_005fserial-1"></a>
<h4 class="subheading">gnutls_x509_crt_set_serial</h4>
<a name="gnutls_005fx509_005fcrt_005fset_005fserial"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fset_005fserial"></a>Function: <em>int</em> <strong>gnutls_x509_crt_set_serial</strong> <em>(gnutls_x509_crt_t <var>cert</var>, const void * <var>serial</var>, size_t <var>serial_size</var>)</em></dt>
<dd><p><var>cert</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>serial</var>: The serial number
</p>
<p><var>serial_size</var>: Holds the size of the serial field.
</p>
<p>This function will set the X.509 certificate&rsquo;s serial number.
While the serial number is an integer, it is often handled
as an opaque field by several CAs. For this reason this function
accepts any kind of data as a serial number. To be consistent
with the X.509/PKIX specifications the provided  <code>serial</code> should be 
a big-endian positive number (i.e. it&rsquo;s leftmost bit should be zero).
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fset_005fsubject_005falt_005fname-1"></a>
<h4 class="subheading">gnutls_x509_crt_set_subject_alt_name</h4>
<a name="gnutls_005fx509_005fcrt_005fset_005fsubject_005falt_005fname"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fset_005fsubject_005falt_005fname"></a>Function: <em>int</em> <strong>gnutls_x509_crt_set_subject_alt_name</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_x509_subject_alt_name_t <var>type</var>, const void * <var>data</var>, unsigned int <var>data_size</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>type</var>: is one of the gnutls_x509_subject_alt_name_t enumerations
</p>
<p><var>data</var>: The data to be set
</p>
<p><var>data_size</var>: The size of data to be set
</p>
<p><var>flags</var>: GNUTLS_FSAN_SET to clear previous data or GNUTLS_FSAN_APPEND to append. 
</p>
<p>This function will set the subject alternative name certificate
extension. It can set the following types: <code>GNUTLS_SAN_DNSNAME</code>  as a text string,
<code>GNUTLS_SAN_RFC822NAME</code>  as a text string, <code>GNUTLS_SAN_URI</code>  as a text string,
<code>GNUTLS_SAN_IPADDRESS</code>  as a binary IP address (4 or 16 bytes),
<code>GNUTLS_SAN_OTHERNAME_XMPP</code>  as a UTF8 string (since 3.5.0).
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.6.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fset_005fsubject_005falt_005fothername-1"></a>
<h4 class="subheading">gnutls_x509_crt_set_subject_alt_othername</h4>
<a name="gnutls_005fx509_005fcrt_005fset_005fsubject_005falt_005fothername"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fset_005fsubject_005falt_005fothername"></a>Function: <em>int</em> <strong>gnutls_x509_crt_set_subject_alt_othername</strong> <em>(gnutls_x509_crt_t <var>crt</var>, const char * <var>oid</var>, const void * <var>data</var>, unsigned int <var>data_size</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>oid</var>: The other name OID
</p>
<p><var>data</var>: The data to be set
</p>
<p><var>data_size</var>: The size of data to be set
</p>
<p><var>flags</var>: GNUTLS_FSAN_SET to clear previous data or GNUTLS_FSAN_APPEND to append. 
</p>
<p>This function will set an &quot;othername&quot; to the subject alternative name certificate
extension.
</p>
<p>The values set are set as binary values and are expected to have the proper DER encoding.
For convenience the flags <code>GNUTLS_FSAN_ENCODE_OCTET_STRING</code>  and <code>GNUTLS_FSAN_ENCODE_UTF8_STRING</code> 
can be used to encode the provided data.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fset_005fsubject_005falternative_005fname-1"></a>
<h4 class="subheading">gnutls_x509_crt_set_subject_alternative_name</h4>
<a name="gnutls_005fx509_005fcrt_005fset_005fsubject_005falternative_005fname"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fset_005fsubject_005falternative_005fname"></a>Function: <em>int</em> <strong>gnutls_x509_crt_set_subject_alternative_name</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_x509_subject_alt_name_t           <var>type</var>, const char * <var>data_string</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>type</var>: is one of the gnutls_x509_subject_alt_name_t enumerations
</p>
<p><var>data_string</var>: The data to be set, a (0) terminated string
</p>
<p>This function will set the subject alternative name certificate
extension. This function assumes that data can be expressed as a null
terminated string.
</p>
<p>The name of the function is unfortunate since it is incosistent with
<code>gnutls_x509_crt_get_subject_alt_name()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fset_005fsubject_005fkey_005fid-1"></a>
<h4 class="subheading">gnutls_x509_crt_set_subject_key_id</h4>
<a name="gnutls_005fx509_005fcrt_005fset_005fsubject_005fkey_005fid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fset_005fsubject_005fkey_005fid"></a>Function: <em>int</em> <strong>gnutls_x509_crt_set_subject_key_id</strong> <em>(gnutls_x509_crt_t <var>cert</var>, const void * <var>id</var>, size_t <var>id_size</var>)</em></dt>
<dd><p><var>cert</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>id</var>: The key ID
</p>
<p><var>id_size</var>: Holds the size of the subject key ID field.
</p>
<p>This function will set the X.509 certificate&rsquo;s subject key ID
extension.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fset_005fsubject_005funique_005fid-1"></a>
<h4 class="subheading">gnutls_x509_crt_set_subject_unique_id</h4>
<a name="gnutls_005fx509_005fcrt_005fset_005fsubject_005funique_005fid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fset_005fsubject_005funique_005fid"></a>Function: <em>int</em> <strong>gnutls_x509_crt_set_subject_unique_id</strong> <em>(gnutls_x509_crt_t <var>cert</var>, const void * <var>id</var>, size_t <var>id_size</var>)</em></dt>
<dd><p><var>cert</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>id</var>: The unique ID
</p>
<p><var>id_size</var>: Holds the size of the unique ID.
</p>
<p>This function will set the X.509 certificate&rsquo;s subject unique ID field.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.7
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fset_005ftlsfeatures-1"></a>
<h4 class="subheading">gnutls_x509_crt_set_tlsfeatures</h4>
<a name="gnutls_005fx509_005fcrt_005fset_005ftlsfeatures"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fset_005ftlsfeatures"></a>Function: <em>int</em> <strong>gnutls_x509_crt_set_tlsfeatures</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_x509_tlsfeatures_t <var>features</var>)</em></dt>
<dd><p><var>crt</var>: A X.509 certificate
</p>
<p><var>features</var>: If the function succeeds, the
features will be added to the certificate.
</p>
<p>This function will set the certificates
X.509 TLS extension from the given structure.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.5.1
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fset_005fversion-1"></a>
<h4 class="subheading">gnutls_x509_crt_set_version</h4>
<a name="gnutls_005fx509_005fcrt_005fset_005fversion"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fset_005fversion"></a>Function: <em>int</em> <strong>gnutls_x509_crt_set_version</strong> <em>(gnutls_x509_crt_t <var>crt</var>, unsigned int <var>version</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>version</var>: holds the version number. For X.509v1 certificates must be 1.
</p>
<p>This function will set the version of the certificate.  This must
be one for X.509 version 1, and so on.  Plain certificates without
extensions must have version set to one.
</p>
<p>To create well-formed certificates, you must specify version 3 if
you use any certificate extensions.  Extensions are created by
functions such as <code>gnutls_x509_crt_set_subject_alt_name()</code> 
or <code>gnutls_x509_crt_set_key_usage()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fsign-1"></a>
<h4 class="subheading">gnutls_x509_crt_sign</h4>
<a name="gnutls_005fx509_005fcrt_005fsign"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fsign"></a>Function: <em>int</em> <strong>gnutls_x509_crt_sign</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_x509_crt_t <var>issuer</var>, gnutls_x509_privkey_t <var>issuer_key</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>issuer</var>: is the certificate of the certificate issuer
</p>
<p><var>issuer_key</var>: holds the issuer&rsquo;s private key
</p>
<p>This function is the same a <code>gnutls_x509_crt_sign2()</code>  with no flags,
and SHA1 as the hash algorithm.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fsign2-1"></a>
<h4 class="subheading">gnutls_x509_crt_sign2</h4>
<a name="gnutls_005fx509_005fcrt_005fsign2"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fsign2"></a>Function: <em>int</em> <strong>gnutls_x509_crt_sign2</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_x509_crt_t <var>issuer</var>, gnutls_x509_privkey_t <var>issuer_key</var>, gnutls_digest_algorithm_t <var>dig</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>issuer</var>: is the certificate of the certificate issuer
</p>
<p><var>issuer_key</var>: holds the issuer&rsquo;s private key
</p>
<p><var>dig</var>: The message digest to use, <code>GNUTLS_DIG_SHA1</code>  is a safe choice
</p>
<p><var>flags</var>: must be 0
</p>
<p>This function will sign the certificate with the issuer&rsquo;s private key, and
will copy the issuer&rsquo;s information into the certificate.
</p>
<p>This must be the last step in a certificate generation since all
the previously set parameters are now signed.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fverify-1"></a>
<h4 class="subheading">gnutls_x509_crt_verify</h4>
<a name="gnutls_005fx509_005fcrt_005fverify"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fverify"></a>Function: <em>int</em> <strong>gnutls_x509_crt_verify</strong> <em>(gnutls_x509_crt_t <var>cert</var>, const gnutls_x509_crt_t * <var>CA_list</var>, unsigned <var>CA_list_length</var>, unsigned int <var>flags</var>, unsigned int * <var>verify</var>)</em></dt>
<dd><p><var>cert</var>: is the certificate to be verified
</p>
<p><var>CA_list</var>: is one certificate that is considered to be trusted one
</p>
<p><var>CA_list_length</var>: holds the number of CA certificate in CA_list
</p>
<p><var>flags</var>: Flags that may be used to change the verification algorithm. Use OR of the gnutls_certificate_verify_flags enumerations.
</p>
<p><var>verify</var>: will hold the certificate verification output.
</p>
<p>This function will try to verify the given certificate and return
its status. Note that a verification error does not imply a negative
return status. In that case the  <code>verify</code> status is set.
</p>
<p>The details of the verification are the same
as in <code>gnutls_x509_trust_list_verify_crt2()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fcrt_005fverify_005fdata2-1"></a>
<h4 class="subheading">gnutls_x509_crt_verify_data2</h4>
<a name="gnutls_005fx509_005fcrt_005fverify_005fdata2"></a><dl>
<dt><a name="index-gnutls_005fx509_005fcrt_005fverify_005fdata2"></a>Function: <em>int</em> <strong>gnutls_x509_crt_verify_data2</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_sign_algorithm_t <var>algo</var>, unsigned int <var>flags</var>, const gnutls_datum_t * <var>data</var>, const gnutls_datum_t * <var>signature</var>)</em></dt>
<dd><p><var>crt</var>: Holds the certificate to verify with
</p>
<p><var>algo</var>: The signature algorithm used
</p>
<p><var>flags</var>: Zero or an OR list of <code>gnutls_certificate_verify_flags</code> 
</p>
<p><var>data</var>: holds the signed data
</p>
<p><var>signature</var>: contains the signature
</p>
<p>This function will verify the given signed data, using the
parameters from the certificate.
</p>
<p><strong>Returns:</strong> In case of a verification failure <code>GNUTLS_E_PK_SIG_VERIFY_FAILED</code>  
is returned, and zero or positive code on success.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<a name="gnutls_005fx509_005fdn_005fdeinit-1"></a>
<h4 class="subheading">gnutls_x509_dn_deinit</h4>
<a name="gnutls_005fx509_005fdn_005fdeinit"></a><dl>
<dt><a name="index-gnutls_005fx509_005fdn_005fdeinit"></a>Function: <em>void</em> <strong>gnutls_x509_dn_deinit</strong> <em>(gnutls_x509_dn_t <var>dn</var>)</em></dt>
<dd><p><var>dn</var>: a DN uint8_t object pointer.
</p>
<p>This function deallocates the DN object as returned by
<code>gnutls_x509_dn_import()</code> .
</p>
<p><strong>Since:</strong> 2.4.0
</p></dd></dl>

<a name="gnutls_005fx509_005fdn_005fexport-1"></a>
<h4 class="subheading">gnutls_x509_dn_export</h4>
<a name="gnutls_005fx509_005fdn_005fexport"></a><dl>
<dt><a name="index-gnutls_005fx509_005fdn_005fexport"></a>Function: <em>int</em> <strong>gnutls_x509_dn_export</strong> <em>(gnutls_x509_dn_t <var>dn</var>, gnutls_x509_crt_fmt_t <var>format</var>, void * <var>output_data</var>, size_t * <var>output_data_size</var>)</em></dt>
<dd><p><var>dn</var>: Holds the uint8_t DN object
</p>
<p><var>format</var>: the format of output params. One of PEM or DER.
</p>
<p><var>output_data</var>: will contain a DN PEM or DER encoded
</p>
<p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)
</p>
<p>This function will export the DN to DER or PEM format.
</p>
<p>If the buffer provided is not long enough to hold the output, then
* <code>output_data_size</code> is updated and <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> 
will be returned.
</p>
<p>If the structure is PEM encoded, it will have a header
of &quot;BEGIN NAME&quot;.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fdn_005fexport2-1"></a>
<h4 class="subheading">gnutls_x509_dn_export2</h4>
<a name="gnutls_005fx509_005fdn_005fexport2"></a><dl>
<dt><a name="index-gnutls_005fx509_005fdn_005fexport2"></a>Function: <em>int</em> <strong>gnutls_x509_dn_export2</strong> <em>(gnutls_x509_dn_t <var>dn</var>, gnutls_x509_crt_fmt_t <var>format</var>, gnutls_datum_t * <var>out</var>)</em></dt>
<dd><p><var>dn</var>: Holds the uint8_t DN object
</p>
<p><var>format</var>: the format of output params. One of PEM or DER.
</p>
<p><var>out</var>: will contain a DN PEM or DER encoded
</p>
<p>This function will export the DN to DER or PEM format.
</p>
<p>The output buffer is allocated using <code>gnutls_malloc()</code> .
</p>
<p>If the structure is PEM encoded, it will have a header
of &quot;BEGIN NAME&quot;.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.3
</p></dd></dl>

<a name="gnutls_005fx509_005fdn_005fget_005frdn_005fava-1"></a>
<h4 class="subheading">gnutls_x509_dn_get_rdn_ava</h4>
<a name="gnutls_005fx509_005fdn_005fget_005frdn_005fava"></a><dl>
<dt><a name="index-gnutls_005fx509_005fdn_005fget_005frdn_005fava-1"></a>Function: <em>int</em> <strong>gnutls_x509_dn_get_rdn_ava</strong> <em>(gnutls_x509_dn_t <var>dn</var>, int <var>irdn</var>, int <var>iava</var>, gnutls_x509_ava_st * <var>ava</var>)</em></dt>
<dd><p><var>dn</var>: a pointer to DN
</p>
<p><var>irdn</var>: index of RDN
</p>
<p><var>iava</var>: index of AVA.
</p>
<p><var>ava</var>: Pointer to structure which will hold output information.
</p>
<p>Get pointers to data within the DN. The format of the  <code>ava</code> structure
is shown below.
</p>
<p>struct gnutls_x509_ava_st {
gnutls_datum_t oid;
gnutls_datum_t value;
unsigned long value_tag;
};
</p>
<p>The X.509 distinguished name is a sequence of sequences of strings
and this is what the  <code>irdn</code> and  <code>iava</code> indexes model.
</p>
<p>Note that  <code>ava</code> will contain pointers into the  <code>dn</code> structure which
in turns points to the original certificate. Thus you should not
modify any data or deallocate any of those.
</p>
<p>This is a low-level function that requires the caller to do the
value conversions when necessary (e.g. from UCS-2).
</p>
<p><strong>Returns:</strong> Returns 0 on success, or an error code.
</p></dd></dl>

<a name="gnutls_005fx509_005fdn_005fget_005fstr-1"></a>
<h4 class="subheading">gnutls_x509_dn_get_str</h4>
<a name="gnutls_005fx509_005fdn_005fget_005fstr"></a><dl>
<dt><a name="index-gnutls_005fx509_005fdn_005fget_005fstr"></a>Function: <em>int</em> <strong>gnutls_x509_dn_get_str</strong> <em>(gnutls_x509_dn_t <var>dn</var>, gnutls_datum_t * <var>str</var>)</em></dt>
<dd><p><var>dn</var>: a pointer to DN
</p>
<p><var>str</var>: a datum that will hold the name
</p>
<p>This function will allocate buffer and copy the name in the provided DN.
The name will be in the form &quot;C=xxxx,O=yyyy,CN=zzzz&quot; as
described in RFC4514. The output string will be ASCII or UTF-8
encoded, depending on the certificate data.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.2
</p></dd></dl>

<a name="gnutls_005fx509_005fdn_005fimport-1"></a>
<h4 class="subheading">gnutls_x509_dn_import</h4>
<a name="gnutls_005fx509_005fdn_005fimport"></a><dl>
<dt><a name="index-gnutls_005fx509_005fdn_005fimport"></a>Function: <em>int</em> <strong>gnutls_x509_dn_import</strong> <em>(gnutls_x509_dn_t <var>dn</var>, const gnutls_datum_t * <var>data</var>)</em></dt>
<dd><p><var>dn</var>: the structure that will hold the imported DN
</p>
<p><var>data</var>: should contain a DER encoded RDN sequence
</p>
<p>This function parses an RDN sequence and stores the result to a
<code>gnutls_x509_dn_t</code>  type. The data must have been initialized
with <code>gnutls_x509_dn_init()</code> . You may use <code>gnutls_x509_dn_get_rdn_ava()</code>  to
decode the DN.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.4.0
</p></dd></dl>

<a name="gnutls_005fx509_005fdn_005finit-1"></a>
<h4 class="subheading">gnutls_x509_dn_init</h4>
<a name="gnutls_005fx509_005fdn_005finit"></a><dl>
<dt><a name="index-gnutls_005fx509_005fdn_005finit"></a>Function: <em>int</em> <strong>gnutls_x509_dn_init</strong> <em>(gnutls_x509_dn_t * <var>dn</var>)</em></dt>
<dd><p><var>dn</var>: the object to be initialized
</p>
<p>This function initializes a <code>gnutls_x509_dn_t</code>  type.
</p>
<p>The object returned must be deallocated using
<code>gnutls_x509_dn_deinit()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.4.0
</p></dd></dl>

<a name="gnutls_005fx509_005fdn_005foid_005fknown-1"></a>
<h4 class="subheading">gnutls_x509_dn_oid_known</h4>
<a name="gnutls_005fx509_005fdn_005foid_005fknown"></a><dl>
<dt><a name="index-gnutls_005fx509_005fdn_005foid_005fknown"></a>Function: <em>int</em> <strong>gnutls_x509_dn_oid_known</strong> <em>(const char * <var>oid</var>)</em></dt>
<dd><p><var>oid</var>: holds an Object Identifier in a null terminated string
</p>
<p>This function will inform about known DN OIDs. This is useful since
functions like <code>gnutls_x509_crt_set_dn_by_oid()</code>  use the information
on known OIDs to properly encode their input. Object Identifiers
that are not known are not encoded by these functions, and their
input is stored directly into the ASN.1 structure. In that case of
unknown OIDs, you have the responsibility of DER encoding your
data.
</p>
<p><strong>Returns:</strong> 1 on known OIDs and 0 otherwise.
</p></dd></dl>

<a name="gnutls_005fx509_005fdn_005foid_005fname-1"></a>
<h4 class="subheading">gnutls_x509_dn_oid_name</h4>
<a name="gnutls_005fx509_005fdn_005foid_005fname"></a><dl>
<dt><a name="index-gnutls_005fx509_005fdn_005foid_005fname"></a>Function: <em>const char *</em> <strong>gnutls_x509_dn_oid_name</strong> <em>(const char * <var>oid</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>oid</var>: holds an Object Identifier in a null terminated string
</p>
<p><var>flags</var>: 0 or GNUTLS_X509_DN_OID_*
</p>
<p>This function will return the name of a known DN OID. If
<code>GNUTLS_X509_DN_OID_RETURN_OID</code>  is specified this function
will return the given OID if no descriptive name has been
found.
</p>
<p><strong>Returns:</strong> A null terminated string or NULL otherwise.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fdn_005fset_005fstr-1"></a>
<h4 class="subheading">gnutls_x509_dn_set_str</h4>
<a name="gnutls_005fx509_005fdn_005fset_005fstr"></a><dl>
<dt><a name="index-gnutls_005fx509_005fdn_005fset_005fstr"></a>Function: <em>int</em> <strong>gnutls_x509_dn_set_str</strong> <em>(gnutls_x509_dn_t <var>dn</var>, const char * <var>str</var>, const char ** <var>err</var>)</em></dt>
<dd><p><var>dn</var>: a pointer to DN
</p>
<p><var>str</var>: a comma separated DN string (RFC4514)
</p>
<p><var>err</var>: indicates the error position (if any)
</p>
<p>This function will set the DN on the provided DN structure.
The input string should be plain ASCII or UTF-8 encoded. On
DN parsing error <code>GNUTLS_E_PARSING_ERROR</code>  is returned.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.5.3
</p></dd></dl>

<a name="gnutls_005fx509_005fext_005fdeinit-1"></a>
<h4 class="subheading">gnutls_x509_ext_deinit</h4>
<a name="gnutls_005fx509_005fext_005fdeinit"></a><dl>
<dt><a name="index-gnutls_005fx509_005fext_005fdeinit"></a>Function: <em>void</em> <strong>gnutls_x509_ext_deinit</strong> <em>(gnutls_x509_ext_st * <var>ext</var>)</em></dt>
<dd><p><var>ext</var>: The extensions structure
</p>
<p>This function will deinitialize an extensions structure.
</p>
<p><strong>Since:</strong> 3.3.8
</p></dd></dl>

<a name="gnutls_005fx509_005fext_005fexport_005faia-1"></a>
<h4 class="subheading">gnutls_x509_ext_export_aia</h4>
<a name="gnutls_005fx509_005fext_005fexport_005faia"></a><dl>
<dt><a name="index-gnutls_005fx509_005fext_005fexport_005faia"></a>Function: <em>int</em> <strong>gnutls_x509_ext_export_aia</strong> <em>(gnutls_x509_aia_t <var>aia</var>, gnutls_datum_t * <var>ext</var>)</em></dt>
<dd><p><var>aia</var>: The authority info access
</p>
<p><var>ext</var>: The DER-encoded extension data; must be freed using <code>gnutls_free()</code> .
</p>
<p>This function will DER encode the Authority Information Access (AIA)
extension; see RFC 5280 section 4.2.2.1 for more information on the
extension.  
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fext_005fexport_005fauthority_005fkey_005fid-1"></a>
<h4 class="subheading">gnutls_x509_ext_export_authority_key_id</h4>
<a name="gnutls_005fx509_005fext_005fexport_005fauthority_005fkey_005fid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fext_005fexport_005fauthority_005fkey_005fid"></a>Function: <em>int</em> <strong>gnutls_x509_ext_export_authority_key_id</strong> <em>(gnutls_x509_aki_t <var>aki</var>, gnutls_datum_t * <var>ext</var>)</em></dt>
<dd><p><var>aki</var>: An initialized authority key identifier
</p>
<p><var>ext</var>: The DER-encoded extension data; must be freed using <code>gnutls_free()</code> .
</p>
<p>This function will convert the provided key identifier to a
DER-encoded PKIX AuthorityKeyIdentifier extension. 
The output data in  <code>ext</code> will be allocated using
<code>gnutls_malloc()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fext_005fexport_005fbasic_005fconstraints-1"></a>
<h4 class="subheading">gnutls_x509_ext_export_basic_constraints</h4>
<a name="gnutls_005fx509_005fext_005fexport_005fbasic_005fconstraints"></a><dl>
<dt><a name="index-gnutls_005fx509_005fext_005fexport_005fbasic_005fconstraints"></a>Function: <em>int</em> <strong>gnutls_x509_ext_export_basic_constraints</strong> <em>(unsigned int <var>ca</var>, int <var>pathlen</var>, gnutls_datum_t * <var>ext</var>)</em></dt>
<dd><p><var>ca</var>: non-zero for a CA
</p>
<p><var>pathlen</var>: The path length constraint (set to -1 for no constraint)
</p>
<p><var>ext</var>: The DER-encoded extension data; must be freed using <code>gnutls_free()</code> .
</p>
<p>This function will convert the parameters provided to a basic constraints
DER encoded extension (2.5.29.19).
The  <code>ext</code> data will be allocated using
<code>gnutls_malloc()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fext_005fexport_005fcrl_005fdist_005fpoints-1"></a>
<h4 class="subheading">gnutls_x509_ext_export_crl_dist_points</h4>
<a name="gnutls_005fx509_005fext_005fexport_005fcrl_005fdist_005fpoints"></a><dl>
<dt><a name="index-gnutls_005fx509_005fext_005fexport_005fcrl_005fdist_005fpoints"></a>Function: <em>int</em> <strong>gnutls_x509_ext_export_crl_dist_points</strong> <em>(gnutls_x509_crl_dist_points_t <var>cdp</var>, gnutls_datum_t * <var>ext</var>)</em></dt>
<dd><p><var>cdp</var>: A pointer to an initialized CRL distribution points.
</p>
<p><var>ext</var>: The DER-encoded extension data; must be freed using <code>gnutls_free()</code> .
</p>
<p>This function will convert the provided policies, to a certificate policy
DER encoded extension (2.5.29.31).
</p>
<p>The  <code>ext</code> data will be allocated using <code>gnutls_malloc()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fext_005fexport_005fkey_005fpurposes-1"></a>
<h4 class="subheading">gnutls_x509_ext_export_key_purposes</h4>
<a name="gnutls_005fx509_005fext_005fexport_005fkey_005fpurposes"></a><dl>
<dt><a name="index-gnutls_005fx509_005fext_005fexport_005fkey_005fpurposes"></a>Function: <em>int</em> <strong>gnutls_x509_ext_export_key_purposes</strong> <em>(gnutls_x509_key_purposes_t <var>p</var>, gnutls_datum_t * <var>ext</var>)</em></dt>
<dd><p><var>p</var>: The key purposes
</p>
<p><var>ext</var>: The DER-encoded extension data; must be freed using <code>gnutls_free()</code> .
</p>
<p>This function will convert the key purposes type to a
DER-encoded PKIX ExtKeyUsageSyntax (2.5.29.37) extension. The output data in 
 <code>ext</code> will be allocated usin <code>gnutls_malloc()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fext_005fexport_005fkey_005fusage-1"></a>
<h4 class="subheading">gnutls_x509_ext_export_key_usage</h4>
<a name="gnutls_005fx509_005fext_005fexport_005fkey_005fusage"></a><dl>
<dt><a name="index-gnutls_005fx509_005fext_005fexport_005fkey_005fusage"></a>Function: <em>int</em> <strong>gnutls_x509_ext_export_key_usage</strong> <em>(unsigned int <var>usage</var>, gnutls_datum_t * <var>ext</var>)</em></dt>
<dd><p><var>usage</var>: an ORed sequence of the GNUTLS_KEY_* elements.
</p>
<p><var>ext</var>: The DER-encoded extension data; must be freed using <code>gnutls_free()</code> .
</p>
<p>This function will convert the keyUsage bit string to a DER
encoded PKIX extension. The  <code>ext</code> data will be allocated using
<code>gnutls_malloc()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fext_005fexport_005fname_005fconstraints-1"></a>
<h4 class="subheading">gnutls_x509_ext_export_name_constraints</h4>
<a name="gnutls_005fx509_005fext_005fexport_005fname_005fconstraints"></a><dl>
<dt><a name="index-gnutls_005fx509_005fext_005fexport_005fname_005fconstraints"></a>Function: <em>int</em> <strong>gnutls_x509_ext_export_name_constraints</strong> <em>(gnutls_x509_name_constraints_t <var>nc</var>, gnutls_datum_t * <var>ext</var>)</em></dt>
<dd><p><var>nc</var>: The nameconstraints
</p>
<p><var>ext</var>: The DER-encoded extension data; must be freed using <code>gnutls_free()</code> .
</p>
<p>This function will convert the provided name constraints type to a
DER-encoded PKIX NameConstraints (2.5.29.30) extension. The output data in 
 <code>ext</code> will be allocated usin <code>gnutls_malloc()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fext_005fexport_005fpolicies-1"></a>
<h4 class="subheading">gnutls_x509_ext_export_policies</h4>
<a name="gnutls_005fx509_005fext_005fexport_005fpolicies"></a><dl>
<dt><a name="index-gnutls_005fx509_005fext_005fexport_005fpolicies"></a>Function: <em>int</em> <strong>gnutls_x509_ext_export_policies</strong> <em>(gnutls_x509_policies_t <var>policies</var>, gnutls_datum_t * <var>ext</var>)</em></dt>
<dd><p><var>policies</var>: A pointer to an initialized policies.
</p>
<p><var>ext</var>: The DER-encoded extension data; must be freed using <code>gnutls_free()</code> .
</p>
<p>This function will convert the provided policies, to a certificate policy
DER encoded extension (2.5.29.32).
</p>
<p>The  <code>ext</code> data will be allocated using <code>gnutls_malloc()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fext_005fexport_005fprivate_005fkey_005fusage_005fperiod-1"></a>
<h4 class="subheading">gnutls_x509_ext_export_private_key_usage_period</h4>
<a name="gnutls_005fx509_005fext_005fexport_005fprivate_005fkey_005fusage_005fperiod"></a><dl>
<dt><a name="index-gnutls_005fx509_005fext_005fexport_005fprivate_005fkey_005fusage_005fperiod"></a>Function: <em>int</em> <strong>gnutls_x509_ext_export_private_key_usage_period</strong> <em>(time_t <var>activation</var>, time_t <var>expiration</var>, gnutls_datum_t * <var>ext</var>)</em></dt>
<dd><p><var>activation</var>: The activation time
</p>
<p><var>expiration</var>: The expiration time
</p>
<p><var>ext</var>: The DER-encoded extension data; must be freed using <code>gnutls_free()</code> .
</p>
<p>This function will convert the periods provided to a private key
usage DER encoded extension (2.5.29.16).
The  <code>ext</code> data will be allocated using
<code>gnutls_malloc()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fext_005fexport_005fproxy-1"></a>
<h4 class="subheading">gnutls_x509_ext_export_proxy</h4>
<a name="gnutls_005fx509_005fext_005fexport_005fproxy"></a><dl>
<dt><a name="index-gnutls_005fx509_005fext_005fexport_005fproxy"></a>Function: <em>int</em> <strong>gnutls_x509_ext_export_proxy</strong> <em>(int <var>pathLenConstraint</var>, const char * <var>policyLanguage</var>, const char * <var>policy</var>, size_t <var>sizeof_policy</var>, gnutls_datum_t * <var>ext</var>)</em></dt>
<dd><p><var>pathLenConstraint</var>: A negative value will remove the path length constraint,
while non-negative values will be set as the length of the pathLenConstraints field.
</p>
<p><var>policyLanguage</var>: OID describing the language of  <code>policy</code> .
</p>
<p><var>policy</var>: uint8_t byte array with policy language, can be <code>NULL</code> 
</p>
<p><var>sizeof_policy</var>: size of  <code>policy</code> .
</p>
<p><var>ext</var>: The DER-encoded extension data; must be freed using <code>gnutls_free()</code> .
</p>
<p>This function will convert the parameters provided to a proxyCertInfo extension.
</p>
<p>The  <code>ext</code> data will be allocated using <code>gnutls_malloc()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fext_005fexport_005fsubject_005falt_005fnames-1"></a>
<h4 class="subheading">gnutls_x509_ext_export_subject_alt_names</h4>
<a name="gnutls_005fx509_005fext_005fexport_005fsubject_005falt_005fnames"></a><dl>
<dt><a name="index-gnutls_005fx509_005fext_005fexport_005fsubject_005falt_005fnames"></a>Function: <em>int</em> <strong>gnutls_x509_ext_export_subject_alt_names</strong> <em>(gnutls_subject_alt_names_t <var>sans</var>, gnutls_datum_t * <var>ext</var>)</em></dt>
<dd><p><var>sans</var>: The alternative names
</p>
<p><var>ext</var>: The DER-encoded extension data; must be freed using <code>gnutls_free()</code> .
</p>
<p>This function will convert the provided alternative names structure to a
DER-encoded SubjectAltName PKIX extension. The output data in  <code>ext</code> will be allocated using
<code>gnutls_malloc()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fext_005fexport_005fsubject_005fkey_005fid-1"></a>
<h4 class="subheading">gnutls_x509_ext_export_subject_key_id</h4>
<a name="gnutls_005fx509_005fext_005fexport_005fsubject_005fkey_005fid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fext_005fexport_005fsubject_005fkey_005fid"></a>Function: <em>int</em> <strong>gnutls_x509_ext_export_subject_key_id</strong> <em>(const gnutls_datum_t * <var>id</var>, gnutls_datum_t * <var>ext</var>)</em></dt>
<dd><p><var>id</var>: The key identifier
</p>
<p><var>ext</var>: The DER-encoded extension data; must be freed using <code>gnutls_free()</code> .
</p>
<p>This function will convert the provided key identifier to a
DER-encoded PKIX SubjectKeyIdentifier extension. 
The output data in  <code>ext</code> will be allocated using
<code>gnutls_malloc()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fext_005fexport_005ftlsfeatures-1"></a>
<h4 class="subheading">gnutls_x509_ext_export_tlsfeatures</h4>
<a name="gnutls_005fx509_005fext_005fexport_005ftlsfeatures"></a><dl>
<dt><a name="index-gnutls_005fx509_005fext_005fexport_005ftlsfeatures"></a>Function: <em>int</em> <strong>gnutls_x509_ext_export_tlsfeatures</strong> <em>(gnutls_x509_tlsfeatures_t <var>f</var>, gnutls_datum_t * <var>ext</var>)</em></dt>
<dd><p><var>f</var>: The features structure
</p>
<p><var>ext</var>: The DER-encoded extension data; must be freed using <code>gnutls_free()</code> .
</p>
<p>This function will convert the provided TLS features structure structure to a
DER-encoded TLS features PKIX extension. The output data in  <code>ext</code> will be allocated using
<code>gnutls_malloc()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.5.1
</p></dd></dl>

<a name="gnutls_005fx509_005fext_005fimport_005faia-1"></a>
<h4 class="subheading">gnutls_x509_ext_import_aia</h4>
<a name="gnutls_005fx509_005fext_005fimport_005faia"></a><dl>
<dt><a name="index-gnutls_005fx509_005fext_005fimport_005faia"></a>Function: <em>int</em> <strong>gnutls_x509_ext_import_aia</strong> <em>(const gnutls_datum_t * <var>ext</var>, gnutls_x509_aia_t <var>aia</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>ext</var>: The DER-encoded extension data
</p>
<p><var>aia</var>: The authority info access
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function extracts the Authority Information Access (AIA)
extension from the provided DER-encoded data; see RFC 5280 section 4.2.2.1 
for more information on the extension.  The
AIA extension holds a sequence of AccessDescription (AD) data.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fext_005fimport_005fauthority_005fkey_005fid-1"></a>
<h4 class="subheading">gnutls_x509_ext_import_authority_key_id</h4>
<a name="gnutls_005fx509_005fext_005fimport_005fauthority_005fkey_005fid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fext_005fimport_005fauthority_005fkey_005fid"></a>Function: <em>int</em> <strong>gnutls_x509_ext_import_authority_key_id</strong> <em>(const gnutls_datum_t * <var>ext</var>, gnutls_x509_aki_t <var>aki</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>ext</var>: a DER encoded extension
</p>
<p><var>aki</var>: An initialized authority key identifier type
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function will return the subject key ID stored in the provided
AuthorityKeyIdentifier extension.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
if the extension is not present, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fext_005fimport_005fbasic_005fconstraints-1"></a>
<h4 class="subheading">gnutls_x509_ext_import_basic_constraints</h4>
<a name="gnutls_005fx509_005fext_005fimport_005fbasic_005fconstraints"></a><dl>
<dt><a name="index-gnutls_005fx509_005fext_005fimport_005fbasic_005fconstraints"></a>Function: <em>int</em> <strong>gnutls_x509_ext_import_basic_constraints</strong> <em>(const gnutls_datum_t * <var>ext</var>, unsigned int * <var>ca</var>, int * <var>pathlen</var>)</em></dt>
<dd><p><var>ext</var>: the DER encoded extension data
</p>
<p><var>ca</var>: will be non zero if the CA status is true
</p>
<p><var>pathlen</var>: the path length constraint; will be set to -1 for no limit
</p>
<p>This function will return the CA status and path length constraint
as written in the PKIX extension 2.5.29.19.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fext_005fimport_005fcrl_005fdist_005fpoints-1"></a>
<h4 class="subheading">gnutls_x509_ext_import_crl_dist_points</h4>
<a name="gnutls_005fx509_005fext_005fimport_005fcrl_005fdist_005fpoints"></a><dl>
<dt><a name="index-gnutls_005fx509_005fext_005fimport_005fcrl_005fdist_005fpoints"></a>Function: <em>int</em> <strong>gnutls_x509_ext_import_crl_dist_points</strong> <em>(const gnutls_datum_t * <var>ext</var>, gnutls_x509_crl_dist_points_t <var>cdp</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>ext</var>: the DER encoded extension data
</p>
<p><var>cdp</var>: A pointer to an initialized CRL distribution points.
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function will extract the CRL distribution points extension (2.5.29.31) 
and store it into the provided type.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fext_005fimport_005fkey_005fpurposes-1"></a>
<h4 class="subheading">gnutls_x509_ext_import_key_purposes</h4>
<a name="gnutls_005fx509_005fext_005fimport_005fkey_005fpurposes"></a><dl>
<dt><a name="index-gnutls_005fx509_005fext_005fimport_005fkey_005fpurposes"></a>Function: <em>int</em> <strong>gnutls_x509_ext_import_key_purposes</strong> <em>(const gnutls_datum_t * <var>ext</var>, gnutls_x509_key_purposes_t <var>p</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>ext</var>: The DER-encoded extension data
</p>
<p><var>p</var>: The key purposes
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function will extract the key purposes in the provided DER-encoded
ExtKeyUsageSyntax PKIX extension, to a <code>gnutls_x509_key_purposes_t</code>  type. 
The data must be initialized.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fext_005fimport_005fkey_005fusage-1"></a>
<h4 class="subheading">gnutls_x509_ext_import_key_usage</h4>
<a name="gnutls_005fx509_005fext_005fimport_005fkey_005fusage"></a><dl>
<dt><a name="index-gnutls_005fx509_005fext_005fimport_005fkey_005fusage"></a>Function: <em>int</em> <strong>gnutls_x509_ext_import_key_usage</strong> <em>(const gnutls_datum_t * <var>ext</var>, unsigned int * <var>key_usage</var>)</em></dt>
<dd><p><var>ext</var>: the DER encoded extension data
</p>
<p><var>key_usage</var>: where the key usage bits will be stored
</p>
<p>This function will return certificate&rsquo;s key usage, by reading the DER
data of the keyUsage X.509 extension (2.5.29.15). The key usage value will ORed
values of the: <code>GNUTLS_KEY_DIGITAL_SIGNATURE</code> ,
<code>GNUTLS_KEY_NON_REPUDIATION</code> , <code>GNUTLS_KEY_KEY_ENCIPHERMENT</code> ,
<code>GNUTLS_KEY_DATA_ENCIPHERMENT</code> , <code>GNUTLS_KEY_KEY_AGREEMENT</code> ,
<code>GNUTLS_KEY_KEY_CERT_SIGN</code> , <code>GNUTLS_KEY_CRL_SIGN</code> ,
<code>GNUTLS_KEY_ENCIPHER_ONLY</code> , <code>GNUTLS_KEY_DECIPHER_ONLY</code> .
</p>
<p><strong>Returns:</strong> the certificate key usage, or a negative error code in case of
parsing error.  If the certificate does not contain the keyUsage
extension <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  will be
returned.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fext_005fimport_005fname_005fconstraints-1"></a>
<h4 class="subheading">gnutls_x509_ext_import_name_constraints</h4>
<a name="gnutls_005fx509_005fext_005fimport_005fname_005fconstraints"></a><dl>
<dt><a name="index-gnutls_005fx509_005fext_005fimport_005fname_005fconstraints"></a>Function: <em>int</em> <strong>gnutls_x509_ext_import_name_constraints</strong> <em>(const gnutls_datum_t * <var>ext</var>, gnutls_x509_name_constraints_t <var>nc</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>ext</var>: a DER encoded extension
</p>
<p><var>nc</var>: The nameconstraints
</p>
<p><var>flags</var>: zero or <code>GNUTLS_NAME_CONSTRAINTS_FLAG_APPEND</code> 
</p>
<p>This function will return an intermediate type containing
the name constraints of the provided NameConstraints extension. That
can be used in combination with <code>gnutls_x509_name_constraints_check()</code> 
to verify whether a server&rsquo;s name is in accordance with the constraints.
</p>
<p>When the  <code>flags</code> is set to <code>GNUTLS_NAME_CONSTRAINTS_FLAG_APPEND</code> , then if 
the  <code>nc</code> type is empty this function will behave identically as if the flag was not set.
Otherwise if there are elements in the  <code>nc</code> structure then the
constraints will be merged with the existing constraints following
RFC5280 p6.1.4 (excluded constraints will be appended, permitted
will be intersected).
</p>
<p>Note that  <code>nc</code> must be initialized prior to calling this function.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
if the extension is not present, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fext_005fimport_005fpolicies-1"></a>
<h4 class="subheading">gnutls_x509_ext_import_policies</h4>
<a name="gnutls_005fx509_005fext_005fimport_005fpolicies"></a><dl>
<dt><a name="index-gnutls_005fx509_005fext_005fimport_005fpolicies"></a>Function: <em>int</em> <strong>gnutls_x509_ext_import_policies</strong> <em>(const gnutls_datum_t * <var>ext</var>, gnutls_x509_policies_t <var>policies</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>ext</var>: the DER encoded extension data
</p>
<p><var>policies</var>: A pointer to an initialized policies.
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function will extract the certificate policy extension (2.5.29.32) 
and store it the provided policies.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fext_005fimport_005fprivate_005fkey_005fusage_005fperiod-1"></a>
<h4 class="subheading">gnutls_x509_ext_import_private_key_usage_period</h4>
<a name="gnutls_005fx509_005fext_005fimport_005fprivate_005fkey_005fusage_005fperiod"></a><dl>
<dt><a name="index-gnutls_005fx509_005fext_005fimport_005fprivate_005fkey_005fusage_005fperiod"></a>Function: <em>int</em> <strong>gnutls_x509_ext_import_private_key_usage_period</strong> <em>(const gnutls_datum_t * <var>ext</var>, time_t * <var>activation</var>, time_t * <var>expiration</var>)</em></dt>
<dd><p><var>ext</var>: the DER encoded extension data
</p>
<p><var>activation</var>: Will hold the activation time
</p>
<p><var>expiration</var>: Will hold the expiration time
</p>
<p>This function will return the expiration and activation
times of the private key as written in the
PKIX extension 2.5.29.16.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fext_005fimport_005fproxy-1"></a>
<h4 class="subheading">gnutls_x509_ext_import_proxy</h4>
<a name="gnutls_005fx509_005fext_005fimport_005fproxy"></a><dl>
<dt><a name="index-gnutls_005fx509_005fext_005fimport_005fproxy"></a>Function: <em>int</em> <strong>gnutls_x509_ext_import_proxy</strong> <em>(const gnutls_datum_t * <var>ext</var>, int * <var>pathlen</var>, char ** <var>policyLanguage</var>, char ** <var>policy</var>, size_t * <var>sizeof_policy</var>)</em></dt>
<dd><p><var>ext</var>: the DER encoded extension data
</p>
<p><var>pathlen</var>: pointer to output integer indicating path length (may be
NULL), non-negative error codes indicate a present pCPathLenConstraint
field and the actual value, -1 indicate that the field is absent.
</p>
<p><var>policyLanguage</var>: output variable with OID of policy language
</p>
<p><var>policy</var>: output variable with policy data
</p>
<p><var>sizeof_policy</var>: output variable size of policy data
</p>
<p>This function will return the information from a proxy certificate
extension. It reads the ProxyCertInfo X.509 extension (1.3.6.1.5.5.7.1.14).
The  <code>policyLanguage</code> and  <code>policy</code> values must be deinitialized using <code>gnutls_free()</code>  after use.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fext_005fimport_005fsubject_005falt_005fnames-1"></a>
<h4 class="subheading">gnutls_x509_ext_import_subject_alt_names</h4>
<a name="gnutls_005fx509_005fext_005fimport_005fsubject_005falt_005fnames"></a><dl>
<dt><a name="index-gnutls_005fx509_005fext_005fimport_005fsubject_005falt_005fnames"></a>Function: <em>int</em> <strong>gnutls_x509_ext_import_subject_alt_names</strong> <em>(const gnutls_datum_t * <var>ext</var>, gnutls_subject_alt_names_t <var>sans</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>ext</var>: The DER-encoded extension data
</p>
<p><var>sans</var>: The alternative names
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function will export the alternative names in the provided DER-encoded
SubjectAltName PKIX extension, to a <code>gnutls_subject_alt_names_t</code>  type.  <code>sans</code> must be initialized.
</p>
<p>This function will succeed even if there no subject alternative names
in the structure.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fext_005fimport_005fsubject_005fkey_005fid-1"></a>
<h4 class="subheading">gnutls_x509_ext_import_subject_key_id</h4>
<a name="gnutls_005fx509_005fext_005fimport_005fsubject_005fkey_005fid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fext_005fimport_005fsubject_005fkey_005fid"></a>Function: <em>int</em> <strong>gnutls_x509_ext_import_subject_key_id</strong> <em>(const gnutls_datum_t * <var>ext</var>, gnutls_datum_t * <var>id</var>)</em></dt>
<dd><p><var>ext</var>: a DER encoded extension
</p>
<p><var>id</var>: will contain the subject key ID
</p>
<p>This function will return the subject key ID stored in the provided
SubjectKeyIdentifier extension. The ID will be allocated using
<code>gnutls_malloc()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
if the extension is not present, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fext_005fimport_005ftlsfeatures-1"></a>
<h4 class="subheading">gnutls_x509_ext_import_tlsfeatures</h4>
<a name="gnutls_005fx509_005fext_005fimport_005ftlsfeatures"></a><dl>
<dt><a name="index-gnutls_005fx509_005fext_005fimport_005ftlsfeatures"></a>Function: <em>int</em> <strong>gnutls_x509_ext_import_tlsfeatures</strong> <em>(const gnutls_datum_t * <var>ext</var>, gnutls_x509_tlsfeatures_t <var>f</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>ext</var>: The DER-encoded extension data
</p>
<p><var>f</var>: The features structure
</p>
<p><var>flags</var>: zero or <code>GNUTLS_EXT_FLAG_APPEND</code> 
</p>
<p>This function will export the features in the provided DER-encoded
TLS Features PKIX extension, to a <code>gnutls_x509_tlsfeatures_t</code>  type.  <code>f</code> must be initialized.
</p>
<p>When the  <code>flags</code> is set to <code>GNUTLS_EXT_FLAG_APPEND</code> ,
then if the  <code>features</code> structure is empty this function will behave
identically as if the flag was not set. Otherwise if there are elements 
in the  <code>features</code> structure then they will be merged with.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.5.1
</p></dd></dl>

<a name="gnutls_005fx509_005fext_005fprint-1"></a>
<h4 class="subheading">gnutls_x509_ext_print</h4>
<a name="gnutls_005fx509_005fext_005fprint"></a><dl>
<dt><a name="index-gnutls_005fx509_005fext_005fprint"></a>Function: <em>int</em> <strong>gnutls_x509_ext_print</strong> <em>(gnutls_x509_ext_st * <var>exts</var>, unsigned int <var>exts_size</var>, gnutls_certificate_print_formats_t <var>format</var>, gnutls_datum_t * <var>out</var>)</em></dt>
<dd><p><var>exts</var>: The data to be printed
</p>
<p><var>exts_size</var>: the number of available structures
</p>
<p><var>format</var>: Indicate the format to use
</p>
<p><var>out</var>: Newly allocated datum with null terminated string.
</p>
<p>This function will pretty print X.509 certificate extensions, 
suitable for display to a human.
</p>
<p>The output  <code>out</code> needs to be deallocated using <code>gnutls_free()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fkey_005fpurpose_005fdeinit-1"></a>
<h4 class="subheading">gnutls_x509_key_purpose_deinit</h4>
<a name="gnutls_005fx509_005fkey_005fpurpose_005fdeinit"></a><dl>
<dt><a name="index-gnutls_005fx509_005fkey_005fpurpose_005fdeinit"></a>Function: <em>void</em> <strong>gnutls_x509_key_purpose_deinit</strong> <em>(gnutls_x509_key_purposes_t <var>p</var>)</em></dt>
<dd><p><var>p</var>: The key purposes
</p>
<p>This function will deinitialize a key purposes type.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fkey_005fpurpose_005fget-1"></a>
<h4 class="subheading">gnutls_x509_key_purpose_get</h4>
<a name="gnutls_005fx509_005fkey_005fpurpose_005fget"></a><dl>
<dt><a name="index-gnutls_005fx509_005fkey_005fpurpose_005fget"></a>Function: <em>int</em> <strong>gnutls_x509_key_purpose_get</strong> <em>(gnutls_x509_key_purposes_t <var>p</var>, unsigned <var>idx</var>, gnutls_datum_t * <var>oid</var>)</em></dt>
<dd><p><var>p</var>: The key purposes
</p>
<p><var>idx</var>: The index of the key purpose to retrieve
</p>
<p><var>oid</var>: Will hold the object identifier of the key purpose (to be treated as constant)
</p>
<p>This function will retrieve the specified by the index key purpose in the
purposes type. The object identifier will be a null terminated string.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
if the index is out of bounds, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fkey_005fpurpose_005finit-1"></a>
<h4 class="subheading">gnutls_x509_key_purpose_init</h4>
<a name="gnutls_005fx509_005fkey_005fpurpose_005finit"></a><dl>
<dt><a name="index-gnutls_005fx509_005fkey_005fpurpose_005finit"></a>Function: <em>int</em> <strong>gnutls_x509_key_purpose_init</strong> <em>(gnutls_x509_key_purposes_t * <var>p</var>)</em></dt>
<dd><p><var>p</var>: The key purposes
</p>
<p>This function will initialize an alternative names type.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fkey_005fpurpose_005fset-1"></a>
<h4 class="subheading">gnutls_x509_key_purpose_set</h4>
<a name="gnutls_005fx509_005fkey_005fpurpose_005fset"></a><dl>
<dt><a name="index-gnutls_005fx509_005fkey_005fpurpose_005fset"></a>Function: <em>int</em> <strong>gnutls_x509_key_purpose_set</strong> <em>(gnutls_x509_key_purposes_t <var>p</var>, const char * <var>oid</var>)</em></dt>
<dd><p><var>p</var>: The key purposes
</p>
<p><var>oid</var>: The object identifier of the key purpose
</p>
<p>This function will store the specified key purpose in the
purposes.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0), otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fname_005fconstraints_005fadd_005fexcluded-1"></a>
<h4 class="subheading">gnutls_x509_name_constraints_add_excluded</h4>
<a name="gnutls_005fx509_005fname_005fconstraints_005fadd_005fexcluded"></a><dl>
<dt><a name="index-gnutls_005fx509_005fname_005fconstraints_005fadd_005fexcluded"></a>Function: <em>int</em> <strong>gnutls_x509_name_constraints_add_excluded</strong> <em>(gnutls_x509_name_constraints_t <var>nc</var>, gnutls_x509_subject_alt_name_t <var>type</var>, const gnutls_datum_t * <var>name</var>)</em></dt>
<dd><p><var>nc</var>: The nameconstraints
</p>
<p><var>type</var>: The type of the constraints
</p>
<p><var>name</var>: The data of the constraints
</p>
<p>This function will add a name constraint to the list of excluded
constraints. The constraints  <code>type</code> can be any of the following types:
<code>GNUTLS_SAN_DNSNAME</code> , <code>GNUTLS_SAN_RFC822NAME</code> , <code>GNUTLS_SAN_DN</code> ,
<code>GNUTLS_SAN_URI</code> , <code>GNUTLS_SAN_IPADDRESS</code> . For the latter, an IP address
in network byte order is expected, followed by its network mask (which is
4 bytes in IPv4 or 16-bytes in IPv6).
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fname_005fconstraints_005fadd_005fpermitted-1"></a>
<h4 class="subheading">gnutls_x509_name_constraints_add_permitted</h4>
<a name="gnutls_005fx509_005fname_005fconstraints_005fadd_005fpermitted"></a><dl>
<dt><a name="index-gnutls_005fx509_005fname_005fconstraints_005fadd_005fpermitted"></a>Function: <em>int</em> <strong>gnutls_x509_name_constraints_add_permitted</strong> <em>(gnutls_x509_name_constraints_t <var>nc</var>, gnutls_x509_subject_alt_name_t <var>type</var>, const gnutls_datum_t * <var>name</var>)</em></dt>
<dd><p><var>nc</var>: The nameconstraints
</p>
<p><var>type</var>: The type of the constraints
</p>
<p><var>name</var>: The data of the constraints
</p>
<p>This function will add a name constraint to the list of permitted
constraints. The constraints  <code>type</code> can be any of the following types:
<code>GNUTLS_SAN_DNSNAME</code> , <code>GNUTLS_SAN_RFC822NAME</code> , <code>GNUTLS_SAN_DN</code> ,
<code>GNUTLS_SAN_URI</code> , <code>GNUTLS_SAN_IPADDRESS</code> . For the latter, an IP address
in network byte order is expected, followed by its network mask.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fname_005fconstraints_005fcheck-1"></a>
<h4 class="subheading">gnutls_x509_name_constraints_check</h4>
<a name="gnutls_005fx509_005fname_005fconstraints_005fcheck"></a><dl>
<dt><a name="index-gnutls_005fx509_005fname_005fconstraints_005fcheck"></a>Function: <em>unsigned</em> <strong>gnutls_x509_name_constraints_check</strong> <em>(gnutls_x509_name_constraints_t <var>nc</var>, gnutls_x509_subject_alt_name_t <var>type</var>, const gnutls_datum_t * <var>name</var>)</em></dt>
<dd><p><var>nc</var>: the extracted name constraints
</p>
<p><var>type</var>: the type of the constraint to check (of type gnutls_x509_subject_alt_name_t)
</p>
<p><var>name</var>: the name to be checked
</p>
<p>This function will check the provided name against the constraints in
 <code>nc</code> using the RFC5280 rules. Currently this function is limited to DNS
names, emails and IP addresses (of type <code>GNUTLS_SAN_DNSNAME</code> ,
<code>GNUTLS_SAN_RFC822NAME</code>  and <code>GNUTLS_SAN_IPADDRESS</code> ).
</p>
<p><strong>Returns:</strong> zero if the provided name is not acceptable, and non-zero otherwise.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fname_005fconstraints_005fcheck_005fcrt-1"></a>
<h4 class="subheading">gnutls_x509_name_constraints_check_crt</h4>
<a name="gnutls_005fx509_005fname_005fconstraints_005fcheck_005fcrt"></a><dl>
<dt><a name="index-gnutls_005fx509_005fname_005fconstraints_005fcheck_005fcrt"></a>Function: <em>unsigned</em> <strong>gnutls_x509_name_constraints_check_crt</strong> <em>(gnutls_x509_name_constraints_t <var>nc</var>, gnutls_x509_subject_alt_name_t <var>type</var>, gnutls_x509_crt_t <var>cert</var>)</em></dt>
<dd><p><var>nc</var>: the extracted name constraints
</p>
<p><var>type</var>: the type of the constraint to check (of type gnutls_x509_subject_alt_name_t)
</p>
<p><var>cert</var>: the certificate to be checked
</p>
<p>This function will check the provided certificate names against the constraints in
 <code>nc</code> using the RFC5280 rules. It will traverse all the certificate&rsquo;s names and
alternative names.
</p>
<p>Currently this function is limited to DNS
names and emails (of type <code>GNUTLS_SAN_DNSNAME</code>  and <code>GNUTLS_SAN_RFC822NAME</code> ).
</p>
<p><strong>Returns:</strong> zero if the provided name is not acceptable, and non-zero otherwise.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fname_005fconstraints_005fdeinit-1"></a>
<h4 class="subheading">gnutls_x509_name_constraints_deinit</h4>
<a name="gnutls_005fx509_005fname_005fconstraints_005fdeinit"></a><dl>
<dt><a name="index-gnutls_005fx509_005fname_005fconstraints_005fdeinit"></a>Function: <em>void</em> <strong>gnutls_x509_name_constraints_deinit</strong> <em>(gnutls_x509_name_constraints_t <var>nc</var>)</em></dt>
<dd><p><var>nc</var>: The nameconstraints
</p>
<p>This function will deinitialize a name constraints type.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fname_005fconstraints_005fget_005fexcluded-1"></a>
<h4 class="subheading">gnutls_x509_name_constraints_get_excluded</h4>
<a name="gnutls_005fx509_005fname_005fconstraints_005fget_005fexcluded"></a><dl>
<dt><a name="index-gnutls_005fx509_005fname_005fconstraints_005fget_005fexcluded"></a>Function: <em>int</em> <strong>gnutls_x509_name_constraints_get_excluded</strong> <em>(gnutls_x509_name_constraints_t <var>nc</var>, unsigned <var>idx</var>, unsigned * <var>type</var>, gnutls_datum_t * <var>name</var>)</em></dt>
<dd><p><var>nc</var>: the extracted name constraints
</p>
<p><var>idx</var>: the index of the constraint
</p>
<p><var>type</var>: the type of the constraint (of type gnutls_x509_subject_alt_name_t)
</p>
<p><var>name</var>: the name in the constraint (of the specific type)
</p>
<p>This function will return an intermediate type containing
the name constraints of the provided CA certificate. That
structure can be used in combination with <code>gnutls_x509_name_constraints_check()</code> 
to verify whether a server&rsquo;s name is in accordance with the constraints.
</p>
<p>The name should be treated as constant and valid for the lifetime of  <code>nc</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
if the extension is not present, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fname_005fconstraints_005fget_005fpermitted-1"></a>
<h4 class="subheading">gnutls_x509_name_constraints_get_permitted</h4>
<a name="gnutls_005fx509_005fname_005fconstraints_005fget_005fpermitted"></a><dl>
<dt><a name="index-gnutls_005fx509_005fname_005fconstraints_005fget_005fpermitted"></a>Function: <em>int</em> <strong>gnutls_x509_name_constraints_get_permitted</strong> <em>(gnutls_x509_name_constraints_t <var>nc</var>, unsigned <var>idx</var>, unsigned * <var>type</var>, gnutls_datum_t * <var>name</var>)</em></dt>
<dd><p><var>nc</var>: the extracted name constraints
</p>
<p><var>idx</var>: the index of the constraint
</p>
<p><var>type</var>: the type of the constraint (of type gnutls_x509_subject_alt_name_t)
</p>
<p><var>name</var>: the name in the constraint (of the specific type)
</p>
<p>This function will return an intermediate type containing
the name constraints of the provided CA certificate. That
structure can be used in combination with <code>gnutls_x509_name_constraints_check()</code> 
to verify whether a server&rsquo;s name is in accordance with the constraints.
</p>
<p>The name should be treated as constant and valid for the lifetime of  <code>nc</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
if the extension is not present, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fname_005fconstraints_005finit-1"></a>
<h4 class="subheading">gnutls_x509_name_constraints_init</h4>
<a name="gnutls_005fx509_005fname_005fconstraints_005finit"></a><dl>
<dt><a name="index-gnutls_005fx509_005fname_005fconstraints_005finit"></a>Function: <em>int</em> <strong>gnutls_x509_name_constraints_init</strong> <em>(gnutls_x509_name_constraints_t * <var>nc</var>)</em></dt>
<dd><p><var>nc</var>: The nameconstraints
</p>
<p>This function will initialize a name constraints type.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fothername_005fto_005fvirtual-1"></a>
<h4 class="subheading">gnutls_x509_othername_to_virtual</h4>
<a name="gnutls_005fx509_005fothername_005fto_005fvirtual"></a><dl>
<dt><a name="index-gnutls_005fx509_005fothername_005fto_005fvirtual"></a>Function: <em>int</em> <strong>gnutls_x509_othername_to_virtual</strong> <em>(const char * <var>oid</var>, const gnutls_datum_t * <var>othername</var>, unsigned int * <var>virt_type</var>, gnutls_datum_t * <var>virt</var>)</em></dt>
<dd><p><var>oid</var>: The othername object identifier
</p>
<p><var>othername</var>: The othername data
</p>
<p><var>virt_type</var>: GNUTLS_SAN_OTHERNAME_XXX
</p>
<p><var>virt</var>: allocated printable data
</p>
<p>This function will parse and convert the othername data to a virtual
type supported by gnutls.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.8
</p></dd></dl>

<a name="gnutls_005fx509_005fpolicies_005fdeinit-1"></a>
<h4 class="subheading">gnutls_x509_policies_deinit</h4>
<a name="gnutls_005fx509_005fpolicies_005fdeinit"></a><dl>
<dt><a name="index-gnutls_005fx509_005fpolicies_005fdeinit"></a>Function: <em>void</em> <strong>gnutls_x509_policies_deinit</strong> <em>(gnutls_x509_policies_t <var>policies</var>)</em></dt>
<dd><p><var>policies</var>: The authority key identifier
</p>
<p>This function will deinitialize an authority key identifier type.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fpolicies_005fget-1"></a>
<h4 class="subheading">gnutls_x509_policies_get</h4>
<a name="gnutls_005fx509_005fpolicies_005fget"></a><dl>
<dt><a name="index-gnutls_005fx509_005fpolicies_005fget"></a>Function: <em>int</em> <strong>gnutls_x509_policies_get</strong> <em>(gnutls_x509_policies_t <var>policies</var>, unsigned int <var>seq</var>, struct gnutls_x509_policy_st * <var>policy</var>)</em></dt>
<dd><p><var>policies</var>: The policies
</p>
<p><var>seq</var>: The index of the name to get
</p>
<p><var>policy</var>: Will hold the policy
</p>
<p>This function will return a specific policy as stored in
the  <code>policies</code> type. The returned values should be treated as constant
and valid for the lifetime of  <code>policies</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
if the index is out of bounds, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fpolicies_005finit-1"></a>
<h4 class="subheading">gnutls_x509_policies_init</h4>
<a name="gnutls_005fx509_005fpolicies_005finit"></a><dl>
<dt><a name="index-gnutls_005fx509_005fpolicies_005finit"></a>Function: <em>int</em> <strong>gnutls_x509_policies_init</strong> <em>(gnutls_x509_policies_t * <var>policies</var>)</em></dt>
<dd><p><var>policies</var>: The authority key ID
</p>
<p>This function will initialize an authority key ID type.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fpolicies_005fset-1"></a>
<h4 class="subheading">gnutls_x509_policies_set</h4>
<a name="gnutls_005fx509_005fpolicies_005fset"></a><dl>
<dt><a name="index-gnutls_005fx509_005fpolicies_005fset"></a>Function: <em>int</em> <strong>gnutls_x509_policies_set</strong> <em>(gnutls_x509_policies_t <var>policies</var>, const struct gnutls_x509_policy_st * <var>policy</var>)</em></dt>
<dd><p><var>policies</var>: An initialized policies
</p>
<p><var>policy</var>: Contains the policy to set
</p>
<p>This function will store the specified policy in
the provided  <code>policies</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0), otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fpolicy_005frelease-1"></a>
<h4 class="subheading">gnutls_x509_policy_release</h4>
<a name="gnutls_005fx509_005fpolicy_005frelease"></a><dl>
<dt><a name="index-gnutls_005fx509_005fpolicy_005frelease"></a>Function: <em>void</em> <strong>gnutls_x509_policy_release</strong> <em>(struct gnutls_x509_policy_st * <var>policy</var>)</em></dt>
<dd><p><var>policy</var>: a certificate policy
</p>
<p>This function will deinitialize all memory associated with the provided
 <code>policy</code> . The policy is allocated using <code>gnutls_x509_crt_get_policy()</code> .
</p>
<p><strong>Since:</strong> 3.1.5
</p></dd></dl>

<a name="gnutls_005fx509_005fprivkey_005fcpy-1"></a>
<h4 class="subheading">gnutls_x509_privkey_cpy</h4>
<a name="gnutls_005fx509_005fprivkey_005fcpy"></a><dl>
<dt><a name="index-gnutls_005fx509_005fprivkey_005fcpy"></a>Function: <em>int</em> <strong>gnutls_x509_privkey_cpy</strong> <em>(gnutls_x509_privkey_t <var>dst</var>, gnutls_x509_privkey_t <var>src</var>)</em></dt>
<dd><p><var>dst</var>: The destination key, which should be initialized.
</p>
<p><var>src</var>: The source key
</p>
<p>This function will copy a private key from source to destination
key. Destination has to be initialized.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fprivkey_005fdeinit-1"></a>
<h4 class="subheading">gnutls_x509_privkey_deinit</h4>
<a name="gnutls_005fx509_005fprivkey_005fdeinit"></a><dl>
<dt><a name="index-gnutls_005fx509_005fprivkey_005fdeinit"></a>Function: <em>void</em> <strong>gnutls_x509_privkey_deinit</strong> <em>(gnutls_x509_privkey_t <var>key</var>)</em></dt>
<dd><p><var>key</var>: The key to be deinitialized
</p>
<p>This function will deinitialize a private key structure.
</p></dd></dl>

<a name="gnutls_005fx509_005fprivkey_005fexport-1"></a>
<h4 class="subheading">gnutls_x509_privkey_export</h4>
<a name="gnutls_005fx509_005fprivkey_005fexport"></a><dl>
<dt><a name="index-gnutls_005fx509_005fprivkey_005fexport"></a>Function: <em>int</em> <strong>gnutls_x509_privkey_export</strong> <em>(gnutls_x509_privkey_t <var>key</var>, gnutls_x509_crt_fmt_t <var>format</var>, void * <var>output_data</var>, size_t * <var>output_data_size</var>)</em></dt>
<dd><p><var>key</var>: Holds the key
</p>
<p><var>format</var>: the format of output params. One of PEM or DER.
</p>
<p><var>output_data</var>: will contain a private key PEM or DER encoded
</p>
<p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)
</p>
<p>This function will export the private key to a PKCS1 structure for
RSA keys, or an integer sequence for DSA keys.  The DSA keys are in
the same format with the parameters used by openssl.
</p>
<p>If the buffer provided is not long enough to hold the output, then
* <code>output_data_size</code> is updated and <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> 
will be returned.
</p>
<p>If the structure is PEM encoded, it will have a header
of &quot;BEGIN RSA PRIVATE KEY&quot;.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fprivkey_005fexport2-1"></a>
<h4 class="subheading">gnutls_x509_privkey_export2</h4>
<a name="gnutls_005fx509_005fprivkey_005fexport2"></a><dl>
<dt><a name="index-gnutls_005fx509_005fprivkey_005fexport2"></a>Function: <em>int</em> <strong>gnutls_x509_privkey_export2</strong> <em>(gnutls_x509_privkey_t <var>key</var>, gnutls_x509_crt_fmt_t <var>format</var>, gnutls_datum_t * <var>out</var>)</em></dt>
<dd><p><var>key</var>: Holds the key
</p>
<p><var>format</var>: the format of output params. One of PEM or DER.
</p>
<p><var>out</var>: will contain a private key PEM or DER encoded
</p>
<p>This function will export the private key to a PKCS1 structure for
RSA keys, or an integer sequence for DSA keys.  The DSA keys are in
the same format with the parameters used by openssl.
</p>
<p>The output buffer is allocated using <code>gnutls_malloc()</code> .
</p>
<p>If the structure is PEM encoded, it will have a header
of &quot;BEGIN RSA PRIVATE KEY&quot;.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p>Since 3.1.3
</p></dd></dl>

<a name="gnutls_005fx509_005fprivkey_005fexport2_005fpkcs8-1"></a>
<h4 class="subheading">gnutls_x509_privkey_export2_pkcs8</h4>
<a name="gnutls_005fx509_005fprivkey_005fexport2_005fpkcs8"></a><dl>
<dt><a name="index-gnutls_005fx509_005fprivkey_005fexport2_005fpkcs8"></a>Function: <em>int</em> <strong>gnutls_x509_privkey_export2_pkcs8</strong> <em>(gnutls_x509_privkey_t <var>key</var>, gnutls_x509_crt_fmt_t <var>format</var>, const char * <var>password</var>, unsigned int <var>flags</var>, gnutls_datum_t * <var>out</var>)</em></dt>
<dd><p><var>key</var>: Holds the key
</p>
<p><var>format</var>: the format of output params. One of PEM or DER.
</p>
<p><var>password</var>: the password that will be used to encrypt the key.
</p>
<p><var>flags</var>: an ORed sequence of gnutls_pkcs_encrypt_flags_t
</p>
<p><var>out</var>: will contain a private key PEM or DER encoded
</p>
<p>This function will export the private key to a PKCS8 structure.
Both RSA and DSA keys can be exported. For DSA keys we use
PKCS <code>11</code>  definitions. If the flags do not specify the encryption
cipher, then the default 3DES (PBES2) will be used.
</p>
<p>The  <code>password</code> can be either ASCII or UTF-8 in the default PBES2
encryption schemas, or ASCII for the PKCS12 schemas.
</p>
<p>The output buffer is allocated using <code>gnutls_malloc()</code> .
</p>
<p>If the structure is PEM encoded, it will have a header
of &quot;BEGIN ENCRYPTED PRIVATE KEY&quot; or &quot;BEGIN PRIVATE KEY&quot; if
encryption is not used.
</p>
<p><strong>Returns:</strong> In case of failure a negative error code will be
returned, and 0 on success.
</p>
<p>Since 3.1.3
</p></dd></dl>

<a name="gnutls_005fx509_005fprivkey_005fexport_005fdsa_005fraw-1"></a>
<h4 class="subheading">gnutls_x509_privkey_export_dsa_raw</h4>
<a name="gnutls_005fx509_005fprivkey_005fexport_005fdsa_005fraw"></a><dl>
<dt><a name="index-gnutls_005fx509_005fprivkey_005fexport_005fdsa_005fraw"></a>Function: <em>int</em> <strong>gnutls_x509_privkey_export_dsa_raw</strong> <em>(gnutls_x509_privkey_t <var>key</var>, gnutls_datum_t * <var>p</var>, gnutls_datum_t * <var>q</var>, gnutls_datum_t * <var>g</var>, gnutls_datum_t * <var>y</var>, gnutls_datum_t * <var>x</var>)</em></dt>
<dd><p><var>key</var>: a key
</p>
<p><var>p</var>: will hold the p
</p>
<p><var>q</var>: will hold the q
</p>
<p><var>g</var>: will hold the g
</p>
<p><var>y</var>: will hold the y
</p>
<p><var>x</var>: will hold the x
</p>
<p>This function will export the DSA private key&rsquo;s parameters found
in the given structure. The new parameters will be allocated using
<code>gnutls_malloc()</code>  and will be stored in the appropriate datum.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fprivkey_005fexport_005fecc_005fraw-1"></a>
<h4 class="subheading">gnutls_x509_privkey_export_ecc_raw</h4>
<a name="gnutls_005fx509_005fprivkey_005fexport_005fecc_005fraw"></a><dl>
<dt><a name="index-gnutls_005fx509_005fprivkey_005fexport_005fecc_005fraw"></a>Function: <em>int</em> <strong>gnutls_x509_privkey_export_ecc_raw</strong> <em>(gnutls_x509_privkey_t <var>key</var>, gnutls_ecc_curve_t * <var>curve</var>, gnutls_datum_t * <var>x</var>, gnutls_datum_t * <var>y</var>, gnutls_datum_t * <var>k</var>)</em></dt>
<dd><p><var>key</var>: a key
</p>
<p><var>curve</var>: will hold the curve
</p>
<p><var>x</var>: will hold the x coordinate
</p>
<p><var>y</var>: will hold the y coordinate
</p>
<p><var>k</var>: will hold the private key
</p>
<p>This function will export the ECC private key&rsquo;s parameters found
in the given structure. The new parameters will be allocated using
<code>gnutls_malloc()</code>  and will be stored in the appropriate datum.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fprivkey_005fexport_005fpkcs8-1"></a>
<h4 class="subheading">gnutls_x509_privkey_export_pkcs8</h4>
<a name="gnutls_005fx509_005fprivkey_005fexport_005fpkcs8"></a><dl>
<dt><a name="index-gnutls_005fx509_005fprivkey_005fexport_005fpkcs8"></a>Function: <em>int</em> <strong>gnutls_x509_privkey_export_pkcs8</strong> <em>(gnutls_x509_privkey_t <var>key</var>, gnutls_x509_crt_fmt_t <var>format</var>, const char * <var>password</var>, unsigned int <var>flags</var>, void * <var>output_data</var>, size_t * <var>output_data_size</var>)</em></dt>
<dd><p><var>key</var>: Holds the key
</p>
<p><var>format</var>: the format of output params. One of PEM or DER.
</p>
<p><var>password</var>: the password that will be used to encrypt the key.
</p>
<p><var>flags</var>: an ORed sequence of gnutls_pkcs_encrypt_flags_t
</p>
<p><var>output_data</var>: will contain a private key PEM or DER encoded
</p>
<p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)
</p>
<p>This function will export the private key to a PKCS8 structure.
Both RSA and DSA keys can be exported. For DSA keys we use
PKCS <code>11</code>  definitions. If the flags do not specify the encryption
cipher, then the default 3DES (PBES2) will be used.
</p>
<p>The  <code>password</code> can be either ASCII or UTF-8 in the default PBES2
encryption schemas, or ASCII for the PKCS12 schemas.
</p>
<p>If the buffer provided is not long enough to hold the output, then
*output_data_size is updated and GNUTLS_E_SHORT_MEMORY_BUFFER will
be returned.
</p>
<p>If the structure is PEM encoded, it will have a header
of &quot;BEGIN ENCRYPTED PRIVATE KEY&quot; or &quot;BEGIN PRIVATE KEY&quot; if
encryption is not used.
</p>
<p><strong>Returns:</strong> In case of failure a negative error code will be
returned, and 0 on success.
</p></dd></dl>

<a name="gnutls_005fx509_005fprivkey_005fexport_005frsa_005fraw-1"></a>
<h4 class="subheading">gnutls_x509_privkey_export_rsa_raw</h4>
<a name="gnutls_005fx509_005fprivkey_005fexport_005frsa_005fraw"></a><dl>
<dt><a name="index-gnutls_005fx509_005fprivkey_005fexport_005frsa_005fraw"></a>Function: <em>int</em> <strong>gnutls_x509_privkey_export_rsa_raw</strong> <em>(gnutls_x509_privkey_t <var>key</var>, gnutls_datum_t * <var>m</var>, gnutls_datum_t * <var>e</var>, gnutls_datum_t * <var>d</var>, gnutls_datum_t * <var>p</var>, gnutls_datum_t * <var>q</var>, gnutls_datum_t * <var>u</var>)</em></dt>
<dd><p><var>key</var>: a key
</p>
<p><var>m</var>: will hold the modulus
</p>
<p><var>e</var>: will hold the public exponent
</p>
<p><var>d</var>: will hold the private exponent
</p>
<p><var>p</var>: will hold the first prime (p)
</p>
<p><var>q</var>: will hold the second prime (q)
</p>
<p><var>u</var>: will hold the coefficient
</p>
<p>This function will export the RSA private key&rsquo;s parameters found
in the given structure. The new parameters will be allocated using
<code>gnutls_malloc()</code>  and will be stored in the appropriate datum.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fprivkey_005fexport_005frsa_005fraw2-1"></a>
<h4 class="subheading">gnutls_x509_privkey_export_rsa_raw2</h4>
<a name="gnutls_005fx509_005fprivkey_005fexport_005frsa_005fraw2"></a><dl>
<dt><a name="index-gnutls_005fx509_005fprivkey_005fexport_005frsa_005fraw2"></a>Function: <em>int</em> <strong>gnutls_x509_privkey_export_rsa_raw2</strong> <em>(gnutls_x509_privkey_t <var>key</var>, gnutls_datum_t * <var>m</var>, gnutls_datum_t * <var>e</var>, gnutls_datum_t * <var>d</var>, gnutls_datum_t * <var>p</var>, gnutls_datum_t * <var>q</var>, gnutls_datum_t * <var>u</var>, gnutls_datum_t * <var>e1</var>, gnutls_datum_t * <var>e2</var>)</em></dt>
<dd><p><var>key</var>: a key
</p>
<p><var>m</var>: will hold the modulus
</p>
<p><var>e</var>: will hold the public exponent
</p>
<p><var>d</var>: will hold the private exponent
</p>
<p><var>p</var>: will hold the first prime (p)
</p>
<p><var>q</var>: will hold the second prime (q)
</p>
<p><var>u</var>: will hold the coefficient
</p>
<p><var>e1</var>: will hold e1 = d mod (p-1)
</p>
<p><var>e2</var>: will hold e2 = d mod (q-1)
</p>
<p>This function will export the RSA private key&rsquo;s parameters found
in the given structure. The new parameters will be allocated using
<code>gnutls_malloc()</code>  and will be stored in the appropriate datum.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<a name="gnutls_005fx509_005fprivkey_005ffix-1"></a>
<h4 class="subheading">gnutls_x509_privkey_fix</h4>
<a name="gnutls_005fx509_005fprivkey_005ffix"></a><dl>
<dt><a name="index-gnutls_005fx509_005fprivkey_005ffix"></a>Function: <em>int</em> <strong>gnutls_x509_privkey_fix</strong> <em>(gnutls_x509_privkey_t <var>key</var>)</em></dt>
<dd><p><var>key</var>: a key
</p>
<p>This function will recalculate the secondary parameters in a key.
In RSA keys, this can be the coefficient and exponent1,2.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fprivkey_005fgenerate-1"></a>
<h4 class="subheading">gnutls_x509_privkey_generate</h4>
<a name="gnutls_005fx509_005fprivkey_005fgenerate"></a><dl>
<dt><a name="index-gnutls_005fx509_005fprivkey_005fgenerate"></a>Function: <em>int</em> <strong>gnutls_x509_privkey_generate</strong> <em>(gnutls_x509_privkey_t <var>key</var>, gnutls_pk_algorithm_t <var>algo</var>, unsigned int <var>bits</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>key</var>: an initialized key
</p>
<p><var>algo</var>: is one of the algorithms in <code>gnutls_pk_algorithm_t</code> .
</p>
<p><var>bits</var>: the size of the parameters to generate
</p>
<p><var>flags</var>: Must be zero or flags from <code>gnutls_privkey_flags_t</code> .
</p>
<p>This function will generate a random private key. Note that this
function must be called on an empty private key. The flag <code>GNUTLS_PRIVKEY_FLAG_PROVABLE</code> 
instructs the key generation process to use algorithms like Shawe-Taylor
which generate provable parameters out of a seed.
</p>
<p>Note that when generating an elliptic curve key, the curve
can be substituted in the place of the bits parameter using the
<code>GNUTLS_CURVE_TO_BITS()</code>  macro. The input to the macro is any curve from
<code>gnutls_ecc_curve_t</code> .
</p>
<p>For DSA keys, if the subgroup size needs to be specified check
the <code>GNUTLS_SUBGROUP_TO_BITS()</code>  macro.
</p>
<p>It is recommended to do not set the number of  <code>bits</code> directly, use <code>gnutls_sec_param_to_pk_bits()</code>  instead .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fprivkey_005fgenerate2-1"></a>
<h4 class="subheading">gnutls_x509_privkey_generate2</h4>
<a name="gnutls_005fx509_005fprivkey_005fgenerate2"></a><dl>
<dt><a name="index-gnutls_005fx509_005fprivkey_005fgenerate2"></a>Function: <em>int</em> <strong>gnutls_x509_privkey_generate2</strong> <em>(gnutls_x509_privkey_t <var>key</var>, gnutls_pk_algorithm_t <var>algo</var>, unsigned int <var>bits</var>, unsigned int <var>flags</var>, const gnutls_keygen_data_st * <var>data</var>, unsigned <var>data_size</var>)</em></dt>
<dd><p><var>key</var>: a key
</p>
<p><var>algo</var>: is one of the algorithms in <code>gnutls_pk_algorithm_t</code> .
</p>
<p><var>bits</var>: the size of the modulus
</p>
<p><var>flags</var>: Must be zero or flags from <code>gnutls_privkey_flags_t</code> .
</p>
<p><var>data</var>: Allow specifying <code>gnutls_keygen_data_st</code>  types such as the seed to be used.
</p>
<p><var>data_size</var>: The number of  <code>data</code> available.
</p>
<p>This function will generate a random private key. Note that this
function must be called on an empty private key. The flag <code>GNUTLS_PRIVKEY_FLAG_PROVABLE</code> 
instructs the key generation process to use algorithms which generate
provable parameters out of a seed.
</p>
<p>Note that when generating an elliptic curve key, the curve
can be substituted in the place of the bits parameter using the
<code>GNUTLS_CURVE_TO_BITS()</code>  macro.
</p>
<p>For DSA keys, if the subgroup size needs to be specified check
the <code>GNUTLS_SUBGROUP_TO_BITS()</code>  macro.
</p>
<p>Do not set the number of bits directly, use <code>gnutls_sec_param_to_pk_bits()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fprivkey_005fget_005fkey_005fid-1"></a>
<h4 class="subheading">gnutls_x509_privkey_get_key_id</h4>
<a name="gnutls_005fx509_005fprivkey_005fget_005fkey_005fid"></a><dl>
<dt><a name="index-gnutls_005fx509_005fprivkey_005fget_005fkey_005fid"></a>Function: <em>int</em> <strong>gnutls_x509_privkey_get_key_id</strong> <em>(gnutls_x509_privkey_t <var>key</var>, unsigned int <var>flags</var>, unsigned char * <var>output_data</var>, size_t * <var>output_data_size</var>)</em></dt>
<dd><p><var>key</var>: a key
</p>
<p><var>flags</var>: should be one of the flags from <code>gnutls_keyid_flags_t</code> 
</p>
<p><var>output_data</var>: will contain the key ID
</p>
<p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)
</p>
<p>This function will return a unique ID that depends on the public key
parameters. This ID can be used in checking whether a certificate
corresponds to the given key.
</p>
<p>If the buffer provided is not long enough to hold the output, then
* <code>output_data_size</code> is updated and <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  will
be returned.  The output will normally be a SHA-1 hash output,
which is 20 bytes.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fprivkey_005fget_005fpk_005falgorithm-1"></a>
<h4 class="subheading">gnutls_x509_privkey_get_pk_algorithm</h4>
<a name="gnutls_005fx509_005fprivkey_005fget_005fpk_005falgorithm"></a><dl>
<dt><a name="index-gnutls_005fx509_005fprivkey_005fget_005fpk_005falgorithm"></a>Function: <em>int</em> <strong>gnutls_x509_privkey_get_pk_algorithm</strong> <em>(gnutls_x509_privkey_t <var>key</var>)</em></dt>
<dd><p><var>key</var>: should contain a <code>gnutls_x509_privkey_t</code>  type
</p>
<p>This function will return the public key algorithm of a private
key.
</p>
<p><strong>Returns:</strong> a member of the <code>gnutls_pk_algorithm_t</code>  enumeration on
success, or a negative error code on error.
</p></dd></dl>

<a name="gnutls_005fx509_005fprivkey_005fget_005fpk_005falgorithm2-1"></a>
<h4 class="subheading">gnutls_x509_privkey_get_pk_algorithm2</h4>
<a name="gnutls_005fx509_005fprivkey_005fget_005fpk_005falgorithm2"></a><dl>
<dt><a name="index-gnutls_005fx509_005fprivkey_005fget_005fpk_005falgorithm2"></a>Function: <em>int</em> <strong>gnutls_x509_privkey_get_pk_algorithm2</strong> <em>(gnutls_x509_privkey_t <var>key</var>, unsigned int * <var>bits</var>)</em></dt>
<dd><p><var>key</var>: should contain a <code>gnutls_x509_privkey_t</code>  type
</p>
<p><var>bits</var>: The number of bits in the public key algorithm
</p>
<p>This function will return the public key algorithm of a private
key.
</p>
<p><strong>Returns:</strong> a member of the <code>gnutls_pk_algorithm_t</code>  enumeration on
success, or a negative error code on error.
</p></dd></dl>

<a name="gnutls_005fx509_005fprivkey_005fget_005fseed-1"></a>
<h4 class="subheading">gnutls_x509_privkey_get_seed</h4>
<a name="gnutls_005fx509_005fprivkey_005fget_005fseed"></a><dl>
<dt><a name="index-gnutls_005fx509_005fprivkey_005fget_005fseed"></a>Function: <em>int</em> <strong>gnutls_x509_privkey_get_seed</strong> <em>(gnutls_x509_privkey_t <var>key</var>, gnutls_digest_algorithm_t * <var>digest</var>, void * <var>seed</var>, size_t * <var>seed_size</var>)</em></dt>
<dd><p><var>key</var>: should contain a <code>gnutls_x509_privkey_t</code>  type
</p>
<p><var>digest</var>: if non-NULL it will contain the digest algorithm used for key generation (if applicable)
</p>
<p><var>seed</var>: where seed will be copied to
</p>
<p><var>seed_size</var>: originally holds the size of  <code>seed</code> , will be updated with actual size
</p>
<p>This function will return the seed that was used to generate the
given private key. That function will succeed only if the key was generated
as a provable key.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<a name="gnutls_005fx509_005fprivkey_005fimport-1"></a>
<h4 class="subheading">gnutls_x509_privkey_import</h4>
<a name="gnutls_005fx509_005fprivkey_005fimport"></a><dl>
<dt><a name="index-gnutls_005fx509_005fprivkey_005fimport"></a>Function: <em>int</em> <strong>gnutls_x509_privkey_import</strong> <em>(gnutls_x509_privkey_t <var>key</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>)</em></dt>
<dd><p><var>key</var>: The data to store the parsed key
</p>
<p><var>data</var>: The DER or PEM encoded certificate.
</p>
<p><var>format</var>: One of DER or PEM
</p>
<p>This function will convert the given DER or PEM encoded key to the
native <code>gnutls_x509_privkey_t</code>  format. The output will be stored in
 <code>key</code> .
</p>
<p>If the key is PEM encoded it should have a header that contains &quot;PRIVATE
KEY&quot;. Note that this function falls back to PKCS <code>8</code>  decoding without
password, if the default format fails to import.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fprivkey_005fimport2-1"></a>
<h4 class="subheading">gnutls_x509_privkey_import2</h4>
<a name="gnutls_005fx509_005fprivkey_005fimport2"></a><dl>
<dt><a name="index-gnutls_005fx509_005fprivkey_005fimport2-1"></a>Function: <em>int</em> <strong>gnutls_x509_privkey_import2</strong> <em>(gnutls_x509_privkey_t <var>key</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>, const char * <var>password</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>key</var>: The data to store the parsed key
</p>
<p><var>data</var>: The DER or PEM encoded key.
</p>
<p><var>format</var>: One of DER or PEM
</p>
<p><var>password</var>: A password (optional)
</p>
<p><var>flags</var>: an ORed sequence of gnutls_pkcs_encrypt_flags_t
</p>
<p>This function will import the given DER or PEM encoded key, to 
the native <code>gnutls_x509_privkey_t</code>  format, irrespective of the
input format. The input format is auto-detected.
</p>
<p>The supported formats are basic unencrypted key, PKCS8, PKCS12,
and the openssl format.
</p>
<p>If the provided key is encrypted but no password was given, then
<code>GNUTLS_E_DECRYPTION_FAILED</code>  is returned. Since GnuTLS 3.4.0 this
function will utilize the PIN callbacks if any.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fprivkey_005fimport_005fdsa_005fraw-1"></a>
<h4 class="subheading">gnutls_x509_privkey_import_dsa_raw</h4>
<a name="gnutls_005fx509_005fprivkey_005fimport_005fdsa_005fraw"></a><dl>
<dt><a name="index-gnutls_005fx509_005fprivkey_005fimport_005fdsa_005fraw"></a>Function: <em>int</em> <strong>gnutls_x509_privkey_import_dsa_raw</strong> <em>(gnutls_x509_privkey_t <var>key</var>, const gnutls_datum_t * <var>p</var>, const gnutls_datum_t * <var>q</var>, const gnutls_datum_t * <var>g</var>, const gnutls_datum_t * <var>y</var>, const gnutls_datum_t * <var>x</var>)</em></dt>
<dd><p><var>key</var>: The data to store the parsed key
</p>
<p><var>p</var>: holds the p
</p>
<p><var>q</var>: holds the q
</p>
<p><var>g</var>: holds the g
</p>
<p><var>y</var>: holds the y
</p>
<p><var>x</var>: holds the x
</p>
<p>This function will convert the given DSA raw parameters to the
native <code>gnutls_x509_privkey_t</code>  format.  The output will be stored
in  <code>key</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fprivkey_005fimport_005fecc_005fraw-1"></a>
<h4 class="subheading">gnutls_x509_privkey_import_ecc_raw</h4>
<a name="gnutls_005fx509_005fprivkey_005fimport_005fecc_005fraw"></a><dl>
<dt><a name="index-gnutls_005fx509_005fprivkey_005fimport_005fecc_005fraw"></a>Function: <em>int</em> <strong>gnutls_x509_privkey_import_ecc_raw</strong> <em>(gnutls_x509_privkey_t <var>key</var>, gnutls_ecc_curve_t <var>curve</var>, const gnutls_datum_t * <var>x</var>, const gnutls_datum_t * <var>y</var>, const gnutls_datum_t * <var>k</var>)</em></dt>
<dd><p><var>key</var>: The data to store the parsed key
</p>
<p><var>curve</var>: holds the curve
</p>
<p><var>x</var>: holds the x
</p>
<p><var>y</var>: holds the y
</p>
<p><var>k</var>: holds the k
</p>
<p>This function will convert the given elliptic curve parameters to the
native <code>gnutls_x509_privkey_t</code>  format.  The output will be stored
in  <code>key</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<a name="gnutls_005fx509_005fprivkey_005fimport_005fopenssl-1"></a>
<h4 class="subheading">gnutls_x509_privkey_import_openssl</h4>
<a name="gnutls_005fx509_005fprivkey_005fimport_005fopenssl"></a><dl>
<dt><a name="index-gnutls_005fx509_005fprivkey_005fimport_005fopenssl-1"></a>Function: <em>int</em> <strong>gnutls_x509_privkey_import_openssl</strong> <em>(gnutls_x509_privkey_t <var>key</var>, const gnutls_datum_t * <var>data</var>, const char * <var>password</var>)</em></dt>
<dd><p><var>key</var>: The data to store the parsed key
</p>
<p><var>data</var>: The DER or PEM encoded key.
</p>
<p><var>password</var>: the password to decrypt the key (if it is encrypted).
</p>
<p>This function will convert the given PEM encrypted to 
the native gnutls_x509_privkey_t format. The
output will be stored in  <code>key</code> .  
</p>
<p>The  <code>password</code> should be in ASCII. If the password is not provided
or wrong then <code>GNUTLS_E_DECRYPTION_FAILED</code>  will be returned.
</p>
<p>If the Certificate is PEM encoded it should have a header of
&quot;PRIVATE KEY&quot; and the &quot;DEK-Info&quot; header. 
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fprivkey_005fimport_005fpkcs8-1"></a>
<h4 class="subheading">gnutls_x509_privkey_import_pkcs8</h4>
<a name="gnutls_005fx509_005fprivkey_005fimport_005fpkcs8"></a><dl>
<dt><a name="index-gnutls_005fx509_005fprivkey_005fimport_005fpkcs8"></a>Function: <em>int</em> <strong>gnutls_x509_privkey_import_pkcs8</strong> <em>(gnutls_x509_privkey_t <var>key</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>, const char * <var>password</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>key</var>: The data to store the parsed key
</p>
<p><var>data</var>: The DER or PEM encoded key.
</p>
<p><var>format</var>: One of DER or PEM
</p>
<p><var>password</var>: the password to decrypt the key (if it is encrypted).
</p>
<p><var>flags</var>: 0 if encrypted or GNUTLS_PKCS_PLAIN if not encrypted.
</p>
<p>This function will convert the given DER or PEM encoded PKCS8 2.0
encrypted key to the native gnutls_x509_privkey_t format. The
output will be stored in  <code>key</code> .  Both RSA and DSA keys can be
imported, and flags can only be used to indicate an unencrypted
key.
</p>
<p>The  <code>password</code> can be either ASCII or UTF-8 in the default PBES2
encryption schemas, or ASCII for the PKCS12 schemas.
</p>
<p>If the Certificate is PEM encoded it should have a header of
&quot;ENCRYPTED PRIVATE KEY&quot;, or &quot;PRIVATE KEY&quot;. You only need to
specify the flags if the key is DER encoded, since in that case
the encryption status cannot be auto-detected.
</p>
<p>If the <code>GNUTLS_PKCS_PLAIN</code>  flag is specified and the supplied data
are encrypted then <code>GNUTLS_E_DECRYPTION_FAILED</code>  is returned.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fprivkey_005fimport_005frsa_005fraw-1"></a>
<h4 class="subheading">gnutls_x509_privkey_import_rsa_raw</h4>
<a name="gnutls_005fx509_005fprivkey_005fimport_005frsa_005fraw"></a><dl>
<dt><a name="index-gnutls_005fx509_005fprivkey_005fimport_005frsa_005fraw"></a>Function: <em>int</em> <strong>gnutls_x509_privkey_import_rsa_raw</strong> <em>(gnutls_x509_privkey_t <var>key</var>, const gnutls_datum_t * <var>m</var>, const gnutls_datum_t * <var>e</var>, const gnutls_datum_t * <var>d</var>, const gnutls_datum_t * <var>p</var>, const gnutls_datum_t * <var>q</var>, const gnutls_datum_t * <var>u</var>)</em></dt>
<dd><p><var>key</var>: The data to store the parsed key
</p>
<p><var>m</var>: holds the modulus
</p>
<p><var>e</var>: holds the public exponent
</p>
<p><var>d</var>: holds the private exponent
</p>
<p><var>p</var>: holds the first prime (p)
</p>
<p><var>q</var>: holds the second prime (q)
</p>
<p><var>u</var>: holds the coefficient
</p>
<p>This function will convert the given RSA raw parameters to the
native <code>gnutls_x509_privkey_t</code>  format.  The output will be stored in
 <code>key</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fprivkey_005fimport_005frsa_005fraw2-1"></a>
<h4 class="subheading">gnutls_x509_privkey_import_rsa_raw2</h4>
<a name="gnutls_005fx509_005fprivkey_005fimport_005frsa_005fraw2"></a><dl>
<dt><a name="index-gnutls_005fx509_005fprivkey_005fimport_005frsa_005fraw2"></a>Function: <em>int</em> <strong>gnutls_x509_privkey_import_rsa_raw2</strong> <em>(gnutls_x509_privkey_t <var>key</var>, const gnutls_datum_t * <var>m</var>, const gnutls_datum_t * <var>e</var>, const gnutls_datum_t * <var>d</var>, const gnutls_datum_t * <var>p</var>, const gnutls_datum_t * <var>q</var>, const gnutls_datum_t * <var>u</var>, const gnutls_datum_t * <var>e1</var>, const gnutls_datum_t * <var>e2</var>)</em></dt>
<dd><p><var>key</var>: The data to store the parsed key
</p>
<p><var>m</var>: holds the modulus
</p>
<p><var>e</var>: holds the public exponent
</p>
<p><var>d</var>: holds the private exponent
</p>
<p><var>p</var>: holds the first prime (p)
</p>
<p><var>q</var>: holds the second prime (q)
</p>
<p><var>u</var>: holds the coefficient (optional)
</p>
<p><var>e1</var>: holds e1 = d mod (p-1) (optional)
</p>
<p><var>e2</var>: holds e2 = d mod (q-1) (optional)
</p>
<p>This function will convert the given RSA raw parameters to the
native <code>gnutls_x509_privkey_t</code>  format.  The output will be stored in
 <code>key</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fprivkey_005finit-1"></a>
<h4 class="subheading">gnutls_x509_privkey_init</h4>
<a name="gnutls_005fx509_005fprivkey_005finit"></a><dl>
<dt><a name="index-gnutls_005fx509_005fprivkey_005finit"></a>Function: <em>int</em> <strong>gnutls_x509_privkey_init</strong> <em>(gnutls_x509_privkey_t * <var>key</var>)</em></dt>
<dd><p><var>key</var>: A pointer to the type to be initialized
</p>
<p>This function will initialize a private key type.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fprivkey_005fsec_005fparam-1"></a>
<h4 class="subheading">gnutls_x509_privkey_sec_param</h4>
<a name="gnutls_005fx509_005fprivkey_005fsec_005fparam"></a><dl>
<dt><a name="index-gnutls_005fx509_005fprivkey_005fsec_005fparam"></a>Function: <em>gnutls_sec_param_t</em> <strong>gnutls_x509_privkey_sec_param</strong> <em>(gnutls_x509_privkey_t <var>key</var>)</em></dt>
<dd><p><var>key</var>: a key
</p>
<p>This function will return the security parameter appropriate with
this private key.
</p>
<p><strong>Returns:</strong> On success, a valid security parameter is returned otherwise
<code>GNUTLS_SEC_PARAM_UNKNOWN</code>  is returned.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<a name="gnutls_005fx509_005fprivkey_005fset_005fflags-1"></a>
<h4 class="subheading">gnutls_x509_privkey_set_flags</h4>
<a name="gnutls_005fx509_005fprivkey_005fset_005fflags"></a><dl>
<dt><a name="index-gnutls_005fx509_005fprivkey_005fset_005fflags"></a>Function: <em>void</em> <strong>gnutls_x509_privkey_set_flags</strong> <em>(gnutls_x509_privkey_t <var>key</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>key</var>: A key of type <code>gnutls_x509_privkey_t</code> 
</p>
<p><var>flags</var>: flags from the <code>gnutls_privkey_flags</code> 
</p>
<p>This function will set flags for the specified private key, after
it is generated. Currently this is useful for the <code>GNUTLS_PRIVKEY_FLAG_EXPORT_COMPAT</code> 
to allow exporting a &quot;provable&quot; private key in backwards compatible way.
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<a name="gnutls_005fx509_005fprivkey_005fset_005fpin_005ffunction-1"></a>
<h4 class="subheading">gnutls_x509_privkey_set_pin_function</h4>
<a name="gnutls_005fx509_005fprivkey_005fset_005fpin_005ffunction"></a><dl>
<dt><a name="index-gnutls_005fx509_005fprivkey_005fset_005fpin_005ffunction"></a>Function: <em>void</em> <strong>gnutls_x509_privkey_set_pin_function</strong> <em>(gnutls_x509_privkey_t <var>privkey</var>, gnutls_pin_callback_t <var>fn</var>, void * <var>userdata</var>)</em></dt>
<dd><p><var>privkey</var>: The certificate structure
</p>
<p><var>fn</var>: the callback
</p>
<p><var>userdata</var>: data associated with the callback
</p>
<p>This function will set a callback function to be used when
it is required to access a protected object. This function overrides 
the global function set using <code>gnutls_pkcs11_set_pin_function()</code> .
</p>
<p>Note that this callback is used when decrypting a key.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<a name="gnutls_005fx509_005fprivkey_005fsign_005fdata-1"></a>
<h4 class="subheading">gnutls_x509_privkey_sign_data</h4>
<a name="gnutls_005fx509_005fprivkey_005fsign_005fdata"></a><dl>
<dt><a name="index-gnutls_005fx509_005fprivkey_005fsign_005fdata"></a>Function: <em>int</em> <strong>gnutls_x509_privkey_sign_data</strong> <em>(gnutls_x509_privkey_t <var>key</var>, gnutls_digest_algorithm_t <var>digest</var>, unsigned int <var>flags</var>, const gnutls_datum_t * <var>data</var>, void * <var>signature</var>, size_t * <var>signature_size</var>)</em></dt>
<dd><p><var>key</var>: a key
</p>
<p><var>digest</var>: should be MD5 or SHA1
</p>
<p><var>flags</var>: should be 0 for now
</p>
<p><var>data</var>: holds the data to be signed
</p>
<p><var>signature</var>: will contain the signature
</p>
<p><var>signature_size</var>: holds the size of signature (and will be replaced
by the new size)
</p>
<p>This function will sign the given data using a signature algorithm
supported by the private key. Signature algorithms are always used
together with a hash functions.  Different hash functions may be
used for the RSA algorithm, but only SHA-1 for the DSA keys.
</p>
<p>If the buffer provided is not long enough to hold the output, then
* <code>signature_size</code> is updated and <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  will
be returned.
</p>
<p>Use <code>gnutls_x509_crt_get_preferred_hash_algorithm()</code>  to determine
the hash algorithm.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fprivkey_005fverify_005fparams-1"></a>
<h4 class="subheading">gnutls_x509_privkey_verify_params</h4>
<a name="gnutls_005fx509_005fprivkey_005fverify_005fparams"></a><dl>
<dt><a name="index-gnutls_005fx509_005fprivkey_005fverify_005fparams"></a>Function: <em>int</em> <strong>gnutls_x509_privkey_verify_params</strong> <em>(gnutls_x509_privkey_t <var>key</var>)</em></dt>
<dd><p><var>key</var>: a key
</p>
<p>This function will verify the private key parameters.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005fprivkey_005fverify_005fseed-1"></a>
<h4 class="subheading">gnutls_x509_privkey_verify_seed</h4>
<a name="gnutls_005fx509_005fprivkey_005fverify_005fseed"></a><dl>
<dt><a name="index-gnutls_005fx509_005fprivkey_005fverify_005fseed"></a>Function: <em>int</em> <strong>gnutls_x509_privkey_verify_seed</strong> <em>(gnutls_x509_privkey_t <var>key</var>, gnutls_digest_algorithm_t <var>digest</var>, const void * <var>seed</var>, size_t <var>seed_size</var>)</em></dt>
<dd><p><var>key</var>: should contain a <code>gnutls_x509_privkey_t</code>  type
</p>
<p><var>digest</var>: it contains the digest algorithm used for key generation (if applicable)
</p>
<p><var>seed</var>: the seed of the key to be checked with
</p>
<p><var>seed_size</var>: holds the size of  <code>seed</code> 
</p>
<p>This function will verify that the given private key was generated from
the provided seed. If  <code>seed</code> is <code>NULL</code>  then the seed stored in the  <code>key</code> &rsquo;s structure
will be used for verification.
</p>
<p><strong>Returns:</strong> In case of a verification failure <code>GNUTLS_E_PRIVKEY_VERIFICATION_ERROR</code> 
is returned, and zero or positive code on success.
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<a name="gnutls_005fx509_005frdn_005fget-1"></a>
<h4 class="subheading">gnutls_x509_rdn_get</h4>
<a name="gnutls_005fx509_005frdn_005fget"></a><dl>
<dt><a name="index-gnutls_005fx509_005frdn_005fget"></a>Function: <em>int</em> <strong>gnutls_x509_rdn_get</strong> <em>(const gnutls_datum_t * <var>idn</var>, char * <var>buf</var>, size_t * <var>buf_size</var>)</em></dt>
<dd><p><var>idn</var>: should contain a DER encoded RDN sequence
</p>
<p><var>buf</var>: a pointer to a structure to hold the peer&rsquo;s name
</p>
<p><var>buf_size</var>: holds the size of  <code>buf</code> 
</p>
<p>This function will return the name of the given RDN sequence.  The
name will be in the form &quot;C=xxxx,O=yyyy,CN=zzzz&quot; as described in
RFC4514.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, or
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  is returned and * <code>buf_size</code> is
updated if the provided buffer is not long enough, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005frdn_005fget_005fby_005foid-1"></a>
<h4 class="subheading">gnutls_x509_rdn_get_by_oid</h4>
<a name="gnutls_005fx509_005frdn_005fget_005fby_005foid"></a><dl>
<dt><a name="index-gnutls_005fx509_005frdn_005fget_005fby_005foid"></a>Function: <em>int</em> <strong>gnutls_x509_rdn_get_by_oid</strong> <em>(const gnutls_datum_t * <var>idn</var>, const char * <var>oid</var>, unsigned <var>indx</var>, unsigned int <var>raw_flag</var>, void * <var>buf</var>, size_t * <var>buf_size</var>)</em></dt>
<dd><p><var>idn</var>: should contain a DER encoded RDN sequence
</p>
<p><var>oid</var>: an Object Identifier
</p>
<p><var>indx</var>: In case multiple same OIDs exist in the RDN indicates which
to send. Use 0 for the first one.
</p>
<p><var>raw_flag</var>: If non-zero then the raw DER data are returned.
</p>
<p><var>buf</var>: a pointer to a structure to hold the peer&rsquo;s name
</p>
<p><var>buf_size</var>: holds the size of  <code>buf</code> 
</p>
<p>This function will return the name of the given Object identifier,
of the RDN sequence.  The name will be encoded using the rules
from RFC4514.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, or
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  is returned and * <code>buf_size</code> is
updated if the provided buffer is not long enough, otherwise a
negative error value.
</p></dd></dl>

<a name="gnutls_005fx509_005frdn_005fget_005foid-1"></a>
<h4 class="subheading">gnutls_x509_rdn_get_oid</h4>
<a name="gnutls_005fx509_005frdn_005fget_005foid"></a><dl>
<dt><a name="index-gnutls_005fx509_005frdn_005fget_005foid"></a>Function: <em>int</em> <strong>gnutls_x509_rdn_get_oid</strong> <em>(const gnutls_datum_t * <var>idn</var>, unsigned <var>indx</var>, void * <var>buf</var>, size_t * <var>buf_size</var>)</em></dt>
<dd><p><var>idn</var>: should contain a DER encoded RDN sequence
</p>
<p><var>indx</var>: Indicates which OID to return. Use 0 for the first one.
</p>
<p><var>buf</var>: a pointer to a structure to hold the peer&rsquo;s name OID
</p>
<p><var>buf_size</var>: holds the size of  <code>buf</code> 
</p>
<p>This function will return the specified Object identifier, of the
RDN sequence.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, or
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  is returned and * <code>buf_size</code> is
updated if the provided buffer is not long enough, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.4.0
</p></dd></dl>

<a name="gnutls_005fx509_005ftlsfeatures_005fadd-1"></a>
<h4 class="subheading">gnutls_x509_tlsfeatures_add</h4>
<a name="gnutls_005fx509_005ftlsfeatures_005fadd"></a><dl>
<dt><a name="index-gnutls_005fx509_005ftlsfeatures_005fadd"></a>Function: <em>int</em> <strong>gnutls_x509_tlsfeatures_add</strong> <em>(gnutls_x509_tlsfeatures_t <var>f</var>, unsigned int <var>feature</var>)</em></dt>
<dd><p><var>f</var>: The TLS features
</p>
<p><var>feature</var>: The feature to add
</p>
<p>This function will append a feature to the X.509 TLS features
extension structure.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.5.1
</p></dd></dl>

<a name="gnutls_005fx509_005ftlsfeatures_005fcheck_005fcrt-1"></a>
<h4 class="subheading">gnutls_x509_tlsfeatures_check_crt</h4>
<a name="gnutls_005fx509_005ftlsfeatures_005fcheck_005fcrt"></a><dl>
<dt><a name="index-gnutls_005fx509_005ftlsfeatures_005fcheck_005fcrt"></a>Function: <em>unsigned</em> <strong>gnutls_x509_tlsfeatures_check_crt</strong> <em>(gnutls_x509_tlsfeatures_t <var>feat</var>, gnutls_x509_crt_t <var>cert</var>)</em></dt>
<dd><p><var>feat</var>: a set of TLSFeatures
</p>
<p><var>cert</var>: the certificate to be checked
</p>
<p>This function will check the provided certificate against the TLSFeatures
set in  <code>feat</code> using the RFC7633 p.4.2.2 rules. It will check whether the certificate
contains the features in  <code>feat</code> or a superset.
</p>
<p><strong>Returns:</strong> non-zero if the provided certificate complies, and zero otherwise.
</p>
<p><strong>Since:</strong> 3.5.1
</p></dd></dl>

<a name="gnutls_005fx509_005ftlsfeatures_005fdeinit-1"></a>
<h4 class="subheading">gnutls_x509_tlsfeatures_deinit</h4>
<a name="gnutls_005fx509_005ftlsfeatures_005fdeinit"></a><dl>
<dt><a name="index-gnutls_005fx509_005ftlsfeatures_005fdeinit"></a>Function: <em>void</em> <strong>gnutls_x509_tlsfeatures_deinit</strong> <em>(gnutls_x509_tlsfeatures_t <var>f</var>)</em></dt>
<dd><p><var>f</var>: The TLS features
</p>
<p>This function will deinitialize a X.509 TLS features extension structure
</p>
<p><strong>Since:</strong> 3.5.1
</p></dd></dl>

<a name="gnutls_005fx509_005ftlsfeatures_005fget-1"></a>
<h4 class="subheading">gnutls_x509_tlsfeatures_get</h4>
<a name="gnutls_005fx509_005ftlsfeatures_005fget"></a><dl>
<dt><a name="index-gnutls_005fx509_005ftlsfeatures_005fget"></a>Function: <em>int</em> <strong>gnutls_x509_tlsfeatures_get</strong> <em>(gnutls_x509_tlsfeatures_t <var>f</var>, unsigned <var>idx</var>, unsigned int * <var>feature</var>)</em></dt>
<dd><p><var>f</var>: The TLS features
</p>
<p><var>idx</var>: The index of the feature to get
</p>
<p><var>feature</var>: If the function succeeds, the feature will be stored in this variable
</p>
<p>This function will get a feature from the X.509 TLS features
extension structure.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.5.1
</p></dd></dl>

<a name="gnutls_005fx509_005ftlsfeatures_005finit-1"></a>
<h4 class="subheading">gnutls_x509_tlsfeatures_init</h4>
<a name="gnutls_005fx509_005ftlsfeatures_005finit"></a><dl>
<dt><a name="index-gnutls_005fx509_005ftlsfeatures_005finit"></a>Function: <em>int</em> <strong>gnutls_x509_tlsfeatures_init</strong> <em>(gnutls_x509_tlsfeatures_t * <var>f</var>)</em></dt>
<dd><p><var>f</var>: The TLS features
</p>
<p>This function will initialize a X.509 TLS features extension structure
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.5.1
</p></dd></dl>

<a name="gnutls_005fx509_005ftrust_005flist_005fadd_005fcas-1"></a>
<h4 class="subheading">gnutls_x509_trust_list_add_cas</h4>
<a name="gnutls_005fx509_005ftrust_005flist_005fadd_005fcas"></a><dl>
<dt><a name="index-gnutls_005fx509_005ftrust_005flist_005fadd_005fcas-1"></a>Function: <em>int</em> <strong>gnutls_x509_trust_list_add_cas</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, const gnutls_x509_crt_t * <var>clist</var>, unsigned <var>clist_size</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>clist</var>: A list of CAs
</p>
<p><var>clist_size</var>: The length of the CA list
</p>
<p><var>flags</var>: should be 0 or an or&rsquo;ed sequence of <code>GNUTLS_TL</code>  options.
</p>
<p>This function will add the given certificate authorities
to the trusted list. The list of CAs must not be deinitialized
during this structure&rsquo;s lifetime.
</p>
<p>If the flag <code>GNUTLS_TL_NO_DUPLICATES</code>  is specified, then
the provided  <code>clist</code> entries that are duplicates will not be
added to the list and will be deinitialized.
</p>
<p><strong>Returns:</strong> The number of added elements is returned.
</p>
<p><strong>Since:</strong> 3.0.0
</p></dd></dl>

<a name="gnutls_005fx509_005ftrust_005flist_005fadd_005fcrls-1"></a>
<h4 class="subheading">gnutls_x509_trust_list_add_crls</h4>
<a name="gnutls_005fx509_005ftrust_005flist_005fadd_005fcrls"></a><dl>
<dt><a name="index-gnutls_005fx509_005ftrust_005flist_005fadd_005fcrls-1"></a>Function: <em>int</em> <strong>gnutls_x509_trust_list_add_crls</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, const gnutls_x509_crl_t * <var>crl_list</var>, unsigned <var>crl_size</var>, unsigned int <var>flags</var>, unsigned int <var>verification_flags</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>crl_list</var>: A list of CRLs
</p>
<p><var>crl_size</var>: The length of the CRL list
</p>
<p><var>flags</var>: if GNUTLS_TL_VERIFY_CRL is given the CRLs will be verified before being added.
</p>
<p><var>verification_flags</var>: gnutls_certificate_verify_flags if flags specifies GNUTLS_TL_VERIFY_CRL
</p>
<p>This function will add the given certificate revocation lists
to the trusted list. The list of CRLs must not be deinitialized
during this structure&rsquo;s lifetime.
</p>
<p>This function must be called after <code>gnutls_x509_trust_list_add_cas()</code> 
to allow verifying the CRLs for validity. If the flag <code>GNUTLS_TL_NO_DUPLICATES</code> 
is given, then any provided CRLs that are a duplicate, will be deinitialized
and not added to the list (that assumes that <code>gnutls_x509_trust_list_deinit()</code> 
will be called with all=1).
</p>
<p><strong>Returns:</strong> The number of added elements is returned.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<a name="gnutls_005fx509_005ftrust_005flist_005fadd_005fnamed_005fcrt-1"></a>
<h4 class="subheading">gnutls_x509_trust_list_add_named_crt</h4>
<a name="gnutls_005fx509_005ftrust_005flist_005fadd_005fnamed_005fcrt"></a><dl>
<dt><a name="index-gnutls_005fx509_005ftrust_005flist_005fadd_005fnamed_005fcrt-1"></a>Function: <em>int</em> <strong>gnutls_x509_trust_list_add_named_crt</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, gnutls_x509_crt_t <var>cert</var>, const void * <var>name</var>, size_t <var>name_size</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>cert</var>: A certificate
</p>
<p><var>name</var>: An identifier for the certificate
</p>
<p><var>name_size</var>: The size of the identifier
</p>
<p><var>flags</var>: should be 0.
</p>
<p>This function will add the given certificate to the trusted
list and associate it with a name. The certificate will not be
be used for verification with <code>gnutls_x509_trust_list_verify_crt()</code> 
but with <code>gnutls_x509_trust_list_verify_named_crt()</code>  or
<code>gnutls_x509_trust_list_verify_crt2()</code>  - the latter only since
GnuTLS 3.4.0 and if a hostname is provided.
</p>
<p>In principle this function can be used to set individual &quot;server&quot;
certificates that are trusted by the user for that specific server
but for no other purposes.
</p>
<p>The certificate must not be deinitialized during the lifetime
of the trusted list.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.0.0
</p></dd></dl>

<a name="gnutls_005fx509_005ftrust_005flist_005fadd_005fsystem_005ftrust-1"></a>
<h4 class="subheading">gnutls_x509_trust_list_add_system_trust</h4>
<a name="gnutls_005fx509_005ftrust_005flist_005fadd_005fsystem_005ftrust"></a><dl>
<dt><a name="index-gnutls_005fx509_005ftrust_005flist_005fadd_005fsystem_005ftrust-1"></a>Function: <em>int</em> <strong>gnutls_x509_trust_list_add_system_trust</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, unsigned int <var>tl_flags</var>, unsigned int <var>tl_vflags</var>)</em></dt>
<dd><p><var>list</var>: The structure of the list
</p>
<p><var>tl_flags</var>: GNUTLS_TL_*
</p>
<p><var>tl_vflags</var>: gnutls_certificate_verify_flags if flags specifies GNUTLS_TL_VERIFY_CRL
</p>
<p>This function adds the system&rsquo;s default trusted certificate
authorities to the trusted list. Note that on unsupported systems
this function returns <code>GNUTLS_E_UNIMPLEMENTED_FEATURE</code> .
</p>
<p>This function implies the flag <code>GNUTLS_TL_NO_DUPLICATES</code> .
</p>
<p><strong>Returns:</strong> The number of added elements or a negative error code on error.
</p>
<p><strong>Since:</strong> 3.1
</p></dd></dl>

<a name="gnutls_005fx509_005ftrust_005flist_005fadd_005ftrust_005fdir-1"></a>
<h4 class="subheading">gnutls_x509_trust_list_add_trust_dir</h4>
<a name="gnutls_005fx509_005ftrust_005flist_005fadd_005ftrust_005fdir"></a><dl>
<dt><a name="index-gnutls_005fx509_005ftrust_005flist_005fadd_005ftrust_005fdir"></a>Function: <em>int</em> <strong>gnutls_x509_trust_list_add_trust_dir</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, const char * <var>ca_dir</var>, const char * <var>crl_dir</var>, gnutls_x509_crt_fmt_t <var>type</var>, unsigned int <var>tl_flags</var>, unsigned int <var>tl_vflags</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>ca_dir</var>: A directory containing the CAs (optional)
</p>
<p><var>crl_dir</var>: A directory containing a list of CRLs (optional)
</p>
<p><var>type</var>: The format of the certificates
</p>
<p><var>tl_flags</var>: GNUTLS_TL_*
</p>
<p><var>tl_vflags</var>: gnutls_certificate_verify_flags if flags specifies GNUTLS_TL_VERIFY_CRL
</p>
<p>This function will add the given certificate authorities
to the trusted list. Only directories are accepted by
this function.
</p>
<p><strong>Returns:</strong> The number of added elements is returned.
</p>
<p><strong>Since:</strong> 3.3.6
</p></dd></dl>

<a name="gnutls_005fx509_005ftrust_005flist_005fadd_005ftrust_005ffile-1"></a>
<h4 class="subheading">gnutls_x509_trust_list_add_trust_file</h4>
<a name="gnutls_005fx509_005ftrust_005flist_005fadd_005ftrust_005ffile"></a><dl>
<dt><a name="index-gnutls_005fx509_005ftrust_005flist_005fadd_005ftrust_005ffile-1"></a>Function: <em>int</em> <strong>gnutls_x509_trust_list_add_trust_file</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, const char * <var>ca_file</var>, const char * <var>crl_file</var>, gnutls_x509_crt_fmt_t <var>type</var>, unsigned int <var>tl_flags</var>, unsigned int <var>tl_vflags</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>ca_file</var>: A file containing a list of CAs (optional)
</p>
<p><var>crl_file</var>: A file containing a list of CRLs (optional)
</p>
<p><var>type</var>: The format of the certificates
</p>
<p><var>tl_flags</var>: GNUTLS_TL_*
</p>
<p><var>tl_vflags</var>: gnutls_certificate_verify_flags if flags specifies GNUTLS_TL_VERIFY_CRL
</p>
<p>This function will add the given certificate authorities
to the trusted list. PKCS <code>11</code>  URLs are also accepted, instead
of files, by this function. A PKCS <code>11</code>  URL implies a trust
database (a specially marked module in p11-kit); the URL &quot;pkcs11:&quot;
implies all trust databases in the system. Only a single URL specifying
trust databases can be set; they cannot be stacked with multiple calls.
</p>
<p><strong>Returns:</strong> The number of added elements is returned.
</p>
<p><strong>Since:</strong> 3.1
</p></dd></dl>

<a name="gnutls_005fx509_005ftrust_005flist_005fadd_005ftrust_005fmem-1"></a>
<h4 class="subheading">gnutls_x509_trust_list_add_trust_mem</h4>
<a name="gnutls_005fx509_005ftrust_005flist_005fadd_005ftrust_005fmem"></a><dl>
<dt><a name="index-gnutls_005fx509_005ftrust_005flist_005fadd_005ftrust_005fmem-1"></a>Function: <em>int</em> <strong>gnutls_x509_trust_list_add_trust_mem</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, const gnutls_datum_t * <var>cas</var>, const gnutls_datum_t * <var>crls</var>, gnutls_x509_crt_fmt_t <var>type</var>, unsigned int <var>tl_flags</var>, unsigned int <var>tl_vflags</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>cas</var>: A buffer containing a list of CAs (optional)
</p>
<p><var>crls</var>: A buffer containing a list of CRLs (optional)
</p>
<p><var>type</var>: The format of the certificates
</p>
<p><var>tl_flags</var>: GNUTLS_TL_*
</p>
<p><var>tl_vflags</var>: gnutls_certificate_verify_flags if flags specifies GNUTLS_TL_VERIFY_CRL
</p>
<p>This function will add the given certificate authorities
to the trusted list. 
</p>
<p><strong>Returns:</strong> The number of added elements is returned.
</p>
<p><strong>Since:</strong> 3.1
</p></dd></dl>

<a name="gnutls_005fx509_005ftrust_005flist_005fdeinit-1"></a>
<h4 class="subheading">gnutls_x509_trust_list_deinit</h4>
<a name="gnutls_005fx509_005ftrust_005flist_005fdeinit"></a><dl>
<dt><a name="index-gnutls_005fx509_005ftrust_005flist_005fdeinit"></a>Function: <em>void</em> <strong>gnutls_x509_trust_list_deinit</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, unsigned int <var>all</var>)</em></dt>
<dd><p><var>list</var>: The list to be deinitialized
</p>
<p><var>all</var>: if non-zero it will deinitialize all the certificates and CRLs contained in the structure.
</p>
<p>This function will deinitialize a trust list. Note that the
 <code>all</code> flag should be typically non-zero unless you have specified
your certificates using <code>gnutls_x509_trust_list_add_cas()</code>  and you
want to prevent them from being deinitialized by this function.
</p>
<p><strong>Since:</strong> 3.0.0
</p></dd></dl>

<a name="gnutls_005fx509_005ftrust_005flist_005fget_005fissuer-1"></a>
<h4 class="subheading">gnutls_x509_trust_list_get_issuer</h4>
<a name="gnutls_005fx509_005ftrust_005flist_005fget_005fissuer"></a><dl>
<dt><a name="index-gnutls_005fx509_005ftrust_005flist_005fget_005fissuer"></a>Function: <em>int</em> <strong>gnutls_x509_trust_list_get_issuer</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, gnutls_x509_crt_t <var>cert</var>, gnutls_x509_crt_t * <var>issuer</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>cert</var>: is the certificate to find issuer for
</p>
<p><var>issuer</var>: Will hold the issuer if any. Should be treated as constant.
</p>
<p><var>flags</var>: Use zero or <code>GNUTLS_TL_GET_COPY</code> 
</p>
<p>This function will find the issuer of the given certificate.
If the flag <code>GNUTLS_TL_GET_COPY</code>  is specified a copy of the issuer
will be returned which must be freed using <code>gnutls_x509_crt_deinit()</code> .
In that case the provided  <code>issuer</code> must not be initialized.
</p>
<p>Note that the flag <code>GNUTLS_TL_GET_COPY</code>  is required for this function
to work with PKCS<code>11</code>  trust lists in a thread-safe way.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<a name="gnutls_005fx509_005ftrust_005flist_005fget_005fissuer_005fby_005fdn-1"></a>
<h4 class="subheading">gnutls_x509_trust_list_get_issuer_by_dn</h4>
<a name="gnutls_005fx509_005ftrust_005flist_005fget_005fissuer_005fby_005fdn"></a><dl>
<dt><a name="index-gnutls_005fx509_005ftrust_005flist_005fget_005fissuer_005fby_005fdn"></a>Function: <em>int</em> <strong>gnutls_x509_trust_list_get_issuer_by_dn</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, const gnutls_datum_t * <var>dn</var>, gnutls_x509_crt_t * <var>issuer</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>dn</var>: is the issuer&rsquo;s DN
</p>
<p><var>issuer</var>: Will hold the issuer if any. Should be deallocated after use.
</p>
<p><var>flags</var>: Use zero
</p>
<p>This function will find the issuer with the given name, and
return a copy of the issuer, which must be freed using <code>gnutls_x509_crt_deinit()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<a name="gnutls_005fx509_005ftrust_005flist_005fget_005fissuer_005fby_005fsubject_005fkey_005fid-1"></a>
<h4 class="subheading">gnutls_x509_trust_list_get_issuer_by_subject_key_id</h4>
<a name="gnutls_005fx509_005ftrust_005flist_005fget_005fissuer_005fby_005fsubject_005fkey_005fid"></a><dl>
<dt><a name="index-gnutls_005fx509_005ftrust_005flist_005fget_005fissuer_005fby_005fsubject_005fkey_005fid"></a>Function: <em>int</em> <strong>gnutls_x509_trust_list_get_issuer_by_subject_key_id</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, const gnutls_datum_t * <var>dn</var>, const gnutls_datum_t * <var>spki</var>, gnutls_x509_crt_t * <var>issuer</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>dn</var>: is the issuer&rsquo;s DN (may be <code>NULL</code> )
</p>
<p><var>spki</var>: is the subject key ID
</p>
<p><var>issuer</var>: Will hold the issuer if any. Should be deallocated after use.
</p>
<p><var>flags</var>: Use zero
</p>
<p>This function will find the issuer with the given name and subject key ID, and
return a copy of the issuer, which must be freed using <code>gnutls_x509_crt_deinit()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.2
</p></dd></dl>

<a name="gnutls_005fx509_005ftrust_005flist_005finit-1"></a>
<h4 class="subheading">gnutls_x509_trust_list_init</h4>
<a name="gnutls_005fx509_005ftrust_005flist_005finit"></a><dl>
<dt><a name="index-gnutls_005fx509_005ftrust_005flist_005finit"></a>Function: <em>int</em> <strong>gnutls_x509_trust_list_init</strong> <em>(gnutls_x509_trust_list_t * <var>list</var>, unsigned int <var>size</var>)</em></dt>
<dd><p><var>list</var>: A pointer to the type to be initialized
</p>
<p><var>size</var>: The size of the internal hash table. Use (0) for default size.
</p>
<p>This function will initialize an X.509 trust list structure.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.0.0
</p></dd></dl>

<a name="gnutls_005fx509_005ftrust_005flist_005fiter_005fdeinit-1"></a>
<h4 class="subheading">gnutls_x509_trust_list_iter_deinit</h4>
<a name="gnutls_005fx509_005ftrust_005flist_005fiter_005fdeinit"></a><dl>
<dt><a name="index-gnutls_005fx509_005ftrust_005flist_005fiter_005fdeinit"></a>Function: <em>void</em> <strong>gnutls_x509_trust_list_iter_deinit</strong> <em>(gnutls_x509_trust_list_iter_t <var>iter</var>)</em></dt>
<dd><p><var>iter</var>: The iterator structure to be deinitialized
</p>
<p>This function will deinitialize an iterator structure.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<a name="gnutls_005fx509_005ftrust_005flist_005fiter_005fget_005fca-1"></a>
<h4 class="subheading">gnutls_x509_trust_list_iter_get_ca</h4>
<a name="gnutls_005fx509_005ftrust_005flist_005fiter_005fget_005fca"></a><dl>
<dt><a name="index-gnutls_005fx509_005ftrust_005flist_005fiter_005fget_005fca"></a>Function: <em>int</em> <strong>gnutls_x509_trust_list_iter_get_ca</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, gnutls_x509_trust_list_iter_t * <var>iter</var>, gnutls_x509_crt_t * <var>crt</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>iter</var>: A pointer to an iterator (initially the iterator should be <code>NULL</code> )
</p>
<p><var>crt</var>: where the certificate will be copied
</p>
<p>This function obtains a certificate in the trust list and advances the
iterator to the next certificate. The certificate returned in  <code>crt</code> must be
deallocated with <code>gnutls_x509_crt_deinit()</code> .
</p>
<p>When past the last element is accessed <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
is returned and the iterator is reset.
</p>
<p>After use, the iterator must be deinitialized usin
<code>gnutls_x509_trust_list_iter_deinit()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<a name="gnutls_005fx509_005ftrust_005flist_005fremove_005fcas-1"></a>
<h4 class="subheading">gnutls_x509_trust_list_remove_cas</h4>
<a name="gnutls_005fx509_005ftrust_005flist_005fremove_005fcas"></a><dl>
<dt><a name="index-gnutls_005fx509_005ftrust_005flist_005fremove_005fcas"></a>Function: <em>int</em> <strong>gnutls_x509_trust_list_remove_cas</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, const gnutls_x509_crt_t * <var>clist</var>, unsigned <var>clist_size</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>clist</var>: A list of CAs
</p>
<p><var>clist_size</var>: The length of the CA list
</p>
<p>This function will remove the given certificate authorities
from the trusted list.
</p>
<p>Note that this function can accept certificates and authorities
not yet known. In that case they will be kept in a separate
black list that will be used during certificate verification.
Unlike <code>gnutls_x509_trust_list_add_cas()</code>  there is no deinitialization
restriction for  certificate list provided in this function.
</p>
<p><strong>Returns:</strong> The number of removed elements is returned.
</p>
<p><strong>Since:</strong> 3.1.10
</p></dd></dl>

<a name="gnutls_005fx509_005ftrust_005flist_005fremove_005ftrust_005ffile-1"></a>
<h4 class="subheading">gnutls_x509_trust_list_remove_trust_file</h4>
<a name="gnutls_005fx509_005ftrust_005flist_005fremove_005ftrust_005ffile"></a><dl>
<dt><a name="index-gnutls_005fx509_005ftrust_005flist_005fremove_005ftrust_005ffile"></a>Function: <em>int</em> <strong>gnutls_x509_trust_list_remove_trust_file</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, const char * <var>ca_file</var>, gnutls_x509_crt_fmt_t <var>type</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>ca_file</var>: A file containing a list of CAs
</p>
<p><var>type</var>: The format of the certificates
</p>
<p>This function will remove the given certificate authorities
from the trusted list, and add them into a black list when needed. 
PKCS 11 URLs are also accepted, instead
of files, by this function.
</p>
<p>See also <code>gnutls_x509_trust_list_remove_cas()</code> .
</p>
<p><strong>Returns:</strong> The number of added elements is returned.
</p>
<p><strong>Since:</strong> 3.1.10
</p></dd></dl>

<a name="gnutls_005fx509_005ftrust_005flist_005fremove_005ftrust_005fmem-1"></a>
<h4 class="subheading">gnutls_x509_trust_list_remove_trust_mem</h4>
<a name="gnutls_005fx509_005ftrust_005flist_005fremove_005ftrust_005fmem"></a><dl>
<dt><a name="index-gnutls_005fx509_005ftrust_005flist_005fremove_005ftrust_005fmem"></a>Function: <em>int</em> <strong>gnutls_x509_trust_list_remove_trust_mem</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, const gnutls_datum_t * <var>cas</var>, gnutls_x509_crt_fmt_t <var>type</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>cas</var>: A buffer containing a list of CAs (optional)
</p>
<p><var>type</var>: The format of the certificates
</p>
<p>This function will remove the provided certificate authorities
from the trusted list, and add them into a black list when needed. 
</p>
<p>See also <code>gnutls_x509_trust_list_remove_cas()</code> .
</p>
<p><strong>Returns:</strong> The number of removed elements is returned.
</p>
<p><strong>Since:</strong> 3.1.10
</p></dd></dl>

<a name="gnutls_005fx509_005ftrust_005flist_005fverify_005fcrt-1"></a>
<h4 class="subheading">gnutls_x509_trust_list_verify_crt</h4>
<a name="gnutls_005fx509_005ftrust_005flist_005fverify_005fcrt"></a><dl>
<dt><a name="index-gnutls_005fx509_005ftrust_005flist_005fverify_005fcrt-1"></a>Function: <em>int</em> <strong>gnutls_x509_trust_list_verify_crt</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, gnutls_x509_crt_t * <var>cert_list</var>, unsigned int <var>cert_list_size</var>, unsigned int <var>flags</var>, unsigned int * <var>voutput</var>, gnutls_verify_output_function <var>func</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>cert_list</var>: is the certificate list to be verified
</p>
<p><var>cert_list_size</var>: is the certificate list size
</p>
<p><var>flags</var>: Flags that may be used to change the verification algorithm. Use OR of the gnutls_certificate_verify_flags enumerations.
</p>
<p><var>voutput</var>: will hold the certificate verification output.
</p>
<p><var>func</var>: If non-null will be called on each chain element verification with the output.
</p>
<p>This function will try to verify the given certificate and return
its status. The  <code>voutput</code> parameter will hold an OR&rsquo;ed sequence of
<code>gnutls_certificate_status_t</code>  flags.
</p>
<p>The details of the verification are the same as in <code>gnutls_x509_trust_list_verify_crt2()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<a name="gnutls_005fx509_005ftrust_005flist_005fverify_005fcrt2-1"></a>
<h4 class="subheading">gnutls_x509_trust_list_verify_crt2</h4>
<a name="gnutls_005fx509_005ftrust_005flist_005fverify_005fcrt2"></a><dl>
<dt><a name="index-gnutls_005fx509_005ftrust_005flist_005fverify_005fcrt2-1"></a>Function: <em>int</em> <strong>gnutls_x509_trust_list_verify_crt2</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, gnutls_x509_crt_t * <var>cert_list</var>, unsigned int <var>cert_list_size</var>, gnutls_typed_vdata_st * <var>data</var>, unsigned int <var>elements</var>, unsigned int <var>flags</var>, unsigned int * <var>voutput</var>, gnutls_verify_output_function <var>func</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>cert_list</var>: is the certificate list to be verified
</p>
<p><var>cert_list_size</var>: is the certificate list size
</p>
<p><var>data</var>: an array of typed data
</p>
<p><var>elements</var>: the number of data elements
</p>
<p><var>flags</var>: Flags that may be used to change the verification algorithm. Use OR of the gnutls_certificate_verify_flags enumerations.
</p>
<p><var>voutput</var>: will hold the certificate verification output.
</p>
<p><var>func</var>: If non-null will be called on each chain element verification with the output.
</p>
<p>This function will attempt to verify the given certificate and return
its status. The  <code>voutput</code> parameter will hold an OR&rsquo;ed sequence of
<code>gnutls_certificate_status_t</code>  flags. When a chain of  <code>cert_list_size</code> with 
more than one certificates is provided, the verification status will apply
to the first certificate in the chain that failed verification. The
verification process starts from the end of the chain (from CA to end
certificate).
</p>
<p>Additionally a certificate verification profile can be specified
from the ones in <code>gnutls_certificate_verification_profiles_t</code>  by
ORing the result of <code>GNUTLS_PROFILE_TO_VFLAGS()</code>  to the verification
flags.
</p>
<p>The acceptable  <code>data</code> types are <code>GNUTLS_DT_DNS_HOSTNAME</code>  and <code>GNUTLS_DT_KEY_PURPOSE_OID</code> .
The former accepts as data a null-terminated hostname, and the latter a null-terminated
object identifier (e.g., <code>GNUTLS_KP_TLS_WWW_SERVER</code> ).
If a DNS hostname is provided then this function will compare
the hostname in the certificate against the given. If names do not match the 
<code>GNUTLS_CERT_UNEXPECTED_OWNER</code>  status flag will be set. In addition it
will consider certificates provided with <code>gnutls_x509_trust_list_add_named_crt()</code> .
</p>
<p>If a key purpose OID is provided and the end-certificate contains the extended key
usage PKIX extension, it will be required to match the provided OID
or be marked for any purpose, otherwise verification will fail with 
<code>GNUTLS_CERT_PURPOSE_MISMATCH</code>  status.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value. Note that verification failure will not result to an
error code, only  <code>voutput</code> will be updated.
</p>
<p><strong>Since:</strong> 3.3.8
</p></dd></dl>

<a name="gnutls_005fx509_005ftrust_005flist_005fverify_005fnamed_005fcrt-1"></a>
<h4 class="subheading">gnutls_x509_trust_list_verify_named_crt</h4>
<a name="gnutls_005fx509_005ftrust_005flist_005fverify_005fnamed_005fcrt"></a><dl>
<dt><a name="index-gnutls_005fx509_005ftrust_005flist_005fverify_005fnamed_005fcrt-1"></a>Function: <em>int</em> <strong>gnutls_x509_trust_list_verify_named_crt</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, gnutls_x509_crt_t <var>cert</var>, const void * <var>name</var>, size_t <var>name_size</var>, unsigned int <var>flags</var>, unsigned int * <var>voutput</var>, gnutls_verify_output_function <var>func</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>cert</var>: is the certificate to be verified
</p>
<p><var>name</var>: is the certificate&rsquo;s name
</p>
<p><var>name_size</var>: is the certificate&rsquo;s name size
</p>
<p><var>flags</var>: Flags that may be used to change the verification algorithm. Use OR of the gnutls_certificate_verify_flags enumerations.
</p>
<p><var>voutput</var>: will hold the certificate verification output.
</p>
<p><var>func</var>: If non-null will be called on each chain element verification with the output.
</p>
<p>This function will try to find a certificate that is associated with the provided
name &ndash;see <code>gnutls_x509_trust_list_add_named_crt()</code> . If a match is found the
certificate is considered valid. In addition to that this function will also 
check CRLs. The  <code>voutput</code> parameter will hold an OR&rsquo;ed sequence of 
<code>gnutls_certificate_status_t</code>  flags.
</p>
<p>Additionally a certificate verification profile can be specified
from the ones in <code>gnutls_certificate_verification_profiles_t</code>  by
ORing the result of <code>GNUTLS_PROFILE_TO_VFLAGS()</code>  to the verification
flags.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.0.0
</p></dd></dl>


<hr>
<div class="header">
<p>
Next: <a href="PKCS-7-API.html#PKCS-7-API" accesskey="n" rel="next">PKCS 7 API</a>, Previous: <a href="Datagram-TLS-API.html#Datagram-TLS-API" accesskey="p" rel="prev">Datagram TLS API</a>, Up: <a href="API-reference.html#API-reference" accesskey="u" rel="up">API reference</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Function-and-Data-Index.html#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
