<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This manual is last updated 4 March 2015 for version
3.4.11 of GnuTLS.

Copyright (C) 2001-2015 Free Software Foundation, Inc.\\
Copyright (C) 2001-2015 Nikos Mavrogiannopoulos

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled "GNU Free
Documentation License". -->
<!-- Created by GNU Texinfo 6.0, http://www.gnu.org/software/texinfo/ -->
<head>
<title>GnuTLS 3.4.11: Using a callback to select the certificate to use</title>

<meta name="description" content="GnuTLS 3.4.11: Using a callback to select the certificate to use">
<meta name="keywords" content="GnuTLS 3.4.11: Using a callback to select the certificate to use">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="Function-and-Data-Index.html#Function-and-Data-Index" rel="index" title="Function and Data Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Client-examples.html#Client-examples" rel="up" title="Client examples">
<link href="Verifying-a-certificate.html#Verifying-a-certificate" rel="next" title="Verifying a certificate">
<link href="Obtaining-session-information.html#Obtaining-session-information" rel="prev" title="Obtaining session information">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space: nowrap}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: serif; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
body { 
	margin: 2%;
	padding: 0 5%;
	background: #ffffff;
}
h1,h2,h3,h4,h5 {
    font-weight: bold;
    padding: 5px 5px 5px 5px;
    background-color: #c2e0ff;
    color: #336699;
}
h1 {
    padding: 2em 2em 2em 5%;
    color: white;
    background: #336699;
    text-align: center;
    letter-spacing: 3px;
}
h2 { text-decoration: underline; }
pre {
  margin: 0 5%;
  padding: 0.5em;
}
pre.example,pre.verbatim {
  padding-bottom: 1em;

  border: solid #c2e0ff;
  background: #f0faff;
  border-width: 1px 1px 1px 5px;
  margin: 1em auto;
  width: 90%;
}

div.node {
  margin: 0 -5% 0 -2%;
  padding: 0.5em 0.5em;
  margin-top: 0.5em;
  margin-bottom: 0.5em;
  font-weight: bold;
}
dd, li {
  padding-top: 0.1em;
  padding-bottom: 0.1em;
}
div.float {

  margin-bottom: 0.5em;
  text-align: center;
}

table {
  text-align: left;
  margin-left:auto;
  margin-right:auto;
  border-spacing: 7px;
  width: 50%;
}

th {
  padding: 0;
  color: #336699;
  background-color: #c2e0ff;
  border: solid #000000;
  border-width: 0px;
  margin: 1em auto;
  text-align: center;
  margin-left:auto;
  margin-right:auto;
}

td {
  padding: 0;
  border: solid #000000;
  background-color: #f0faff;
  border-width: 0px;
  margin: 1em auto;
  text-align: left;
  margin-left:auto;
  margin-right:auto;
  padding-left: 1em;
}

dl {
  text-align: left;
  margin-left:auto;
  margin-right:auto;
  width: 50%;

  padding-left: 1em;
  border: solid #c2e0ff;
  background: #f0faff;
  border-width: 5px 1px 1px 1px;
  margin: 1em auto;
}

-->
</style>


</head>

<body lang="en">
<a name="Using-a-callback-to-select-the-certificate-to-use"></a>
<div class="header">
<p>
Next: <a href="Verifying-a-certificate.html#Verifying-a-certificate" accesskey="n" rel="next">Verifying a certificate</a>, Previous: <a href="Obtaining-session-information.html#Obtaining-session-information" accesskey="p" rel="prev">Obtaining session information</a>, Up: <a href="Client-examples.html#Client-examples" accesskey="u" rel="up">Client examples</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Function-and-Data-Index.html#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="Using-a-callback-to-select-the-certificate-to-use-1"></a>
<h4 class="subsection">7.1.6 Using a callback to select the certificate to use</h4>

<p>There are cases where a client holds several certificate and key
pairs, and may not want to load all of them in the credentials
structure.  The following example demonstrates the use of the
certificate selection callback.
</p>
<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;unistd.h&gt;
#include &lt;gnutls/gnutls.h&gt;
#include &lt;gnutls/x509.h&gt;
#include &lt;gnutls/abstract.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

/* A TLS client that loads the certificate and key.
 */

#define MAX_BUF 1024
#define MSG &quot;GET / HTTP/1.0\r\n\r\n&quot;

#define CERT_FILE &quot;cert.pem&quot;
#define KEY_FILE &quot;key.pem&quot;
#define CAFILE &quot;/etc/ssl/certs/ca-certificates.crt&quot;

extern int tcp_connect(void);
extern void tcp_close(int sd);

static int
cert_callback(gnutls_session_t session,
              const gnutls_datum_t * req_ca_rdn, int nreqs,
              const gnutls_pk_algorithm_t * sign_algos,
              int sign_algos_length, gnutls_pcert_st ** pcert,
              unsigned int *pcert_length, gnutls_privkey_t * pkey);

gnutls_pcert_st pcrt;
gnutls_privkey_t key;

/* Load the certificate and the private key.
 */
static void load_keys(void)
{
        int ret;
        gnutls_datum_t data;

        ret = gnutls_load_file(CERT_FILE, &amp;data);
        if (ret &lt; 0) {
                fprintf(stderr, &quot;*** Error loading certificate file.\n&quot;);
                exit(1);
        }

        ret =
            gnutls_pcert_import_x509_raw(&amp;pcrt, &amp;data, GNUTLS_X509_FMT_PEM,
                                         0);
        if (ret &lt; 0) {
                fprintf(stderr, &quot;*** Error loading certificate file: %s\n&quot;,
                        gnutls_strerror(ret));
                exit(1);
        }

        gnutls_free(data.data);

        ret = gnutls_load_file(KEY_FILE, &amp;data);
        if (ret &lt; 0) {
                fprintf(stderr, &quot;*** Error loading key file.\n&quot;);
                exit(1);
        }

        gnutls_privkey_init(&amp;key);

        ret =
            gnutls_privkey_import_x509_raw(key, &amp;data, GNUTLS_X509_FMT_PEM,
                                           NULL, 0);
        if (ret &lt; 0) {
                fprintf(stderr, &quot;*** Error loading key file: %s\n&quot;,
                        gnutls_strerror(ret));
                exit(1);
        }

        gnutls_free(data.data);
}

int main(void)
{
        int ret, sd, ii;
        gnutls_session_t session;
        gnutls_priority_t priorities_cache;
        char buffer[MAX_BUF + 1];
        gnutls_certificate_credentials_t xcred;
        
        if (gnutls_check_version(&quot;3.1.4&quot;) == NULL) {
                fprintf(stderr, &quot;GnuTLS 3.1.4 or later is required for this example\n&quot;);
                exit(1);
        }

        /* for backwards compatibility with gnutls &lt; 3.3.0 */
        gnutls_global_init();

        load_keys();

        /* X509 stuff */
        gnutls_certificate_allocate_credentials(&amp;xcred);

        /* priorities */
        gnutls_priority_init(&amp;priorities_cache, 
                             &quot;NORMAL&quot;, NULL);

        /* sets the trusted cas file
         */
        gnutls_certificate_set_x509_trust_file(xcred, CAFILE,
                                               GNUTLS_X509_FMT_PEM);

        gnutls_certificate_set_retrieve_function2(xcred, cert_callback);

        /* Initialize TLS session 
         */
        gnutls_init(&amp;session, GNUTLS_CLIENT);

        /* Use default priorities */
        gnutls_priority_set(session, priorities_cache);

        /* put the x509 credentials to the current session
         */
        gnutls_credentials_set(session, GNUTLS_CRD_CERTIFICATE, xcred);

        /* connect to the peer
         */
        sd = tcp_connect();

        gnutls_transport_set_int(session, sd);

        /* Perform the TLS handshake
         */
        ret = gnutls_handshake(session);

        if (ret &lt; 0) {
                fprintf(stderr, &quot;*** Handshake failed\n&quot;);
                gnutls_perror(ret);
                goto end;
        } else {
                char *desc;

                desc = gnutls_session_get_desc(session);
                printf(&quot;- Session info: %s\n&quot;, desc);
                gnutls_free(desc);
        }

        gnutls_record_send(session, MSG, strlen(MSG));

        ret = gnutls_record_recv(session, buffer, MAX_BUF);
        if (ret == 0) {
                printf(&quot;- Peer has closed the TLS connection\n&quot;);
                goto end;
        } else if (ret &lt; 0) {
                fprintf(stderr, &quot;*** Error: %s\n&quot;, gnutls_strerror(ret));
                goto end;
        }

        printf(&quot;- Received %d bytes: &quot;, ret);
        for (ii = 0; ii &lt; ret; ii++) {
                fputc(buffer[ii], stdout);
        }
        fputs(&quot;\n&quot;, stdout);

        gnutls_bye(session, GNUTLS_SHUT_RDWR);

      end:

        tcp_close(sd);

        gnutls_deinit(session);

        gnutls_certificate_free_credentials(xcred);
        gnutls_priority_deinit(priorities_cache);

        gnutls_global_deinit();

        return 0;
}



/* This callback should be associated with a session by calling
 * gnutls_certificate_client_set_retrieve_function( session, cert_callback),
 * before a handshake.
 */

static int
cert_callback(gnutls_session_t session,
              const gnutls_datum_t * req_ca_rdn, int nreqs,
              const gnutls_pk_algorithm_t * sign_algos,
              int sign_algos_length, gnutls_pcert_st ** pcert,
              unsigned int *pcert_length, gnutls_privkey_t * pkey)
{
        char issuer_dn[256];
        int i, ret;
        size_t len;
        gnutls_certificate_type_t type;

        /* Print the server's trusted CAs
         */
        if (nreqs &gt; 0)
                printf(&quot;- Server's trusted authorities:\n&quot;);
        else
                printf
                    (&quot;- Server did not send us any trusted authorities names.\n&quot;);

        /* print the names (if any) */
        for (i = 0; i &lt; nreqs; i++) {
                len = sizeof(issuer_dn);
                ret = gnutls_x509_rdn_get(&amp;req_ca_rdn[i], issuer_dn, &amp;len);
                if (ret &gt;= 0) {
                        printf(&quot;   [%d]: &quot;, i);
                        printf(&quot;%s\n&quot;, issuer_dn);
                }
        }

        /* Select a certificate and return it.
         * The certificate must be of any of the &quot;sign algorithms&quot;
         * supported by the server.
         */
        type = gnutls_certificate_type_get(session);
        if (type == GNUTLS_CRT_X509) {
                *pcert_length = 1;
                *pcert = &amp;pcrt;
                *pkey = key;
        } else {
                return -1;
        }

        return 0;

}
</pre>
<hr>
<div class="header">
<p>
Next: <a href="Verifying-a-certificate.html#Verifying-a-certificate" accesskey="n" rel="next">Verifying a certificate</a>, Previous: <a href="Obtaining-session-information.html#Obtaining-session-information" accesskey="p" rel="prev">Obtaining session information</a>, Up: <a href="Client-examples.html#Client-examples" accesskey="u" rel="up">Client examples</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Function-and-Data-Index.html#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
