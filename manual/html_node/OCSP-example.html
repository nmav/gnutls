<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This manual is last updated 4 March 2015 for version
3.4.10 of GnuTLS.

Copyright (C) 2001-2015 Free Software Foundation, Inc.\\
Copyright (C) 2001-2015 Nikos Mavrogiannopoulos

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled "GNU Free
Documentation License". -->
<!-- Created by GNU Texinfo 6.0, http://www.gnu.org/software/texinfo/ -->
<head>
<title>GnuTLS 3.4.10: OCSP example</title>

<meta name="description" content="GnuTLS 3.4.10: OCSP example">
<meta name="keywords" content="GnuTLS 3.4.10: OCSP example">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="Function-and-Data-Index.html#Function-and-Data-Index" rel="index" title="Function and Data Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="GnuTLS-application-examples.html#GnuTLS-application-examples" rel="up" title="GnuTLS application examples">
<link href="Miscellaneous-examples.html#Miscellaneous-examples" rel="next" title="Miscellaneous examples">
<link href="DTLS-echo-server-with-X_002e509-authentication.html#DTLS-echo-server-with-X_002e509-authentication" rel="prev" title="DTLS echo server with X.509 authentication">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space: nowrap}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: serif; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
body { 
	margin: 2%;
	padding: 0 5%;
	background: #ffffff;
}
h1,h2,h3,h4,h5 {
    font-weight: bold;
    padding: 5px 5px 5px 5px;
    background-color: #c2e0ff;
    color: #336699;
}
h1 {
    padding: 2em 2em 2em 5%;
    color: white;
    background: #336699;
    text-align: center;
    letter-spacing: 3px;
}
h2 { text-decoration: underline; }
pre {
  margin: 0 5%;
  padding: 0.5em;
}
pre.example,pre.verbatim {
  padding-bottom: 1em;

  border: solid #c2e0ff;
  background: #f0faff;
  border-width: 1px 1px 1px 5px;
  margin: 1em auto;
  width: 90%;
}

div.node {
  margin: 0 -5% 0 -2%;
  padding: 0.5em 0.5em;
  margin-top: 0.5em;
  margin-bottom: 0.5em;
  font-weight: bold;
}
dd, li {
  padding-top: 0.1em;
  padding-bottom: 0.1em;
}
div.float {

  margin-bottom: 0.5em;
  text-align: center;
}

table {
  text-align: left;
  margin-left:auto;
  margin-right:auto;
  border-spacing: 7px;
  width: 50%;
}

th {
  padding: 0;
  color: #336699;
  background-color: #c2e0ff;
  border: solid #000000;
  border-width: 0px;
  margin: 1em auto;
  text-align: center;
  margin-left:auto;
  margin-right:auto;
}

td {
  padding: 0;
  border: solid #000000;
  background-color: #f0faff;
  border-width: 0px;
  margin: 1em auto;
  text-align: left;
  margin-left:auto;
  margin-right:auto;
  padding-left: 1em;
}

dl {
  text-align: left;
  margin-left:auto;
  margin-right:auto;
  width: 50%;

  padding-left: 1em;
  border: solid #c2e0ff;
  background: #f0faff;
  border-width: 5px 1px 1px 1px;
  margin: 1em auto;
}

-->
</style>


</head>

<body lang="en">
<a name="OCSP-example"></a>
<div class="header">
<p>
Next: <a href="Miscellaneous-examples.html#Miscellaneous-examples" accesskey="n" rel="next">Miscellaneous examples</a>, Previous: <a href="Server-examples.html#Server-examples" accesskey="p" rel="prev">Server examples</a>, Up: <a href="GnuTLS-application-examples.html#GnuTLS-application-examples" accesskey="u" rel="up">GnuTLS application examples</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Function-and-Data-Index.html#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="OCSP-example-1"></a>
<h3 class="section">7.3 OCSP example</h3>

<a name="Generate-OCSP-request"></a><a name="Generate-OCSP-request-1"></a>
<h4 class="subheading">Generate <acronym>OCSP</acronym> request</h4>

<p>A small tool to generate OCSP requests.
</p>
<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;gnutls/gnutls.h&gt;
#include &lt;gnutls/crypto.h&gt;
#include &lt;gnutls/ocsp.h&gt;
#ifndef NO_LIBCURL
#include &lt;curl/curl.h&gt;
#endif
#include &quot;read-file.h&quot;

size_t get_data(void *buffer, size_t size, size_t nmemb, void *userp);
static gnutls_x509_crt_t load_cert(const char *cert_file);
static void _response_info(const gnutls_datum_t * data);
static void
_generate_request(gnutls_datum_t * rdata, gnutls_x509_crt_t cert,
                  gnutls_x509_crt_t issuer, gnutls_datum_t *nonce);
static int
_verify_response(gnutls_datum_t * data, gnutls_x509_crt_t cert,
                 gnutls_x509_crt_t signer, gnutls_datum_t *nonce);

/* This program queries an OCSP server.
   It expects three files. argv[1] containing the certificate to
   be checked, argv[2] holding the issuer for this certificate,
   and argv[3] holding a trusted certificate to verify OCSP's response.
   argv[4] is optional and should hold the server host name.
   
   For simplicity the libcurl library is used.
 */

int main(int argc, char *argv[])
{
        gnutls_datum_t ud, tmp;
        int ret;
        gnutls_datum_t req;
        gnutls_x509_crt_t cert, issuer, signer;
#ifndef NO_LIBCURL
        CURL *handle;
        struct curl_slist *headers = NULL;
#endif
        int v, seq;
        const char *cert_file = argv[1];
        const char *issuer_file = argv[2];
        const char *signer_file = argv[3];
        char *hostname = NULL;
        unsigned char noncebuf[23];
        gnutls_datum_t nonce = { noncebuf, sizeof(noncebuf) };

        gnutls_global_init();

        if (argc &gt; 4)
                hostname = argv[4];

        ret = gnutls_rnd(GNUTLS_RND_NONCE, nonce.data, nonce.size);
        if (ret &lt; 0)
                exit(1);

        cert = load_cert(cert_file);
        issuer = load_cert(issuer_file);
        signer = load_cert(signer_file);

        if (hostname == NULL) {

                for (seq = 0;; seq++) {
                        ret =
                            gnutls_x509_crt_get_authority_info_access(cert,
                                                                      seq,
                                                                      GNUTLS_IA_OCSP_URI,
                                                                      &amp;tmp,
                                                                      NULL);
                        if (ret == GNUTLS_E_UNKNOWN_ALGORITHM)
                                continue;
                        if (ret == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) {
                                fprintf(stderr,
                                        &quot;No URI was found in the certificate.\n&quot;);
                                exit(1);
                        }
                        if (ret &lt; 0) {
                                fprintf(stderr, &quot;error: %s\n&quot;,
                                        gnutls_strerror(ret));
                                exit(1);
                        }

                        printf(&quot;CA issuers URI: %.*s\n&quot;, tmp.size,
                               tmp.data);

                        hostname = malloc(tmp.size + 1);
                        memcpy(hostname, tmp.data, tmp.size);
                        hostname[tmp.size] = 0;

                        gnutls_free(tmp.data);
                        break;
                }

        }

        /* Note that the OCSP servers hostname might be available
         * using gnutls_x509_crt_get_authority_info_access() in the issuer's
         * certificate */

        memset(&amp;ud, 0, sizeof(ud));
        fprintf(stderr, &quot;Connecting to %s\n&quot;, hostname);

        _generate_request(&amp;req, cert, issuer, &amp;nonce);

#ifndef NO_LIBCURL
        curl_global_init(CURL_GLOBAL_ALL);

        handle = curl_easy_init();
        if (handle == NULL)
                exit(1);

        headers =
            curl_slist_append(headers,
                              &quot;Content-Type: application/ocsp-request&quot;);

        curl_easy_setopt(handle, CURLOPT_HTTPHEADER, headers);
        curl_easy_setopt(handle, CURLOPT_POSTFIELDS, (void *) req.data);
        curl_easy_setopt(handle, CURLOPT_POSTFIELDSIZE, req.size);
        curl_easy_setopt(handle, CURLOPT_URL, hostname);
        curl_easy_setopt(handle, CURLOPT_WRITEFUNCTION, get_data);
        curl_easy_setopt(handle, CURLOPT_WRITEDATA, &amp;ud);

        ret = curl_easy_perform(handle);
        if (ret != 0) {
                fprintf(stderr, &quot;curl[%d] error %d\n&quot;, __LINE__, ret);
                exit(1);
        }

        curl_easy_cleanup(handle);
#endif

        _response_info(&amp;ud);

        v = _verify_response(&amp;ud, cert, signer, &amp;nonce);

        gnutls_x509_crt_deinit(cert);
        gnutls_x509_crt_deinit(issuer);
        gnutls_x509_crt_deinit(signer);
        gnutls_global_deinit();

        return v;
}

static void _response_info(const gnutls_datum_t * data)
{
        gnutls_ocsp_resp_t resp;
        int ret;
        gnutls_datum buf;

        ret = gnutls_ocsp_resp_init(&amp;resp);
        if (ret &lt; 0)
                exit(1);

        ret = gnutls_ocsp_resp_import(resp, data);
        if (ret &lt; 0)
                exit(1);

        ret = gnutls_ocsp_resp_print(resp, GNUTLS_OCSP_PRINT_FULL, &amp;buf);
        if (ret != 0)
                exit(1);

        printf(&quot;%.*s&quot;, buf.size, buf.data);
        gnutls_free(buf.data);

        gnutls_ocsp_resp_deinit(resp);
}

static gnutls_x509_crt_t load_cert(const char *cert_file)
{
        gnutls_x509_crt_t crt;
        int ret;
        gnutls_datum_t data;
        size_t size;

        ret = gnutls_x509_crt_init(&amp;crt);
        if (ret &lt; 0)
                exit(1);

        data.data = (void *) read_binary_file(cert_file, &amp;size);
        data.size = size;

        if (!data.data) {
                fprintf(stderr, &quot;Cannot open file: %s\n&quot;, cert_file);
                exit(1);
        }

        ret = gnutls_x509_crt_import(crt, &amp;data, GNUTLS_X509_FMT_PEM);
        free(data.data);
        if (ret &lt; 0) {
                fprintf(stderr, &quot;Cannot import certificate in %s: %s\n&quot;,
                        cert_file, gnutls_strerror(ret));
                exit(1);
        }

        return crt;
}

static void
_generate_request(gnutls_datum_t * rdata, gnutls_x509_crt_t cert,
                  gnutls_x509_crt_t issuer, gnutls_datum_t *nonce)
{
        gnutls_ocsp_req_t req;
        int ret;

        ret = gnutls_ocsp_req_init(&amp;req);
        if (ret &lt; 0)
                exit(1);

        ret = gnutls_ocsp_req_add_cert(req, GNUTLS_DIG_SHA1, issuer, cert);
        if (ret &lt; 0)
                exit(1);


        ret = gnutls_ocsp_req_set_nonce(req, 0, nonce);
        if (ret &lt; 0)
                exit(1);

        ret = gnutls_ocsp_req_export(req, rdata);
        if (ret != 0)
                exit(1);

        gnutls_ocsp_req_deinit(req);

        return;
}

static int
_verify_response(gnutls_datum_t * data, gnutls_x509_crt_t cert,
                 gnutls_x509_crt_t signer, gnutls_datum_t *nonce)
{
        gnutls_ocsp_resp_t resp;
        int ret;
        unsigned verify;
        gnutls_datum_t rnonce;

        ret = gnutls_ocsp_resp_init(&amp;resp);
        if (ret &lt; 0)
                exit(1);

        ret = gnutls_ocsp_resp_import(resp, data);
        if (ret &lt; 0)
                exit(1);

        ret = gnutls_ocsp_resp_check_crt(resp, 0, cert);
        if (ret &lt; 0)
                exit(1);

	ret = gnutls_ocsp_resp_get_nonce(resp, NULL, &amp;rnonce);
	if (ret &lt; 0)
		exit(1);

	if (rnonce.size != nonce-&gt;size || memcmp(nonce-&gt;data, rnonce.data,
		nonce-&gt;size) != 0) {
		exit(1);
	}

        ret = gnutls_ocsp_resp_verify_direct(resp, signer, &amp;verify, 0);
        if (ret &lt; 0)
                exit(1);

        printf(&quot;Verifying OCSP Response: &quot;);
        if (verify == 0)
                printf(&quot;Verification success!\n&quot;);
        else
                printf(&quot;Verification error!\n&quot;);

        if (verify &amp; GNUTLS_OCSP_VERIFY_SIGNER_NOT_FOUND)
                printf(&quot;Signer cert not found\n&quot;);

        if (verify &amp; GNUTLS_OCSP_VERIFY_SIGNER_KEYUSAGE_ERROR)
                printf(&quot;Signer cert keyusage error\n&quot;);

        if (verify &amp; GNUTLS_OCSP_VERIFY_UNTRUSTED_SIGNER)
                printf(&quot;Signer cert is not trusted\n&quot;);

        if (verify &amp; GNUTLS_OCSP_VERIFY_INSECURE_ALGORITHM)
                printf(&quot;Insecure algorithm\n&quot;);

        if (verify &amp; GNUTLS_OCSP_VERIFY_SIGNATURE_FAILURE)
                printf(&quot;Signature failure\n&quot;);

        if (verify &amp; GNUTLS_OCSP_VERIFY_CERT_NOT_ACTIVATED)
                printf(&quot;Signer cert not yet activated\n&quot;);

        if (verify &amp; GNUTLS_OCSP_VERIFY_CERT_EXPIRED)
                printf(&quot;Signer cert expired\n&quot;);

        gnutls_free(rnonce.data);
        gnutls_ocsp_resp_deinit(resp);

        return verify;
}

size_t get_data(void *buffer, size_t size, size_t nmemb, void *userp)
{
        gnutls_datum_t *ud = userp;

        size *= nmemb;

        ud-&gt;data = realloc(ud-&gt;data, size + ud-&gt;size);
        if (ud-&gt;data == NULL) {
                fprintf(stderr, &quot;Not enough memory for the request\n&quot;);
                exit(1);
        }

        memcpy(&amp;ud-&gt;data[ud-&gt;size], buffer, size);
        ud-&gt;size += size;

        return size;
}
</pre>
<hr>
<div class="header">
<p>
Next: <a href="Miscellaneous-examples.html#Miscellaneous-examples" accesskey="n" rel="next">Miscellaneous examples</a>, Previous: <a href="Server-examples.html#Server-examples" accesskey="p" rel="prev">Server examples</a>, Up: <a href="GnuTLS-application-examples.html#GnuTLS-application-examples" accesskey="u" rel="up">GnuTLS application examples</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Function-and-Data-Index.html#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
